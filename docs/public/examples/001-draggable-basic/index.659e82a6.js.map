{"mappings":"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","sources":["examples/001-draggable-basic/index.ts","src/index.ts","src/sensors/sensor.ts","src/sensors/base-sensor.ts","node_modules/eventti/dist/index.js","src/sensors/base-motion-sensor.ts","src/singletons/ticker.ts","node_modules/tikki/dist/index.js","src/sensors/pointer-sensor.ts","src/utils/get-pointer-event-data.ts","src/utils/get-pointer-type.ts","src/utils/get-pointer-id.ts","src/utils/parse-listener-options.ts","src/constants.ts","src/utils/parse-source-events.ts","src/sensors/keyboard-sensor.ts","src/sensors/keyboard-motion-sensor.ts","src/draggable/draggable.ts","src/draggable/draggable-drag.ts","src/draggable/draggable-drag-item.ts","node_modules/mezr/dist/esm/index.js","node_modules/mezr/dist/esm/getContainingBlock.js","node_modules/mezr/dist/esm/utils/getStyle.js","node_modules/mezr/dist/esm/utils/isContainingBlockForFixedElement.js","node_modules/mezr/dist/esm/utils/constants.js","node_modules/mezr/dist/esm/utils/isBlockElement.js","node_modules/mezr/dist/esm/utils/isContainingBlockForAbsoluteElement.js","node_modules/mezr/dist/esm/utils/isDocumentElement.js","node_modules/mezr/dist/esm/getDistance.js","node_modules/mezr/dist/esm/utils/getDistanceBetweenRects.js","node_modules/mezr/dist/esm/utils/isIntersecting.js","node_modules/mezr/dist/esm/utils/getDistanceBetweenPoints.js","node_modules/mezr/dist/esm/utils/getNormalizedRect.js","node_modules/mezr/dist/esm/getRect.js","node_modules/mezr/dist/esm/getWidth.js","node_modules/mezr/dist/esm/utils/isWindow.js","node_modules/mezr/dist/esm/utils/isDocument.js","node_modules/mezr/dist/esm/utils/getWindowWidth.js","node_modules/mezr/dist/esm/utils/getPreciseScrollbarSize.js","node_modules/mezr/dist/esm/utils/getDocumentWidth.js","node_modules/mezr/dist/esm/utils/getElementWidth.js","node_modules/mezr/dist/esm/getHeight.js","node_modules/mezr/dist/esm/utils/getWindowHeight.js","node_modules/mezr/dist/esm/utils/getDocumentHeight.js","node_modules/mezr/dist/esm/utils/getElementHeight.js","node_modules/mezr/dist/esm/getOffset.js","node_modules/mezr/dist/esm/utils/isRectObject.js","node_modules/mezr/dist/esm/utils/getOffsetFromDocument.js","node_modules/mezr/dist/esm/getIntersection.js","node_modules/mezr/dist/esm/getOffsetContainer.js","node_modules/mezr/dist/esm/getOverflow.js","src/utils/get-style.ts","src/utils/get-offset-diff.ts","src/draggable/plugins/auto-scroll-plugin.ts","src/auto-scroll/auto-scroll.ts","src/pool.ts","src/utils/get-intersection-score.ts","src/utils/get-intersection-area.ts","src/utils/get-scroll-element.ts","src/utils/is-window.ts","src/utils/get-scroll-left.ts","src/utils/get-scroll-left-max.ts","src/utils/get-scroll-top.ts","src/utils/get-scroll-top-max.ts","src/utils/is-intersecting.ts","src/singletons/auto-scroll.ts","src/utils/create-pointer-sensor-start-predicate.ts","src/utils/get-scrollable-ancestors.ts","src/utils/is-scrollable.ts","src/utils/is-document.ts","src/utils/create-snap-modifier.ts"],"sourcesContent":["import {\n  Draggable,\n  PointerSensor,\n  KeyboardMotionSensor,\n  createPointerSensorStartPredicate,\n} from '../../src';\n\nconst element = document.querySelector('.draggable') as HTMLElement;\nconst pointerSensor = new PointerSensor(element);\nconst keyboardSensor = new KeyboardMotionSensor();\nconst draggable = new Draggable([pointerSensor, keyboardSensor], {\n  getElements: () => [element],\n  startPredicate: createPointerSensorStartPredicate(),\n  getFrozenProps: () => ['transform'],\n});\n\ndraggable.on('start', () => {\n  element.classList.add('dragging');\n});\n\ndraggable.on('end', () => {\n  element.classList.remove('dragging');\n});\n","export * from './sensors/sensor.js';\n\nexport * from './sensors/base-sensor.js';\n\nexport * from './sensors/base-motion-sensor.js';\n\nexport * from './sensors/pointer-sensor.js';\n\nexport * from './sensors/keyboard-sensor.js';\n\nexport * from './sensors/keyboard-motion-sensor.js';\n\nexport * from './draggable/draggable.js';\n\nexport * from './draggable/plugins/auto-scroll-plugin.js';\n\nexport * from './auto-scroll/auto-scroll.js';\n\nexport * from './singletons/auto-scroll.js';\n\nexport * from './singletons/ticker.js';\n\nexport * from './utils/create-pointer-sensor-start-predicate.js';\n\nexport * from './utils/create-snap-modifier.js';\n","import { EventListenerId } from 'eventti';\n\nexport const SensorEventType = {\n  start: 'start',\n  move: 'move',\n  cancel: 'cancel',\n  end: 'end',\n  destroy: 'destroy',\n} as const;\n\nexport interface SensorStartEvent {\n  type: typeof SensorEventType.start;\n  x: number;\n  y: number;\n}\n\nexport interface SensorMoveEvent {\n  type: typeof SensorEventType.move;\n  x: number;\n  y: number;\n}\n\nexport interface SensorCancelEvent {\n  type: typeof SensorEventType.cancel;\n  x: number;\n  y: number;\n}\n\nexport interface SensorEndEvent {\n  type: typeof SensorEventType.end;\n  x: number;\n  y: number;\n}\n\nexport interface SensorDestroyEvent {\n  type: typeof SensorEventType.destroy;\n}\n\nexport interface SensorEvents {\n  start: SensorStartEvent;\n  move: SensorMoveEvent;\n  cancel: SensorCancelEvent;\n  end: SensorEndEvent;\n  destroy: SensorDestroyEvent;\n}\n\nexport interface Sensor<E extends SensorEvents = SensorEvents> {\n  events: E;\n  on<T extends keyof E>(\n    type: T,\n    listener: (eventData: E[T]) => void,\n    listenerId?: EventListenerId,\n  ): EventListenerId;\n  off<T extends keyof E>(type: T, listenerId: EventListenerId): void;\n  cancel(): void;\n  destroy(): void;\n}\n","import { Emitter, Events, EventListenerId } from 'eventti';\n\nimport { Sensor, SensorEvents, SensorEventType } from './sensor.js';\n\nimport { Writeable } from '../types.js';\n\nexport interface BaseSensorDragData {\n  readonly x: number;\n  readonly y: number;\n}\n\nexport class BaseSensor<E extends SensorEvents = SensorEvents> implements Sensor<E> {\n  declare events: E;\n  readonly drag: BaseSensorDragData | null;\n  readonly isDestroyed: boolean;\n  protected _emitter: Emitter<Events>;\n\n  constructor() {\n    this.drag = null;\n    this.isDestroyed = false;\n    this._emitter = new Emitter();\n  }\n\n  protected _createDragData(data: E['start']): BaseSensorDragData {\n    return {\n      x: data.x,\n      y: data.y,\n    };\n  }\n\n  protected _updateDragData(data: E['move'] | E['end'] | E['cancel']) {\n    if (!this.drag) return;\n    (this.drag.x as Writeable<number>) = data.x;\n    (this.drag.y as Writeable<number>) = data.y;\n  }\n\n  protected _resetDragData() {\n    (this as Writeable<this>).drag = null;\n  }\n\n  protected _start(data: E['start']) {\n    if (this.isDestroyed || this.drag) return;\n    (this as Writeable<this>).drag = this._createDragData(data);\n    this._emitter.emit(SensorEventType.start, data);\n  }\n\n  protected _move(data: E['move']) {\n    if (!this.drag) return;\n    this._updateDragData(data);\n    this._emitter.emit(SensorEventType.move, data);\n  }\n\n  protected _end(data: E['end']) {\n    if (!this.drag) return;\n    this._updateDragData(data);\n    this._emitter.emit(SensorEventType.end, data);\n    this._resetDragData();\n  }\n\n  protected _cancel(data: E['cancel']) {\n    if (!this.drag) return;\n    this._updateDragData(data);\n    this._emitter.emit(SensorEventType.cancel, data);\n    this._resetDragData();\n  }\n\n  on<T extends keyof E>(\n    type: T,\n    listener: (e: E[T]) => void,\n    listenerId?: EventListenerId,\n  ): EventListenerId {\n    return this._emitter.on(type, listener, listenerId);\n  }\n\n  off<T extends keyof E>(type: T, listenerId: EventListenerId): void {\n    this._emitter.off(type, listenerId);\n  }\n\n  cancel() {\n    if (!this.drag) return;\n    this._emitter.emit(SensorEventType.cancel, {\n      type: SensorEventType.cancel,\n      x: this.drag.x,\n      y: this.drag.y,\n    });\n    this._resetDragData();\n  }\n\n  destroy() {\n    if (this.isDestroyed) return;\n    (this as Writeable<this>).isDestroyed = true;\n    this.cancel();\n    this._emitter.emit(SensorEventType.destroy, {\n      type: SensorEventType.destroy,\n    });\n    this._emitter.off();\n  }\n}\n","var r={ADD:\"add\",UPDATE:\"update\",IGNORE:\"ignore\",THROW:\"throw\"},a=class{constructor(n={}){let{dedupe:t=r.ADD,getId:e=()=>Symbol()}=n;this.dedupe=t,this.getId=e,this._events=new Map}_getListeners(n){let t=this._events.get(n);if(t){let{idMap:e}=t;if(e.size)return t.emitList=t.emitList||[...e.values()]}return null}on(n,t,e){let{_events:s}=this,i=s.get(n);i||(i={idMap:new Map,emitList:null},s.set(n,i));let{idMap:d,emitList:o}=i;if(e=e===void 0?this.getId(t):e,d.has(e))switch(this.dedupe){case r.THROW:throw new Error(\"Eventti: duplicate listener id!\");case r.IGNORE:return e;case r.UPDATE:{i.emitList=null;break}default:d.delete(e),i.emitList=null}return d.set(e,t),o?.push(t),e}once(n,t,e){let s=!1;return e=e===void 0?this.getId(t):e,this.on(n,(...i)=>{s||(s=!0,this.off(n,e),t(...i))},e)}off(n,t){if(n===void 0){this._events.clear();return}if(t===void 0){this._events.delete(n);return}let e=this._events.get(n);e&&e.idMap.delete(t)&&(e.emitList=null,e.idMap.size||this._events.delete(n))}emit(n,...t){let e=this._getListeners(n);if(!e)return;let{length:s}=e;if(t.length)if(s===1)e[0](...t);else{let i=0;for(;i<s;i++)e[i](...t)}else if(s===1)e[0]();else{let i=0;for(;i<s;i++)e[i]()}}listenerCount(n){if(n===void 0){let t=0;return this._events.forEach((e,s)=>{t+=this.listenerCount(s)}),t}return this._events.get(n)?.idMap.size||0}};export{a as Emitter,r as EmitterDedupe};\n","import { Sensor, SensorEvents } from './sensor.js';\n\nimport { BaseSensor, BaseSensorDragData } from './base-sensor.js';\n\nimport { Point, Writeable } from '../types.js';\n\nimport { ticker, tickerReadPhase } from '../singletons/ticker.js';\n\nexport interface BaseMotionSensorTickEvent {\n  type: 'tick';\n  time: number;\n  deltaTime: number;\n}\n\nexport interface BaseMotionSensorEvents extends SensorEvents {\n  tick: BaseMotionSensorTickEvent;\n}\n\nexport interface BaseMotionSensorDragData extends BaseSensorDragData {\n  readonly time: number;\n  readonly deltaTime: number;\n}\n\nexport class BaseMotionSensor<E extends BaseMotionSensorEvents = BaseMotionSensorEvents>\n  extends BaseSensor<E>\n  implements Sensor<E>\n{\n  declare events: E;\n  readonly drag: BaseMotionSensorDragData | null;\n  protected _direction: Point;\n  protected _speed: number;\n\n  constructor() {\n    super();\n    this.drag = null;\n    this._direction = { x: 0, y: 0 };\n    this._speed = 0;\n\n    this._tick = this._tick.bind(this);\n  }\n\n  protected _createDragData(data: E['start']): BaseMotionSensorDragData {\n    return {\n      ...super._createDragData(data),\n      time: 0,\n      deltaTime: 0,\n    };\n  }\n\n  protected _start(data: E['start']) {\n    if (this.isDestroyed || this.drag) return;\n    super._start(data);\n    ticker.on(tickerReadPhase, this._tick, this._tick);\n  }\n\n  protected _end(data: E['end']) {\n    if (!this.drag) return;\n    ticker.off(tickerReadPhase, this._tick);\n    super._end(data);\n  }\n\n  protected _cancel(data: E['cancel']) {\n    if (!this.drag) return;\n    ticker.off(tickerReadPhase, this._tick);\n    super._cancel(data);\n  }\n\n  protected _tick(time: number) {\n    if (!this.drag) return;\n    if (time && this.drag.time) {\n      // Update tick time and delta time.\n      (this.drag.deltaTime as Writeable<number>) = time - this.drag.time;\n      (this.drag.time as Writeable<number>) = time;\n\n      // Emit tick event.\n      const tickEvent: BaseMotionSensorTickEvent = {\n        type: 'tick',\n        time: this.drag.time,\n        deltaTime: this.drag.deltaTime,\n      };\n      this._emitter.emit('tick', tickEvent);\n\n      // Make sure the sensor is still active.\n      if (!this.drag) return;\n\n      // Compute the movement offset (delta) by applying time factor to\n      // the speed. The speed is assumed to be provided as pixels-per-second.\n      const speedFactor = this._speed * (this.drag.deltaTime / 1000);\n      const deltaX = this._direction.x * speedFactor;\n      const deltaY = this._direction.y * speedFactor;\n\n      // Trigger move event if the clientX/Y needs change. Note that calling\n      // this._move() automatically updates clientX/Y values also so we don't\n      // need to do it here.\n      if (deltaX || deltaY) {\n        this._move({\n          type: 'move',\n          x: this.drag.x + deltaX,\n          y: this.drag.y + deltaY,\n        });\n      }\n    } else {\n      (this.drag.time as Writeable<number>) = time;\n      (this.drag.deltaTime as Writeable<number>) = 0;\n    }\n  }\n}\n","import { AutoTicker, Phase, FrameCallback } from 'tikki';\n\nexport let tickerReadPhase: Phase = Symbol();\n\nexport let tickerWritePhase: Phase = Symbol();\n\nexport let ticker = new AutoTicker<Phase>({ phases: [tickerReadPhase, tickerWritePhase] });\n\nexport function setTicker(\n  newTicker: AutoTicker<Phase, FrameCallback>,\n  readPhase: Phase,\n  writePhase: Phase,\n) {\n  tickerReadPhase = readPhase;\n  tickerWritePhase = writePhase;\n  ticker = newTicker;\n}\n","import{Emitter as m,EmitterDedupe as p}from\"eventti\";var _=p,o=class{constructor(e={}){let{phases:t=[],dedupe:r,getId:s}=e;this._phases=t,this._emitter=new m({getId:s,dedupe:r}),this._queue=[],this.tick=this.tick.bind(this),this._getListeners=this._emitter._getListeners.bind(this._emitter)}get phases(){return this._phases}set phases(e){this._phases=e}get dedupe(){return this._emitter.dedupe}set dedupe(e){this._emitter.dedupe=e}get getId(){return this._emitter.getId}set getId(e){this._emitter.getId=e}tick(...e){this._assertEmptyQueue(),this._fillQueue(),this._processQueue(...e)}on(e,t,r){return this._emitter.on(e,t,r)}once(e,t,r){return this._emitter.once(e,t,r)}off(e,t){return this._emitter.off(e,t)}count(e){return this._emitter.listenerCount(e)}_assertEmptyQueue(){if(this._queue.length)throw new Error(\"Ticker: Can't tick before the previous tick has finished!\")}_fillQueue(){let e=this._queue,t=this._phases,r=this._getListeners,s=0,a=t.length,n;for(;s<a;s++)n=r(t[s]),n&&e.push(n);return e}_processQueue(...e){let t=this._queue,r=t.length;if(!r)return;let s=0,a=0,n,c;for(;s<r;s++)for(n=t[s],a=0,c=n.length;a<c;a++)n[a](...e);t.length=0}};function u(i=60){if(typeof requestAnimationFrame==\"function\"&&typeof cancelAnimationFrame==\"function\")return e=>{let t=requestAnimationFrame(e);return()=>cancelAnimationFrame(t)};{let e=1e3/i,t=typeof performance>\"u\"?()=>Date.now():()=>performance.now();return r=>{let s=setTimeout(()=>r(t()),e);return()=>clearTimeout(s)}}}var l=class extends o{constructor(e={}){let{paused:t=!1,onDemand:r=!1,requestFrame:s=u(),...a}=e;super(a),this._paused=t,this._onDemand=r,this._requestFrame=s,this._cancelFrame=null,this._empty=!0,!t&&!r&&this._request()}get phases(){return this._phases}set phases(e){this._phases=e,e.length?(this._empty=!1,this._request()):this._empty=!0}get paused(){return this._paused}set paused(e){this._paused=e,e?this._cancel():this._request()}get onDemand(){return this._onDemand}set onDemand(e){this._onDemand=e,e||this._request()}get requestFrame(){return this._requestFrame}set requestFrame(e){this._requestFrame!==e&&(this._requestFrame=e,this._cancelFrame&&(this._cancel(),this._request()))}tick(...e){if(this._assertEmptyQueue(),this._cancelFrame=null,this._onDemand||this._request(),!this._empty){if(!this._fillQueue().length){this._empty=!0;return}this._onDemand&&this._request(),this._processQueue(...e)}}on(e,t,r){let s=super.on(e,t,r);return this._empty=!1,this._request(),s}once(e,t,r){let s=super.once(e,t,r);return this._empty=!1,this._request(),s}_request(){this._paused||this._cancelFrame||(this._cancelFrame=this._requestFrame(this.tick))}_cancel(){this._cancelFrame&&(this._cancelFrame(),this._cancelFrame=null)}};function I(i){return e=>{let t=i.requestAnimationFrame(e);return()=>i.cancelAnimationFrame(t)}}export{l as AutoTicker,o as Ticker,_ as TickerDedupe,u as createRequestFrame,I as createXrRequestFrame};\n","import { Emitter, Events, EventListenerId } from 'eventti';\n\nimport { ListenerOptions, Writeable, PointerType } from '../types.js';\n\nimport {\n  Sensor,\n  SensorEventType,\n  SensorStartEvent,\n  SensorMoveEvent,\n  SensorCancelEvent,\n  SensorEndEvent,\n  SensorDestroyEvent,\n} from './sensor.js';\n\nimport { getPointerEventData } from '../utils/get-pointer-event-data.js';\n\nimport { getPointerType } from '../utils/get-pointer-type.js';\n\nimport { getPointerId } from '../utils/get-pointer-id.js';\n\nimport { parseListenerOptions } from '../utils/parse-listener-options.js';\n\nimport { parseSourceEvents } from '../utils/parse-source-events.js';\n\nconst POINTER_EVENTS = {\n  start: 'pointerdown',\n  move: 'pointermove',\n  cancel: 'pointercancel',\n  end: 'pointerup',\n} as const;\n\nconst TOUCH_EVENTS = {\n  start: 'touchstart',\n  move: 'touchmove',\n  cancel: 'touchcancel',\n  end: 'touchend',\n} as const;\n\nconst MOUSE_EVENTS = {\n  start: 'mousedown',\n  move: 'mousemove',\n  cancel: '',\n  end: 'mouseup',\n} as const;\n\nconst SOURCE_EVENTS = {\n  pointer: POINTER_EVENTS,\n  touch: TOUCH_EVENTS,\n  mouse: MOUSE_EVENTS,\n} as const;\n\ntype PointerSensorSourceEvent = PointerEvent | TouchEvent | MouseEvent;\n\nexport type PointerSensorDragData = {\n  readonly pointerId: number;\n  readonly pointerType: PointerType;\n  readonly x: number;\n  readonly y: number;\n};\n\nexport interface PointerSensorSettings {\n  listenerOptions: ListenerOptions;\n  sourceEvents: keyof typeof SOURCE_EVENTS | 'auto';\n  startPredicate: (e: PointerSensorSourceEvent) => boolean;\n}\n\nexport interface PointerSensorStartEvent extends SensorStartEvent {\n  pointerId: number;\n  pointerType: PointerType;\n  srcEvent: PointerSensorSourceEvent;\n  target: EventTarget | null;\n}\n\nexport interface PointerSensorMoveEvent extends SensorMoveEvent {\n  pointerId: number;\n  pointerType: PointerType;\n  srcEvent: PointerSensorSourceEvent;\n  target: EventTarget | null;\n}\n\nexport interface PointerSensorCancelEvent extends SensorCancelEvent {\n  pointerId: number;\n  pointerType: PointerType;\n  srcEvent: PointerSensorSourceEvent | null;\n  target: EventTarget | null;\n}\n\nexport interface PointerSensorEndEvent extends SensorEndEvent {\n  pointerId: number;\n  pointerType: PointerType;\n  srcEvent: PointerSensorSourceEvent | null;\n  target: EventTarget | null;\n}\n\nexport interface PointerSensorDestroyEvent extends SensorDestroyEvent {}\n\nexport interface PointerSensorEvents {\n  start: PointerSensorStartEvent;\n  move: PointerSensorMoveEvent;\n  cancel: PointerSensorCancelEvent;\n  end: PointerSensorEndEvent;\n  destroy: PointerSensorDestroyEvent;\n}\n\nexport class PointerSensor<E extends PointerSensorEvents = PointerSensorEvents>\n  implements Sensor<E>\n{\n  declare events: E;\n\n  /**\n   * The observed element or window.\n   */\n  readonly element: Element | Window;\n\n  /**\n   * Current drag data, null if drag is not active.\n   */\n  readonly drag: PointerSensorDragData | null;\n\n  /**\n   * Indicator if the instance is destroyed.\n   */\n  readonly isDestroyed: boolean;\n\n  /**\n   * The options object to be used for `addEventListener`.\n   */\n  protected _startPredicate: (e: PointerSensorSourceEvent) => boolean;\n\n  /**\n   * The options object to be used for `addEventListener`.\n   */\n  protected _listenerOptions: ListenerOptions;\n\n  /**\n   * Type of tracked source events.\n   */\n  protected _sourceEvents: keyof typeof SOURCE_EVENTS;\n\n  /**\n   * Indicator if window's listener's are bound.\n   */\n  protected _areWindowListenersBound: boolean;\n\n  /**\n   * Internal event emitter instance.\n   */\n  protected _emitter: Emitter<Events>;\n\n  constructor(element: Element | Window, options: Partial<PointerSensorSettings> = {}) {\n    const {\n      listenerOptions = {},\n      sourceEvents = 'auto',\n      startPredicate = (e) => ('button' in e && e.button > 0 ? false : true),\n    } = options;\n\n    this.element = element;\n    this.drag = null;\n    this.isDestroyed = false;\n\n    this._areWindowListenersBound = false;\n    this._startPredicate = startPredicate;\n    this._listenerOptions = parseListenerOptions(listenerOptions);\n    this._sourceEvents = parseSourceEvents(sourceEvents);\n    this._emitter = new Emitter();\n\n    this._onStart = this._onStart.bind(this);\n    this._onMove = this._onMove.bind(this);\n    this._onCancel = this._onCancel.bind(this);\n    this._onEnd = this._onEnd.bind(this);\n\n    // Listen to start event.\n    element.addEventListener(\n      SOURCE_EVENTS[this._sourceEvents].start,\n      this._onStart as EventListener,\n      this._listenerOptions,\n    );\n  }\n\n  /**\n   * Check if the provided event contains the tracked pointer id or in the case\n   * of touch event if the first changed touch is the tracked touch object and\n   * return the event or touch object. Otherwise return null.\n   */\n  protected _getTrackedPointerEventData(\n    e: PointerSensorSourceEvent,\n  ): PointerEvent | MouseEvent | Touch | null {\n    return this.drag ? getPointerEventData(e, this.drag.pointerId) : null;\n  }\n\n  /**\n   * Listener for start event.\n   */\n  protected _onStart(e: PointerSensorSourceEvent) {\n    if (this.isDestroyed || this.drag) return;\n\n    // Make sure start predicate is fulfilled.\n    if (!this._startPredicate(e)) return;\n\n    // Try to get pointer id.\n    const pointerId = getPointerId(e);\n    if (pointerId === null) return;\n\n    // Try to get pointer.\n    const pointerEventData = getPointerEventData(e, pointerId);\n    if (pointerEventData === null) return;\n\n    // Create drag data.\n    const dragData: PointerSensorDragData = {\n      pointerId,\n      pointerType: getPointerType(e),\n      x: pointerEventData.clientX,\n      y: pointerEventData.clientY,\n    };\n\n    // Set drag data.\n    (this as Writeable<this>).drag = dragData;\n\n    // Emit start event.\n    const eventData: PointerSensorStartEvent = {\n      ...dragData,\n      type: SensorEventType.start,\n      srcEvent: e,\n      target: pointerEventData.target,\n    };\n    this._emitter.emit(eventData.type, eventData);\n\n    // If the drag procedure was not reset within the start procedure let's\n    // activate the instance (start listening to move/cancel/end events).\n    if (this.drag) {\n      this._bindWindowListeners();\n    }\n  }\n\n  /**\n   * Listener for move event.\n   */\n  protected _onMove(e: PointerSensorSourceEvent) {\n    if (!this.drag) return;\n\n    const pointerEventData = this._getTrackedPointerEventData(e);\n    if (!pointerEventData) return;\n\n    (this.drag.x as Writeable<number>) = pointerEventData.clientX;\n    (this.drag.y as Writeable<number>) = pointerEventData.clientY;\n\n    const eventData: PointerSensorMoveEvent = {\n      type: SensorEventType.move,\n      srcEvent: e,\n      target: pointerEventData.target,\n      ...this.drag,\n    };\n\n    this._emitter.emit(eventData.type, eventData);\n  }\n\n  /**\n   * Listener for cancel event.\n   */\n  protected _onCancel(e: PointerEvent | TouchEvent) {\n    if (!this.drag) return;\n\n    const pointerEventData = this._getTrackedPointerEventData(e);\n    if (!pointerEventData) return;\n\n    (this.drag.x as Writeable<number>) = pointerEventData.clientX;\n    (this.drag.y as Writeable<number>) = pointerEventData.clientY;\n\n    const eventData: PointerSensorCancelEvent = {\n      type: SensorEventType.cancel,\n      srcEvent: e,\n      target: pointerEventData.target,\n      ...this.drag,\n    };\n\n    this._emitter.emit(eventData.type, eventData);\n\n    this._resetDrag();\n  }\n\n  /**\n   * Listener for end event.\n   */\n  protected _onEnd(e: PointerSensorSourceEvent) {\n    if (!this.drag) return;\n\n    const pointerEventData = this._getTrackedPointerEventData(e);\n    if (!pointerEventData) return;\n\n    (this.drag.x as Writeable<number>) = pointerEventData.clientX;\n    (this.drag.y as Writeable<number>) = pointerEventData.clientY;\n\n    const eventData: PointerSensorEndEvent = {\n      type: SensorEventType.end,\n      srcEvent: e,\n      target: pointerEventData.target,\n      ...this.drag,\n    };\n\n    this._emitter.emit(eventData.type, eventData);\n\n    this._resetDrag();\n  }\n\n  /**\n   * Bind window event listeners for move/end/cancel.\n   */\n  protected _bindWindowListeners() {\n    if (this._areWindowListenersBound) return;\n    const { move, end, cancel } = SOURCE_EVENTS[this._sourceEvents];\n    window.addEventListener(move, this._onMove, this._listenerOptions);\n    window.addEventListener(end, this._onEnd, this._listenerOptions);\n    if (cancel) {\n      window.addEventListener(cancel, this._onCancel, this._listenerOptions);\n    }\n    this._areWindowListenersBound = true;\n  }\n\n  /**\n   * Unbind window event listeners for move/end/cancel.\n   */\n  protected _unbindWindowListeners() {\n    if (this._areWindowListenersBound) {\n      const { move, end, cancel } = SOURCE_EVENTS[this._sourceEvents];\n      window.removeEventListener(move, this._onMove, this._listenerOptions);\n      window.removeEventListener(end, this._onEnd, this._listenerOptions);\n      if (cancel) {\n        window.removeEventListener(cancel, this._onCancel, this._listenerOptions);\n      }\n      this._areWindowListenersBound = false;\n    }\n  }\n\n  /**\n   * Reset drag data.\n   */\n  protected _resetDrag() {\n    (this as Writeable<this>).drag = null;\n    this._unbindWindowListeners();\n  }\n\n  /**\n   * Forcefully cancel the drag process.\n   */\n  cancel() {\n    if (!this.drag) return;\n\n    const eventData: PointerSensorCancelEvent = {\n      type: SensorEventType.cancel,\n      srcEvent: null,\n      target: null,\n      ...this.drag,\n    };\n\n    this._emitter.emit(eventData.type, eventData);\n\n    this._resetDrag();\n  }\n\n  /**\n   * Update the instance's settings.\n   */\n  updateSettings(options: Partial<PointerSensorSettings>) {\n    if (this.isDestroyed) return;\n\n    const { listenerOptions, sourceEvents, startPredicate } = options;\n    const nextSourceEvents = parseSourceEvents(sourceEvents);\n    const nextListenerOptions = parseListenerOptions(listenerOptions);\n\n    // Update start predicate if needed.\n    if (startPredicate && this._startPredicate !== startPredicate) {\n      this._startPredicate = startPredicate;\n    }\n\n    // Update listener options and/or source events if needed.\n    if (\n      (listenerOptions &&\n        (this._listenerOptions.capture !== nextListenerOptions.capture ||\n          this._listenerOptions.passive === nextListenerOptions.passive)) ||\n      (sourceEvents && this._sourceEvents !== nextSourceEvents)\n    ) {\n      // Unbind start listener.\n      this.element.removeEventListener(\n        SOURCE_EVENTS[this._sourceEvents].start,\n        this._onStart as EventListener,\n        this._listenerOptions,\n      );\n\n      // Unbind window listeners.\n      this._unbindWindowListeners();\n\n      // Cancel current drag process.\n      this.cancel();\n\n      // Update options to instace.\n      if (sourceEvents) {\n        this._sourceEvents = nextSourceEvents;\n      }\n      if (listenerOptions && nextListenerOptions) {\n        this._listenerOptions = nextListenerOptions;\n      }\n\n      // Rebind start listener with new options.\n      this.element.addEventListener(\n        SOURCE_EVENTS[this._sourceEvents].start,\n        this._onStart as EventListener,\n        this._listenerOptions,\n      );\n    }\n  }\n\n  /**\n   * Bind a drag event listener.\n   */\n  on<T extends keyof E>(\n    type: T,\n    listener: (e: E[T]) => void,\n    listenerId?: EventListenerId,\n  ): EventListenerId {\n    return this._emitter.on(type, listener, listenerId);\n  }\n\n  /**\n   * Unbind a drag event listener.\n   */\n  off<T extends keyof E>(type: T, listenerId: EventListenerId): void {\n    this._emitter.off(type, listenerId);\n  }\n\n  /**\n   * Destroy the instance and unbind all drag event listeners.\n   */\n  destroy() {\n    if (this.isDestroyed) return;\n\n    // Mark as destroyed.\n    (this as Writeable<this>).isDestroyed = true;\n\n    // Cancel any ongoing drag process.\n    this.cancel();\n\n    // Emit destroy event.\n    this._emitter.emit(SensorEventType.destroy, {\n      type: SensorEventType.destroy,\n    });\n\n    // Destroy emitter.\n    this._emitter.off();\n\n    // Unbind start event listeners.\n    this.element.removeEventListener(\n      SOURCE_EVENTS[this._sourceEvents].start,\n      this._onStart as EventListener,\n      this._listenerOptions,\n    );\n  }\n}\n","export function getPointerEventData(\n  e: PointerEvent | TouchEvent | MouseEvent,\n  id: number,\n): PointerEvent | MouseEvent | Touch | null {\n  // If we have a pointer event return the whole event if there's a match, and\n  // null otherwise.\n  if ('pointerId' in e) {\n    return e.pointerId === id ? e : null;\n  }\n\n  // For touch events let's check if there's a changed touch object that matches\n  // the pointerId in which case return the touch object.\n  if ('changedTouches' in e) {\n    let i = 0;\n    for (; i < e.changedTouches.length; i++) {\n      if (e.changedTouches[i].identifier === id) {\n        return e.changedTouches[i];\n      }\n    }\n    return null;\n  }\n\n  // For mouse/other events let's assume there's only one pointer and just\n  // return the event.\n  return e;\n}\n","import { PointerType } from '../types.js';\n\nexport function getPointerType(e: PointerEvent | TouchEvent | MouseEvent): PointerType {\n  return 'pointerType' in e ? (e.pointerType as PointerType) : 'touches' in e ? 'touch' : 'mouse';\n}\n","export function getPointerId(e: PointerEvent | TouchEvent | MouseEvent) {\n  // If we have pointer id available let's use it.\n  if ('pointerId' in e) return e.pointerId;\n  // For touch events let's get the first changed touch's identifier.\n  if ('changedTouches' in e) return e.changedTouches[0] ? e.changedTouches[0].identifier : null;\n  // For mouse/other events let's provide a static id. And let's make it a\n  // negative number so it has it has not chance of clashing with touch/pointer\n  // ids.\n  return -1;\n}\n","import { HAS_PASSIVE_EVENTS } from '../constants.js';\n\nimport { ListenerOptions } from '../types.js';\n\nexport function parseListenerOptions(options: ListenerOptions = {}): ListenerOptions {\n  const { capture = true, passive = true } = options;\n  if (HAS_PASSIVE_EVENTS) {\n    return { capture, passive };\n  } else {\n    return { capture };\n  }\n}\n","export const IS_BROWSER = typeof window !== 'undefined' && typeof window.document !== 'undefined';\n\nexport const HAS_PASSIVE_EVENTS = (() => {\n  let isPassiveEventsSupported = false;\n  try {\n    const passiveOpts = Object.defineProperty({}, 'passive', {\n      get: function () {\n        isPassiveEventsSupported = true;\n      },\n    });\n    // @ts-ignore\n    window.addEventListener('testPassive', null, passiveOpts);\n    // @ts-ignore\n    window.removeEventListener('testPassive', null, passiveOpts);\n  } catch (e) {}\n  return isPassiveEventsSupported;\n})();\n\nexport const HAS_TOUCH_EVENTS = IS_BROWSER && 'ontouchstart' in window;\n\nexport const HAS_POINTER_EVENTS = IS_BROWSER && !!window.PointerEvent;\n\nexport const IS_SAFARI = !!(\n  IS_BROWSER &&\n  navigator.vendor &&\n  navigator.vendor.indexOf('Apple') > -1 &&\n  navigator.userAgent &&\n  navigator.userAgent.indexOf('CriOS') == -1 &&\n  navigator.userAgent.indexOf('FxiOS') == -1\n);\n","import { HAS_POINTER_EVENTS, HAS_TOUCH_EVENTS } from '../constants.js';\n\nexport function parseSourceEvents(\n  sourceEvents: 'pointer' | 'touch' | 'mouse' | 'auto' | undefined,\n): 'pointer' | 'touch' | 'mouse' {\n  return sourceEvents === 'auto' || sourceEvents === undefined\n    ? HAS_POINTER_EVENTS\n      ? 'pointer'\n      : HAS_TOUCH_EVENTS\n        ? 'touch'\n        : 'mouse'\n    : sourceEvents;\n}\n","import {\n  Sensor,\n  SensorStartEvent,\n  SensorMoveEvent,\n  SensorCancelEvent,\n  SensorEndEvent,\n  SensorDestroyEvent,\n} from './sensor.js';\n\nimport { BaseSensor } from './base-sensor.js';\n\nimport { Point } from 'types.js';\n\nexport type KeyboardSensorPredicate = (\n  e: KeyboardEvent,\n  sensor: KeyboardSensor,\n  moveDistance: Point,\n) => Point | null | undefined;\n\nexport interface KeyboardSensorSettings {\n  moveDistance: number | Point;\n  startPredicate: KeyboardSensorPredicate;\n  movePredicate: KeyboardSensorPredicate;\n  cancelPredicate: KeyboardSensorPredicate;\n  endPredicate: KeyboardSensorPredicate;\n}\n\nexport interface KeyboardSensorStartEvent extends SensorStartEvent {\n  srcEvent: KeyboardEvent;\n}\n\nexport interface KeyboardSensorMoveEvent extends SensorMoveEvent {\n  srcEvent: KeyboardEvent;\n}\n\nexport interface KeyboardSensorCancelEvent extends SensorCancelEvent {\n  srcEvent: KeyboardEvent;\n}\n\nexport interface KeyboardSensorEndEvent extends SensorEndEvent {\n  srcEvent: KeyboardEvent;\n}\n\nexport interface KeyboardSensorDestroyEvent extends SensorDestroyEvent {}\n\nexport interface KeyboardSensorEvents {\n  start: KeyboardSensorStartEvent;\n  move: KeyboardSensorMoveEvent;\n  cancel: KeyboardSensorCancelEvent;\n  end: KeyboardSensorEndEvent;\n  destroy: KeyboardSensorDestroyEvent;\n}\n\nexport class KeyboardSensor<E extends KeyboardSensorEvents = KeyboardSensorEvents>\n  extends BaseSensor<E>\n  implements Sensor<E>\n{\n  declare events: E;\n  protected _moveDistance: Point;\n  protected _startPredicate: KeyboardSensorPredicate;\n  protected _movePredicate: KeyboardSensorPredicate;\n  protected _cancelPredicate: KeyboardSensorPredicate;\n  protected _endPredicate: KeyboardSensorPredicate;\n\n  constructor(options: Partial<KeyboardSensorSettings> = {}) {\n    super();\n\n    const {\n      moveDistance = 25,\n      startPredicate = (e) => {\n        if (e.key === 'Enter' || e.key === ' ') {\n          if (document.activeElement && document.activeElement !== document.body) {\n            const { left, top } = document.activeElement.getBoundingClientRect();\n            return { x: left, y: top };\n          }\n        }\n        return null;\n      },\n      movePredicate = (e, sensor, moveDistance) => {\n        if (!sensor.drag) return null;\n\n        switch (e.key) {\n          case 'ArrowLeft': {\n            return {\n              x: sensor.drag.x - moveDistance.x,\n              y: sensor.drag.y,\n            };\n          }\n          case 'ArrowRight': {\n            return {\n              x: sensor.drag.x + moveDistance.x,\n              y: sensor.drag.y,\n            };\n          }\n          case 'ArrowUp': {\n            return {\n              x: sensor.drag.x,\n              y: sensor.drag.y - moveDistance.y,\n            };\n          }\n          case 'ArrowDown': {\n            return {\n              x: sensor.drag.x,\n              y: sensor.drag.y + moveDistance.y,\n            };\n          }\n          default: {\n            return null;\n          }\n        }\n      },\n      cancelPredicate = (e, sensor) => {\n        if (sensor.drag && e.key === 'Escape') {\n          return { x: sensor.drag.x, y: sensor.drag.y };\n        }\n        return null;\n      },\n      endPredicate = (e, sensor) => {\n        if (sensor.drag && (e.key === 'Enter' || e.key === ' ')) {\n          return { x: sensor.drag.x, y: sensor.drag.y };\n        }\n        return null;\n      },\n    } = options;\n\n    this._moveDistance =\n      typeof moveDistance === 'number' ? { x: moveDistance, y: moveDistance } : { ...moveDistance };\n    this._startPredicate = startPredicate;\n    this._movePredicate = movePredicate;\n    this._cancelPredicate = cancelPredicate;\n    this._endPredicate = endPredicate;\n\n    this.cancel = this.cancel.bind(this);\n    this._onKeyDown = this._onKeyDown.bind(this);\n\n    document.addEventListener('keydown', this._onKeyDown);\n    window.addEventListener('blur', this.cancel);\n    window.addEventListener('visibilitychange', this.cancel);\n  }\n\n  protected _onKeyDown(e: KeyboardEvent) {\n    // Handle start.\n    if (!this.drag) {\n      const startPosition = this._startPredicate(e, this, this._moveDistance);\n      if (startPosition) {\n        e.preventDefault();\n        this._start({\n          type: 'start',\n          x: startPosition.x,\n          y: startPosition.y,\n          srcEvent: e,\n        });\n      }\n      return;\n    }\n\n    // Handle cancel.\n    const cancelPosition = this._cancelPredicate(e, this, this._moveDistance);\n    if (cancelPosition) {\n      e.preventDefault();\n      this._cancel({\n        type: 'cancel',\n        x: cancelPosition.x,\n        y: cancelPosition.y,\n        srcEvent: e,\n      });\n      return;\n    }\n\n    // Handle end.\n    const endPosition = this._endPredicate(e, this, this._moveDistance);\n    if (endPosition) {\n      e.preventDefault();\n      this._end({\n        type: 'end',\n        x: endPosition.x,\n        y: endPosition.y,\n        srcEvent: e,\n      });\n      return;\n    }\n\n    // Handle move.\n    const movePosition = this._movePredicate(e, this, this._moveDistance);\n    if (movePosition) {\n      e.preventDefault();\n      this._move({\n        type: 'move',\n        x: movePosition.x,\n        y: movePosition.y,\n        srcEvent: e,\n      });\n      return;\n    }\n  }\n\n  updateSettings(options: Partial<KeyboardSensorSettings> = {}) {\n    if (options.moveDistance !== undefined) {\n      if (typeof options.moveDistance === 'number') {\n        this._moveDistance.x = options.moveDistance;\n        this._moveDistance.y = options.moveDistance;\n      } else {\n        this._moveDistance.x = options.moveDistance.x;\n        this._moveDistance.y = options.moveDistance.y;\n      }\n    }\n\n    if (options.startPredicate !== undefined) {\n      this._startPredicate = options.startPredicate;\n    }\n\n    if (options.movePredicate !== undefined) {\n      this._movePredicate = options.movePredicate;\n    }\n\n    if (options.cancelPredicate !== undefined) {\n      this._cancelPredicate = options.cancelPredicate;\n    }\n\n    if (options.endPredicate !== undefined) {\n      this._endPredicate = options.endPredicate;\n    }\n  }\n\n  destroy() {\n    if (this.isDestroyed) return;\n    super.destroy();\n    document.removeEventListener('keydown', this._onKeyDown);\n    window.removeEventListener('blur', this.cancel);\n    window.removeEventListener('visibilitychange', this.cancel);\n  }\n}\n","import { Sensor } from './sensor.js';\n\nimport { BaseMotionSensor, BaseMotionSensorEvents } from './base-motion-sensor.js';\n\nimport { Point } from 'types.js';\n\nexport interface KeyboardMotionSensorSettings<\n  E extends KeyboardMotionSensorEvents = KeyboardMotionSensorEvents,\n> {\n  startPredicate: (e: KeyboardEvent, sensor: KeyboardMotionSensor<E>) => Point | null | undefined;\n  computeSpeed: (sensor: KeyboardMotionSensor<E>) => number;\n  startKeys: string[];\n  moveLeftKeys: string[];\n  moveRightKeys: string[];\n  moveUpKeys: string[];\n  moveDownKeys: string[];\n  cancelKeys: string[];\n  endKeys: string[];\n}\n\nexport interface KeyboardMotionSensorEvents extends BaseMotionSensorEvents {}\n\nconst KEY_TYPES = [\n  'start',\n  'cancel',\n  'end',\n  'moveLeft',\n  'moveRight',\n  'moveUp',\n  'moveDown',\n] as const;\n\nfunction getEarliestTimestamp(keys: Set<string>, timestamps: Map<string, number>) {\n  if (!keys.size || !timestamps.size) return Infinity;\n  let result = Infinity;\n  for (const key of keys) {\n    const timestamp = timestamps.get(key);\n    if (timestamp !== undefined && timestamp < result) {\n      result = timestamp;\n    }\n  }\n  return result;\n}\n\nexport class KeyboardMotionSensor<E extends KeyboardMotionSensorEvents = KeyboardMotionSensorEvents>\n  extends BaseMotionSensor<E>\n  implements Sensor<E>\n{\n  declare events: E;\n  protected _startPredicate: Exclude<KeyboardMotionSensorSettings<E>['startPredicate'], undefined>;\n  protected _computeSpeed: Exclude<KeyboardMotionSensorSettings<E>['computeSpeed'], undefined>;\n  protected _moveKeys: Set<string>;\n  protected _moveKeyTimestamps: Map<string, number>;\n  protected _startKeys: Set<string>;\n  protected _moveLeftKeys: Set<string>;\n  protected _moveRightKeys: Set<string>;\n  protected _moveUpKeys: Set<string>;\n  protected _moveDownKeys: Set<string>;\n  protected _cancelKeys: Set<string>;\n  protected _endKeys: Set<string>;\n\n  constructor(options: Partial<KeyboardMotionSensorSettings<E>> = {}) {\n    super();\n\n    const {\n      startPredicate = () => {\n        if (document.activeElement) {\n          const { left, top } = document.activeElement.getBoundingClientRect();\n          return { x: left, y: top };\n        }\n        return null;\n      },\n      computeSpeed = () => 500,\n      startKeys = [' ', 'Enter'],\n      moveLeftKeys = ['ArrowLeft'],\n      moveRightKeys = ['ArrowRight'],\n      moveUpKeys = ['ArrowUp'],\n      moveDownKeys = ['ArrowDown'],\n      cancelKeys = ['Escape'],\n      endKeys = [' ', 'Enter'],\n    } = options;\n\n    this._computeSpeed = computeSpeed;\n    this._startPredicate = startPredicate;\n    this._startKeys = new Set(startKeys);\n    this._cancelKeys = new Set(cancelKeys);\n    this._endKeys = new Set(endKeys);\n    this._moveLeftKeys = new Set(moveLeftKeys);\n    this._moveRightKeys = new Set(moveRightKeys);\n    this._moveUpKeys = new Set(moveUpKeys);\n    this._moveDownKeys = new Set(moveDownKeys);\n    this._moveKeys = new Set([...moveLeftKeys, ...moveRightKeys, ...moveUpKeys, ...moveDownKeys]);\n    this._moveKeyTimestamps = new Map();\n\n    this._onKeyDown = this._onKeyDown.bind(this);\n    this._onKeyUp = this._onKeyUp.bind(this);\n    this._onTick = this._onTick.bind(this);\n\n    this.on('tick', this._onTick, this._onTick);\n    document.addEventListener('keydown', this._onKeyDown);\n    document.addEventListener('keyup', this._onKeyUp);\n    window.addEventListener('blur', this.cancel);\n    window.addEventListener('visibilitychange', this.cancel);\n  }\n\n  protected _end(data: E['end']) {\n    if (!this.drag) return;\n    this._moveKeyTimestamps.clear();\n    this._direction.x = 0;\n    this._direction.y = 0;\n    super._end(data);\n  }\n\n  protected _cancel(data: E['cancel']) {\n    if (!this.drag) return;\n    this._moveKeyTimestamps.clear();\n    this._direction.x = 0;\n    this._direction.y = 0;\n    super._cancel(data);\n  }\n\n  protected _updateDirection() {\n    const leftTime = getEarliestTimestamp(this._moveLeftKeys, this._moveKeyTimestamps);\n    const rightTime = getEarliestTimestamp(this._moveRightKeys, this._moveKeyTimestamps);\n    const upTime = getEarliestTimestamp(this._moveUpKeys, this._moveKeyTimestamps);\n    const downTime = getEarliestTimestamp(this._moveDownKeys, this._moveKeyTimestamps);\n\n    let x = leftTime === rightTime ? 0 : leftTime < rightTime ? -1 : 1;\n    let y = upTime === downTime ? 0 : upTime < downTime ? -1 : 1;\n\n    // If the direction is NE/NW/SE/SW we need to normalize the direction\n    // vector.\n    if (!(x === 0 || y === 0)) {\n      const normFactor = 1 / (Math.sqrt(x * x + y * y) || 1);\n      x *= normFactor;\n      y *= normFactor;\n    }\n\n    this._direction.x = x;\n    this._direction.y = y;\n  }\n\n  protected _onTick() {\n    this._speed = this._computeSpeed(this);\n  }\n\n  protected _onKeyUp(e: KeyboardEvent) {\n    if (this._moveKeyTimestamps.get(e.key)) {\n      this._moveKeyTimestamps.delete(e.key);\n      this._updateDirection();\n    }\n  }\n\n  protected _onKeyDown(e: KeyboardEvent) {\n    // Handle start.\n    if (!this.drag) {\n      if (this._startKeys.has(e.key)) {\n        const startPosition = this._startPredicate(e, this);\n        if (startPosition) {\n          e.preventDefault();\n          this._start({\n            type: 'start',\n            x: startPosition.x,\n            y: startPosition.y,\n          });\n        }\n      }\n      return;\n    }\n\n    // Handle cancel.\n    if (this._cancelKeys.has(e.key)) {\n      e.preventDefault();\n      this._cancel({\n        type: 'cancel',\n        x: this.drag.x,\n        y: this.drag.y,\n      });\n      return;\n    }\n\n    // Handle end.\n    if (this._endKeys.has(e.key)) {\n      e.preventDefault();\n      this._end({\n        type: 'end',\n        x: this.drag.x,\n        y: this.drag.y,\n      });\n      return;\n    }\n\n    // Handle move.\n    if (this._moveKeys.has(e.key)) {\n      e.preventDefault();\n      if (!this._moveKeyTimestamps.get(e.key)) {\n        this._moveKeyTimestamps.set(e.key, Date.now());\n        this._updateDirection();\n      }\n      return;\n    }\n  }\n\n  updateSettings(options: Partial<KeyboardMotionSensorSettings<E>> = {}) {\n    let moveKeysMayNeedUpdate = false;\n\n    if (options.startPredicate !== undefined) {\n      this._startPredicate = options.startPredicate;\n    }\n\n    if (options.computeSpeed !== undefined) {\n      this._computeSpeed = options.computeSpeed;\n    }\n\n    KEY_TYPES.forEach((keyType, index) => {\n      const name = `${keyType}Keys` as const;\n      const value = options[name];\n      if (value !== undefined) {\n        this[`_${name}`] = new Set(value);\n        if (index >= 3) moveKeysMayNeedUpdate = true;\n      }\n    });\n\n    if (moveKeysMayNeedUpdate) {\n      // Construct the next move keys array.\n      const nextMoveKeys = [\n        ...this._moveLeftKeys,\n        ...this._moveRightKeys,\n        ...this._moveUpKeys,\n        ...this._moveDownKeys,\n      ];\n\n      // Check if the next move keys are equal to the current ones.\n      const areMoveKeysEqual = [...this._moveKeys].every(\n        (key, index) => nextMoveKeys[index] === key,\n      );\n\n      // Update move keys if needed.\n      if (!areMoveKeysEqual) {\n        this._moveKeys = new Set(nextMoveKeys);\n        this._moveKeyTimestamps.clear();\n        this._updateDirection();\n      }\n    }\n  }\n\n  destroy() {\n    if (this.isDestroyed) return;\n    super.destroy();\n    this.off('tick', this._onTick);\n    document.removeEventListener('keydown', this._onKeyDown);\n    document.removeEventListener('keyup', this._onKeyUp);\n    window.removeEventListener('blur', this.cancel);\n    window.removeEventListener('visibilitychange', this.cancel);\n  }\n}\n","import { HAS_PASSIVE_EVENTS } from '../constants.js';\n\nimport { Emitter, EventListenerId } from 'eventti';\n\nimport { Sensor, SensorEvents } from '../sensors/sensor.js';\n\nimport { DraggableDrag } from './draggable-drag.js';\n\nimport { DraggableDragItem } from './draggable-drag-item.js';\n\nimport { ticker, tickerReadPhase, tickerWritePhase } from '../singletons/ticker.js';\n\nimport { getOffsetDiff } from '../utils/get-offset-diff.js';\n\nimport { Writeable, CSSProperties, Point } from '../types.js';\n\nconst SCROLL_LISTENER_OPTIONS = HAS_PASSIVE_EVENTS ? { capture: true, passive: true } : true;\n\nconst OFFSET_DIFF = { left: 0, top: 0 };\n\nconst POSITION_CHANGE = { x: 0, y: 0 };\n\nenum DraggableStartPredicateState {\n  PENDING = 0,\n  RESOLVED = 1,\n  REJECTED = 2,\n}\n\nfunction getDefaultSettings<S extends Sensor[], E extends S[number]['events']>(): DraggableSettings<\n  S,\n  E\n> {\n  return {\n    container: null,\n    startPredicate: () => true,\n    getElements: () => null,\n    releaseElements: () => null,\n    getFrozenProps: () => null,\n    getStartPosition: () => {\n      return { x: 0, y: 0 };\n    },\n    setPosition: ({ item, x, y }) => {\n      item.element.style.transform = `translate(${x}px, ${y}px) ${item.initialTransform}`;\n    },\n    getPositionChange: ({ event, prevEvent }) => {\n      POSITION_CHANGE.x = event.x - prevEvent.x;\n      POSITION_CHANGE.y = event.y - prevEvent.y;\n      return POSITION_CHANGE;\n    },\n  };\n}\n\nexport interface DraggableSettings<S extends Sensor[], E extends S[number]['events']> {\n  container: HTMLElement | null;\n  startPredicate: (data: {\n    draggable: Draggable<S, E>;\n    sensor: S[number];\n    event: E['start'] | E['move'];\n  }) => boolean | undefined;\n  getElements: (data: {\n    draggable: Draggable<S, E>;\n    sensor: S[number];\n    startEvent: E['start'] | E['move'];\n  }) => (HTMLElement | SVGSVGElement)[] | null;\n  releaseElements: (data: {\n    draggable: Draggable<S, E>;\n    sensor: S[number];\n    elements: (HTMLElement | SVGSVGElement)[];\n  }) => void;\n  getFrozenProps: (data: {\n    draggable: Draggable<S, E>;\n    sensor: S[number];\n    item: DraggableDragItem<S, E>;\n    style: CSSStyleDeclaration;\n  }) => CSSProperties | (keyof CSSProperties)[] | null;\n  getStartPosition: (data: {\n    draggable: Draggable<S, E>;\n    sensor: S[number];\n    item: DraggableDragItem<S, E>;\n    style: CSSStyleDeclaration;\n  }) => Point;\n  setPosition: (data: {\n    draggable: Draggable<S, E>;\n    sensor: S[number];\n    phase: 'start' | 'move' | 'end';\n    item: DraggableDragItem<S, E>;\n    x: number;\n    y: number;\n  }) => void;\n  getPositionChange: (data: {\n    draggable: Draggable<S, E>;\n    sensor: S[number];\n    item: DraggableDragItem<S, E>;\n    event: E['start'] | E['move'];\n    prevEvent: E['start'] | E['move'];\n    startEvent: E['start'] | E['move'];\n  }) => Point;\n}\n\nexport interface DraggablePlugin {\n  name: string;\n  version: string;\n}\n\nexport type DraggablePluginMap = Record<string, DraggablePlugin | undefined>;\n\nexport interface DraggableEventCallbacks<E extends SensorEvents> {\n  preparestart(event: E['start'] | E['move']): void;\n  start(event: E['start'] | E['move']): void;\n  preparemove(event: E['move']): void;\n  move(event: E['move']): void;\n  end(event: E['end'] | E['cancel'] | E['destroy'] | null): void;\n  destroy(): void;\n}\n\nexport class Draggable<\n  S extends Sensor[] = Sensor[],\n  E extends S[number]['events'] = S[number]['events'],\n  P extends DraggablePluginMap = {},\n> {\n  readonly sensors: S;\n  readonly settings: DraggableSettings<S, E>;\n  readonly plugins: P;\n  readonly drag: DraggableDrag<S, E> | null;\n  readonly isDestroyed: boolean;\n  protected _sensorData: Map<\n    S[number],\n    {\n      predicateState: DraggableStartPredicateState;\n      predicateEvent: E['start'] | E['move'] | null;\n      onMove: (e: Parameters<Draggable<S, E, P>['_onMove']>[0]) => void;\n      onEnd: (e: Parameters<Draggable<S, E, P>['_onEnd']>[0]) => void;\n    }\n  >;\n  protected _emitter: Emitter<{\n    [K in keyof DraggableEventCallbacks<E>]: DraggableEventCallbacks<E>[K];\n  }>;\n  protected _startId: symbol;\n  protected _moveId: symbol;\n  protected _updateId: symbol;\n\n  constructor(sensors: S, options: Partial<DraggableSettings<S, E>> = {}) {\n    this.sensors = sensors;\n    this.settings = this._parseSettings(options);\n    this.plugins = {} as P;\n    this.drag = null;\n    this.isDestroyed = false;\n\n    this._sensorData = new Map();\n    this._emitter = new Emitter();\n    this._startId = Symbol();\n    this._moveId = Symbol();\n    this._updateId = Symbol();\n\n    // Bind methods (that need binding).\n    this._onMove = this._onMove.bind(this);\n    this._onScroll = this._onScroll.bind(this);\n    this._onEnd = this._onEnd.bind(this);\n    this._prepareStart = this._prepareStart.bind(this);\n    this._applyStart = this._applyStart.bind(this);\n    this._prepareMove = this._prepareMove.bind(this);\n    this._applyMove = this._applyMove.bind(this);\n    this._preparePositionUpdate = this._preparePositionUpdate.bind(this);\n    this._applyPositionUpdate = this._applyPositionUpdate.bind(this);\n\n    // Bind drag sensor events.\n    this.sensors.forEach((sensor) => {\n      this._sensorData.set(sensor, {\n        predicateState: DraggableStartPredicateState.PENDING,\n        predicateEvent: null,\n        onMove: (e) => this._onMove(e, sensor),\n        onEnd: (e) => this._onEnd(e, sensor),\n      });\n      const { onMove, onEnd } = this._sensorData.get(sensor)!;\n      sensor.on('start', onMove, onMove);\n      sensor.on('move', onMove, onMove);\n      sensor.on('cancel', onEnd, onEnd);\n      sensor.on('end', onEnd, onEnd);\n      sensor.on('destroy', onEnd, onEnd);\n    });\n  }\n\n  protected _parseSettings(\n    options?: Partial<this['settings']>,\n    defaults: this['settings'] = getDefaultSettings(),\n  ): this['settings'] {\n    const {\n      container = defaults.container,\n      startPredicate = defaults.startPredicate,\n      getElements = defaults.getElements,\n      releaseElements = defaults.releaseElements,\n      getFrozenProps = defaults.getFrozenProps,\n      getStartPosition = defaults.getStartPosition,\n      setPosition = defaults.setPosition,\n      getPositionChange = defaults.getPositionChange,\n    } = options || {};\n\n    return {\n      container,\n      startPredicate,\n      getElements,\n      releaseElements,\n      getFrozenProps,\n      getStartPosition,\n      setPosition,\n      getPositionChange,\n    };\n  }\n\n  protected _emit<K extends keyof DraggableEventCallbacks<E>>(\n    type: K,\n    ...e: Parameters<DraggableEventCallbacks<E>[K]>\n  ) {\n    this._emitter.emit(type, ...e);\n  }\n\n  protected _onMove(e: E['start'] | E['move'], sensor: S[number]) {\n    const sensorData = this._sensorData.get(sensor);\n    if (!sensorData) return;\n\n    switch (sensorData.predicateState) {\n      case DraggableStartPredicateState.PENDING: {\n        sensorData.predicateEvent = e;\n\n        // Check if drag should start.\n        const shouldStart = this.settings.startPredicate({\n          draggable: this,\n          sensor,\n          event: e,\n        });\n\n        // Resolve procedure (start move process).\n        if (shouldStart === true) {\n          this.resolveStartPredicate(sensor);\n        }\n        // Reject procedure.\n        else if (shouldStart === false) {\n          this.rejectStartPredicate(sensor);\n        }\n        break;\n      }\n      case DraggableStartPredicateState.RESOLVED: {\n        // Move the element if dragging is active.\n        if (this.drag) {\n          (this.drag as Writeable<DraggableDrag<S, E>>).event = e;\n          ticker.once(tickerReadPhase, this._prepareMove, this._moveId);\n          ticker.once(tickerWritePhase, this._applyMove, this._moveId);\n        }\n        break;\n      }\n    }\n  }\n\n  protected _onScroll() {\n    this.updatePosition();\n  }\n\n  protected _onEnd(e: E['end'] | E['cancel'] | E['destroy'], sensor: S[number]) {\n    const sensorData = this._sensorData.get(sensor);\n    if (!sensorData) return;\n\n    // If there is no active drag yet, let's reset the sensor's start predicate\n    // so that it can try starting drag again.\n    if (!this.drag) {\n      sensorData.predicateState = DraggableStartPredicateState.PENDING;\n      sensorData.predicateEvent = null;\n    }\n    // Otherwise, if drag is active AND the sensor is the one that triggered the\n    // drag process, let's reset all sensors' start preidcate states.\n    else if (sensorData.predicateState === DraggableStartPredicateState.RESOLVED) {\n      (this.drag as Writeable<DraggableDrag<S, E>>).endEvent = e;\n      this._sensorData.forEach((data) => {\n        data.predicateState = DraggableStartPredicateState.PENDING;\n        data.predicateEvent = null;\n      });\n      this.stop();\n    }\n  }\n\n  protected _prepareStart() {\n    const drag: Writeable<DraggableDrag<S, E>> | null = this.drag;\n    if (!drag) return;\n\n    // Get elements that we'll need to move with the drag.\n    // NB: It is okay if there are no elements and thus no items. The drag\n    // process will process as usual, but nothing is moving by default.\n    const elements =\n      this.settings.getElements({\n        draggable: this,\n        sensor: drag.sensor,\n        startEvent: drag.startEvent,\n      }) || [];\n\n    // Create drag items.\n    drag.items = elements.map((element) => {\n      return new DraggableDragItem(element, this);\n    });\n\n    // Emit preparestart event.\n    this._emit('preparestart', drag.startEvent);\n  }\n\n  protected _applyStart() {\n    const drag: Writeable<DraggableDrag<S, E>> | null = this.drag;\n    if (!drag) return;\n\n    const { container } = this.settings;\n    for (const item of drag.items as Writeable<DraggableDragItem<S, E>>[]) {\n      // Append element within the container element if such is provided.\n      if (container && item.element.parentElement !== container) {\n        container.appendChild(item.element);\n        item.position.x += item._containerDiff.x;\n        item.position.y += item._containerDiff.y;\n      }\n\n      // Freeze element's props if such are provided.\n      if (item.frozenProps) {\n        Object.assign(item.element.style, item.frozenProps);\n      }\n\n      // Set the element's start position.\n      this.settings.setPosition({\n        phase: 'start',\n        draggable: this,\n        sensor: drag.sensor,\n        item: item as DraggableDragItem<S, E>,\n        x: item.position.x,\n        y: item.position.y,\n      });\n    }\n\n    // Bind scroll listeners.\n    window.addEventListener('scroll', this._onScroll, SCROLL_LISTENER_OPTIONS);\n\n    // Emit start event.\n    this._emit('start', drag.startEvent);\n  }\n\n  protected _prepareMove() {\n    const drag: Writeable<DraggableDrag<S, E>> | null = this.drag;\n    if (!drag) return;\n\n    // Get next event and previous event so we can compute the movement\n    // difference between the clientX/Y values.\n    const { event, prevEvent, startEvent, sensor } = drag;\n    if (event === prevEvent) return;\n\n    for (const item of drag.items as Writeable<DraggableDragItem<S, E>>[]) {\n      // Compute how much x and y needs to be transformed.\n      const { x: changeX, y: changeY } = this.settings.getPositionChange({\n        draggable: this,\n        sensor,\n        item: item as DraggableDragItem<S, E>,\n        event,\n        prevEvent,\n        startEvent,\n      });\n\n      // Update horizontal position data.\n      if (changeX) {\n        item.position.x += changeX;\n        item.clientRect.left += changeX;\n        item._moveDiff.x += changeX;\n      }\n\n      // Update vertical position data.\n      if (changeY) {\n        item.position.y += changeY;\n        item.clientRect.top += changeY;\n        item._moveDiff.y += changeY;\n      }\n    }\n\n    // Store next event as previous event.\n    (drag as Writeable<DraggableDrag<S, E>>).prevEvent = event;\n\n    // Emit preparemove event.\n    this._emit('preparemove', event as E['move']);\n  }\n\n  protected _applyMove() {\n    const drag: Writeable<DraggableDrag<S, E>> | null = this.drag;\n    if (!drag) return;\n\n    // Reset movement diff and move the element.\n    for (const item of drag.items as Writeable<DraggableDragItem<S, E>>[]) {\n      item._moveDiff.x = 0;\n      item._moveDiff.y = 0;\n\n      this.settings.setPosition({\n        phase: 'move',\n        draggable: this,\n        sensor: drag.sensor,\n        item: item as DraggableDragItem<S, E>,\n        x: item.position.x,\n        y: item.position.y,\n      });\n    }\n\n    // Emit move event.\n    if (drag.event) {\n      this._emit('move', drag.event as E['move']);\n    }\n  }\n\n  protected _preparePositionUpdate() {\n    const { drag } = this;\n    if (!drag) return;\n\n    for (const item of drag.items as Writeable<DraggableDragItem<S, E>>[]) {\n      // Update container diff.\n      if (item.elementOffsetContainer !== item.dragOffsetContainer) {\n        const { left, top } = getOffsetDiff(\n          item.dragOffsetContainer,\n          item.elementOffsetContainer,\n          OFFSET_DIFF,\n        );\n        item._containerDiff.x = left;\n        item._containerDiff.y = top;\n      }\n\n      const { left, top, width, height } = item.element.getBoundingClientRect();\n\n      // Update horizontal position data.\n      const updateDiffX = item.clientRect.left - item._moveDiff.x - left;\n      item.position.x = item.position.x - item._updateDiff.x + updateDiffX;\n      item._updateDiff.x = updateDiffX;\n\n      // Update vertical position data.\n      const updateDiffY = item.clientRect.top - item._moveDiff.y - top;\n      item.position.y = item.position.y - item._updateDiff.y + updateDiffY;\n      item._updateDiff.y = updateDiffY;\n\n      // Update item client size. This is not necessary for the drag process,\n      // but since we're computing the bounding client rect, we might as well\n      // update the size in the process. The size is used by the auto-scroll\n      // plugin and possibly some other third-party plugins.\n      item.clientRect.width = width;\n      item.clientRect.height = height;\n    }\n  }\n\n  protected _applyPositionUpdate() {\n    const { drag } = this;\n    if (!drag) return;\n\n    for (const item of drag.items as Writeable<DraggableDragItem<S, E>>[]) {\n      item._updateDiff.x = 0;\n      item._updateDiff.y = 0;\n\n      this.settings.setPosition({\n        phase: 'move',\n        draggable: this,\n        sensor: drag.sensor,\n        item: item as DraggableDragItem<S, E>,\n        x: item.position.x,\n        y: item.position.y,\n      });\n    }\n  }\n\n  on<T extends keyof DraggableEventCallbacks<E>>(\n    type: T,\n    listener: DraggableEventCallbacks<E>[T],\n    listenerId?: EventListenerId,\n  ): EventListenerId {\n    return this._emitter.on(type, listener, listenerId);\n  }\n\n  off<T extends keyof DraggableEventCallbacks<E>>(type: T, listenerId: EventListenerId): void {\n    this._emitter.off(type, listenerId);\n  }\n\n  resolveStartPredicate(sensor: S[number], e?: E['start'] | E['move']) {\n    const sensorData = this._sensorData.get(sensor);\n    if (!sensorData) return;\n\n    const startEvent = e || sensorData.predicateEvent;\n\n    if (sensorData.predicateState === DraggableStartPredicateState.PENDING && startEvent) {\n      // Resolve the provided sensor's start predicate.\n      sensorData.predicateState = DraggableStartPredicateState.RESOLVED;\n      sensorData.predicateEvent = null;\n\n      (this as Writeable<this>).drag = new DraggableDrag(sensor, startEvent);\n\n      // Reject other sensors' start predicates.\n      this._sensorData.forEach((data, s) => {\n        if (s === sensor) return;\n        data.predicateState = DraggableStartPredicateState.REJECTED;\n        data.predicateEvent = null;\n      });\n\n      // Queue drag start.\n      ticker.once(tickerReadPhase, this._prepareStart, this._startId);\n      ticker.once(tickerWritePhase, this._applyStart, this._startId);\n    }\n  }\n\n  rejectStartPredicate(sensor: S[number]) {\n    const sensorData = this._sensorData.get(sensor);\n    if (sensorData?.predicateState === DraggableStartPredicateState.PENDING) {\n      sensorData.predicateState = DraggableStartPredicateState.REJECTED;\n      sensorData.predicateEvent = null;\n    }\n  }\n\n  stop() {\n    const drag: Writeable<DraggableDrag<S, E>> | null = this.drag;\n    if (!drag || drag.isEnded) return;\n\n    // Mark drag process as ended.\n    drag.isEnded = true;\n\n    // Cancel all queued ticks.\n    ticker.off(tickerReadPhase, this._startId);\n    ticker.off(tickerWritePhase, this._startId);\n    ticker.off(tickerReadPhase, this._moveId);\n    ticker.off(tickerWritePhase, this._moveId);\n    ticker.off(tickerReadPhase, this._updateId);\n    ticker.off(tickerWritePhase, this._updateId);\n\n    // Unbind scroll listener.\n    window.removeEventListener('scroll', this._onScroll, SCROLL_LISTENER_OPTIONS);\n\n    // Move elements within the root container and collect all elements\n    // to an elements array.\n    const elements: (HTMLElement | SVGSVGElement)[] = [];\n    for (const item of drag.items as Writeable<DraggableDragItem<S, E>>[]) {\n      elements.push(item.element);\n      if (item.elementContainer && item.element.parentElement !== item.elementContainer) {\n        item.position.x -= item._containerDiff.x;\n        item.position.y -= item._containerDiff.y;\n        item._containerDiff.x = 0;\n        item._containerDiff.y = 0;\n        item.elementContainer.appendChild(item.element);\n      }\n\n      // Unfreeze element's props if such are provided.\n      if (item.unfrozenProps) {\n        for (const key in item.unfrozenProps) {\n          item.element.style[key] = item.unfrozenProps[key] || '';\n        }\n      }\n\n      // Set final position after drag.\n      this.settings.setPosition({\n        phase: 'end',\n        draggable: this,\n        sensor: drag.sensor,\n        item: item as DraggableDragItem<S, E>,\n        x: item.position.x,\n        y: item.position.y,\n      });\n    }\n\n    // Call \"releaseElements\" callback.\n    if (elements.length) {\n      this.settings.releaseElements({\n        draggable: this,\n        sensor: drag.sensor!,\n        elements,\n      });\n    }\n\n    // Emit end event.\n    this._emit('end', drag.endEvent);\n\n    // Reset drag data.\n    (this as Writeable<this>).drag = null;\n  }\n\n  updatePosition(instant = false) {\n    if (!this.drag) return;\n    if (instant) {\n      this._preparePositionUpdate();\n      this._applyPositionUpdate();\n    } else {\n      ticker.once(tickerReadPhase, this._preparePositionUpdate, this._updateId);\n      ticker.once(tickerWritePhase, this._applyPositionUpdate, this._updateId);\n    }\n  }\n\n  updateSettings(options: Partial<this['settings']> = {}) {\n    (this as Writeable<this>).settings = this._parseSettings(options, this.settings);\n  }\n\n  use<SS extends S, EE extends SS[number]['events'], PP extends P>(\n    plugin: (draggable: this) => Draggable<SS, EE, PP>,\n  ) {\n    return plugin(this);\n  }\n\n  destroy() {\n    if (this.isDestroyed) return;\n    (this as Writeable<this>).isDestroyed = true;\n\n    this.stop();\n\n    this._sensorData.forEach(({ onMove, onEnd }, sensor) => {\n      sensor.off('start', onMove);\n      sensor.off('move', onMove);\n      sensor.off('cancel', onEnd);\n      sensor.off('end', onEnd);\n      sensor.off('destroy', onEnd);\n    });\n\n    this._sensorData.clear();\n\n    this._emit('destroy');\n\n    this._emitter.off();\n  }\n}\n","import { Sensor } from '../sensors/sensor.js';\n\nimport { DraggableDragItem } from './draggable-drag-item.js';\n\nexport class DraggableDrag<S extends Sensor[], E extends S[number]['events']> {\n  readonly sensor: S[number];\n  readonly isEnded: boolean;\n  readonly event: E['start'] | E['move'];\n  readonly prevEvent: E['start'] | E['move'];\n  readonly startEvent: E['start'] | E['move'];\n  readonly endEvent: E['end'] | E['cancel'] | E['destroy'] | null;\n  readonly items: DraggableDragItem[];\n\n  constructor(sensor: S[number], startEvent: E['start'] | E['move']) {\n    this.sensor = sensor;\n    this.isEnded = false;\n    this.event = startEvent;\n    this.prevEvent = startEvent;\n    this.startEvent = startEvent;\n    this.endEvent = null;\n    this.items = [];\n  }\n}\n","import { getOffsetContainer } from 'mezr';\n\nimport { Sensor } from '../sensors/sensor.js';\n\nimport { CSSProperties, Point, Rect } from '../types.js';\n\nimport { getStyle } from 'utils/get-style.js';\n\nimport { getOffsetDiff } from 'utils/get-offset-diff.js';\n\nimport type { Draggable } from './draggable.js';\n\nconst OFFSET_DIFF = { left: 0, top: 0 };\n\nconst IDENTITY_MATRIX = 'matrix(1, 0, 0, 1, 0, 0)';\n\nconst IDENTITY_MATRIX_3D = 'matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)';\n\nexport class DraggableDragItem<\n  S extends Sensor[] = Sensor[],\n  E extends S[number]['events'] = S[number]['events'],\n> {\n  data: { [key: string]: any };\n  readonly element: HTMLElement | SVGSVGElement;\n  readonly elementContainer: HTMLElement;\n  readonly elementOffsetContainer: HTMLElement | SVGSVGElement | Window | Document;\n  readonly dragContainer: HTMLElement;\n  readonly dragOffsetContainer: HTMLElement | SVGSVGElement | Window | Document;\n  readonly initialTransform: string;\n  readonly frozenProps: CSSProperties | null;\n  readonly unfrozenProps: CSSProperties | null;\n  readonly clientRect: Rect;\n  readonly position: Point;\n  readonly _updateDiff: Point;\n  readonly _moveDiff: Point;\n  readonly _containerDiff: Point;\n\n  constructor(element: HTMLElement | SVGSVGElement, draggable: Draggable<S, E>) {\n    // Make sure the element is in DOM.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected\n    if (!element.isConnected) {\n      throw new Error('Element is not connected');\n    }\n\n    // Make sure sensor is defined.\n    const sensor = draggable.drag?.sensor;\n    if (!sensor) {\n      throw new Error('Sensor is not defined');\n    }\n\n    const item = this;\n    const style = getStyle(element);\n    const clientRect = element.getBoundingClientRect();\n\n    this.data = {};\n    this.element = element;\n    this.frozenProps = null;\n    this.unfrozenProps = null;\n    this.position = { x: 0, y: 0 };\n    this._updateDiff = { x: 0, y: 0 };\n    this._moveDiff = { x: 0, y: 0 };\n    this._containerDiff = { x: 0, y: 0 };\n\n    // Use element's parent element as the element container.\n    const elementContainer = element.parentElement;\n    if (!elementContainer) {\n      throw new Error('Element does not have a parent element.');\n    }\n    this.elementContainer = elementContainer;\n\n    // Compute element's offset container.\n    const elementOffsetContainer = getOffsetContainer(element);\n    if (!elementOffsetContainer) {\n      throw new Error('Offset container could not be computed for the element!');\n    }\n    this.elementOffsetContainer = elementOffsetContainer;\n\n    // Get element's drag parent, default to element's parent element.\n    const dragContainer = draggable.settings.container || elementContainer;\n    this.dragContainer = dragContainer;\n\n    // Get drag container's offset container.\n    const dragOffsetContainer =\n      dragContainer === elementContainer\n        ? elementOffsetContainer\n        : getOffsetContainer(element, { container: dragContainer });\n    if (!dragOffsetContainer) {\n      throw new Error('Drag offset container could not be computed for the element!');\n    }\n    this.dragOffsetContainer = dragOffsetContainer;\n\n    // Store element's client rect.\n    {\n      const { left, top, width, height } = clientRect;\n      this.clientRect = { left, top, width, height };\n    }\n\n    // If element's offset container is different than drag container's\n    // offset container let's compute the offset between the offset containers.\n    if (elementOffsetContainer !== dragOffsetContainer) {\n      const { left, top } = getOffsetDiff(dragOffsetContainer, elementOffsetContainer, OFFSET_DIFF);\n      this._containerDiff.x = left;\n      this._containerDiff.y = top;\n    }\n\n    // Store element's initial transform.\n    const { transform } = style;\n    if (\n      transform &&\n      transform !== 'none' &&\n      transform !== IDENTITY_MATRIX &&\n      transform !== IDENTITY_MATRIX_3D\n    ) {\n      this.initialTransform = transform;\n    } else {\n      this.initialTransform = '';\n    }\n\n    // Get element's initial position. This position is relative to the\n    // properties the user is using to move the element. For example, if the\n    // user is using the `translate` transform to move the element then the\n    // initial position will be relative to the `translate` transform and the\n    // position here should reflect the transform value delta.\n    const { x, y } = draggable.settings.getStartPosition({\n      draggable,\n      sensor,\n      item,\n      style,\n    });\n    this.position.x = x;\n    this.position.y = y;\n\n    // Get element's frozen props.\n    const frozenProps = draggable.settings.getFrozenProps({\n      draggable,\n      sensor,\n      item,\n      style,\n    });\n    if (Array.isArray(frozenProps)) {\n      if (frozenProps.length) {\n        const props: CSSProperties = {};\n        for (const prop of frozenProps) {\n          props[prop] = style[prop];\n        }\n        this.frozenProps = props;\n      } else {\n        this.frozenProps = null;\n      }\n    } else {\n      this.frozenProps = frozenProps;\n    }\n\n    // Lastly, let's compute the unfrozen props. We store the current inline\n    // style values for all frozen props so that we can restore them after the\n    // drag process is over.\n    if (this.frozenProps) {\n      const unfrozenProps: CSSProperties = {};\n      for (const key in this.frozenProps) {\n        if (this.frozenProps.hasOwnProperty(key)) {\n          unfrozenProps[key] = element.style[key];\n        }\n      }\n      this.unfrozenProps = unfrozenProps;\n    }\n  }\n\n  updateSize(dimensions?: { width: number; height: number }) {\n    if (dimensions) {\n      this.clientRect.width = dimensions.width;\n      this.clientRect.height = dimensions.height;\n    } else {\n      const rect = this.element.getBoundingClientRect();\n      this.clientRect.width = rect.width;\n      this.clientRect.height = rect.height;\n    }\n  }\n}\n","export*from\"./getContainingBlock.js\";export*from\"./getDistance.js\";export*from\"./getHeight.js\";export*from\"./getIntersection.js\";export*from\"./getOffset.js\";export*from\"./getOffsetContainer.js\";export*from\"./getOverflow.js\";export*from\"./getRect.js\";export*from\"./getWidth.js\";","import{getStyle}from\"./utils/getStyle.js\";import{isContainingBlockForFixedElement}from\"./utils/isContainingBlockForFixedElement.js\";import{isContainingBlockForAbsoluteElement}from\"./utils/isContainingBlockForAbsoluteElement.js\";import{isBlockElement}from\"./utils/isBlockElement.js\";import{isDocumentElement}from\"./utils/isDocumentElement.js\";export function getContainingBlock(e,t={}){if(isDocumentElement(e))return e.ownerDocument.defaultView;const n=t.position||getStyle(e).position,{skipDisplayNone:i,container:o}=t;switch(n){case\"static\":case\"relative\":case\"sticky\":case\"-webkit-sticky\":{let t=o||e.parentElement;for(;t;){const e=isBlockElement(t);if(e)return t;if(null===e&&!i)return null;t=t.parentElement}return e.ownerDocument.documentElement}case\"absolute\":case\"fixed\":{const t=\"fixed\"===n;let l=o||e.parentElement;for(;l;){const e=t?isContainingBlockForFixedElement(l):isContainingBlockForAbsoluteElement(l);if(!0===e)return l;if(null===e&&!i)return null;l=l.parentElement}return e.ownerDocument.defaultView}default:return null}}","const STYLE_DECLARATION_CACHE=new WeakMap;export function getStyle(e,t){if(t)return window.getComputedStyle(e,t);let C=STYLE_DECLARATION_CACHE.get(e)?.deref();return C||(C=window.getComputedStyle(e,null),STYLE_DECLARATION_CACHE.set(e,new WeakRef(C))),C}","import{IS_SAFARI}from\"./constants.js\";import{getStyle}from\"./getStyle.js\";import{isBlockElement}from\"./isBlockElement.js\";export function isContainingBlockForFixedElement(n){const t=getStyle(n);if(!IS_SAFARI){const{filter:n}=t;if(n&&\"none\"!==n)return!0;const{backdropFilter:e}=t;if(e&&\"none\"!==e)return!0;const{willChange:i}=t;if(i&&(i.indexOf(\"filter\")>-1||i.indexOf(\"backdrop-filter\")>-1))return!0}const e=isBlockElement(n);if(!e)return e;const{transform:i}=t;if(i&&\"none\"!==i)return!0;const{perspective:r}=t;if(r&&\"none\"!==r)return!0;const{contentVisibility:o}=t;if(o&&\"auto\"===o)return!0;const{contain:f}=t;if(f&&(\"strict\"===f||\"content\"===f||f.indexOf(\"paint\")>-1||f.indexOf(\"layout\")>-1))return!0;const{willChange:c}=t;return!(!c||!(c.indexOf(\"transform\")>-1||c.indexOf(\"perspective\")>-1||c.indexOf(\"contain\")>-1))||!!(IS_SAFARI&&c&&c.indexOf(\"filter\")>-1)}","export const IS_BROWSER=\"undefined\"!=typeof window&&void 0!==window.document;export const IS_SAFARI=!!(IS_BROWSER&&navigator.vendor&&navigator.vendor.indexOf(\"Apple\")>-1&&navigator.userAgent&&-1==navigator.userAgent.indexOf(\"CriOS\")&&-1==navigator.userAgent.indexOf(\"FxiOS\"));export const BOX_EDGE={content:\"content\",padding:\"padding\",scrollbar:\"scrollbar\",border:\"border\",margin:\"margin\"};export const INCLUDE_WINDOW_SCROLLBAR={[BOX_EDGE.content]:!1,[BOX_EDGE.padding]:!1,[BOX_EDGE.scrollbar]:!0,[BOX_EDGE.border]:!0,[BOX_EDGE.margin]:!0};export const SCROLLABLE_OVERFLOWS=new Set([\"auto\",\"scroll\"]);export const IS_CHROMIUM=(()=>{try{return window.navigator.userAgentData.brands.some((({brand:n})=>\"Chromium\"===n))}catch(n){return!1}})();","import{getStyle}from\"./getStyle.js\";export function isBlockElement(e){switch(getStyle(e).display){case\"none\":return null;case\"inline\":case\"contents\":return!1;default:return!0}}","import{getStyle}from\"./getStyle.js\";import{isContainingBlockForFixedElement}from\"./isContainingBlockForFixedElement.js\";export function isContainingBlockForAbsoluteElement(t){return\"static\"!==getStyle(t).position||isContainingBlockForFixedElement(t)}","export function isDocumentElement(e){return e instanceof HTMLHtmlElement}","import{getDistanceBetweenRects}from\"./utils/getDistanceBetweenRects.js\";import{getNormalizedRect}from\"./utils/getNormalizedRect.js\";export function getDistance(e,t){const c=getNormalizedRect(e),i=getNormalizedRect(t);return getDistanceBetweenRects(c,i)}","import{isIntersecting}from\"./isIntersecting.js\";import{getDistanceBetweenPoints}from\"./getDistanceBetweenPoints.js\";export function getDistanceBetweenRects(t,e){if(isIntersecting(t,e))return null;const n=t.left+t.width,i=t.top+t.height,o=e.left+e.width,s=e.top+e.height;return n<=e.left?i<=e.top?getDistanceBetweenPoints(n,i,e.left,e.top):t.top>=s?getDistanceBetweenPoints(n,t.top,e.left,s):e.left-n:t.left>=o?i<=e.top?getDistanceBetweenPoints(t.left,i,o,e.top):t.top>=s?getDistanceBetweenPoints(t.left,t.top,o,s):t.left-o:i<=e.top?e.top-i:t.top-s}","export function isIntersecting(t,e){return!(t.left+t.width<=e.left||e.left+e.width<=t.left||t.top+t.height<=e.top||e.top+e.height<=t.top)}","export function getDistanceBetweenPoints(t,e,n,o){return Math.sqrt(Math.pow(n-t,2)+Math.pow(o-e,2))}","import{getRect}from\"../getRect.js\";import{isRectObject}from\"./isRectObject.js\";export function getNormalizedRect(t){return isRectObject(t)?t:getRect(t)}","import{getWidth}from\"./getWidth.js\";import{getHeight}from\"./getHeight.js\";import{getOffset}from\"./getOffset.js\";import{isRectObject}from\"./utils/isRectObject.js\";export function getRect(t,e){let i=0,g=0;isRectObject(t)?(i=t.width,g=t.height):Array.isArray(t)?(i=getWidth(...t),g=getHeight(...t)):(i=getWidth(t),g=getHeight(t));const r=getOffset(t,e);return{width:i,height:g,...r,right:r.left+i,bottom:r.top+g}}","import{INCLUDE_WINDOW_SCROLLBAR,BOX_EDGE}from\"./utils/constants.js\";import{isWindow}from\"./utils/isWindow.js\";import{isDocument}from\"./utils/isDocument.js\";import{getWindowWidth}from\"./utils/getWindowWidth.js\";import{getDocumentWidth}from\"./utils/getDocumentWidth.js\";import{getElementWidth}from\"./utils/getElementWidth.js\";export function getWidth(t,i=BOX_EDGE.border){return isWindow(t)?getWindowWidth(t,INCLUDE_WINDOW_SCROLLBAR[i]):isDocument(t)?getDocumentWidth(t):getElementWidth(t,i)}","export function isWindow(n){return n instanceof Window}","export function isDocument(n){return n instanceof Document}","import{getPreciseScrollbarSize}from\"./getPreciseScrollbarSize.js\";export function getWindowWidth(e,r=!1){if(r)return e.innerWidth;const{innerWidth:t,document:i}=e,{documentElement:n}=i,{clientWidth:c}=n;return t-getPreciseScrollbarSize(n,\"y\",t-c)}","import{IS_CHROMIUM}from\"./constants.js\";import{getStyle}from\"./getStyle.js\";const SUBPIXEL_OFFSET=new Map;let testStyleElement=null,testParentElement=null,testChildElement=null;function getSubpixelScrollbarSize(t,e){const n=t.split(\".\");let l=SUBPIXEL_OFFSET.get(n[1]);if(void 0===l){testStyleElement||(testStyleElement=document.createElement(\"style\")),testStyleElement.innerHTML=`\\n      #mezr-scrollbar-test::-webkit-scrollbar {\\n        width: ${t} !important;\\n      }\\n    `,testParentElement&&testChildElement||(testParentElement=document.createElement(\"div\"),testChildElement=document.createElement(\"div\"),testParentElement.appendChild(testChildElement),testParentElement.id=\"mezr-scrollbar-test\",testParentElement.style.cssText=\"\\n        all: unset !important;\\n        position: fixed !important;\\n        top: -200px !important;\\n        left: 0px !important;\\n        width: 100px !important;\\n        height: 100px !important;\\n        overflow: scroll !important;\\n        pointer-events: none !important;\\n        visibility: hidden !important;\\n      \",testChildElement.style.cssText=\"\\n        all: unset !important;\\n        position: absolute !important;\\n        inset: 0 !important;\\n      \"),document.body.appendChild(testStyleElement),document.body.appendChild(testParentElement);l=testParentElement.getBoundingClientRect().width-testChildElement.getBoundingClientRect().width-e,SUBPIXEL_OFFSET.set(n[1],l),document.body.removeChild(testParentElement),document.body.removeChild(testStyleElement)}return e+l}export function getPreciseScrollbarSize(t,e,n){if(n<=0)return 0;if(IS_CHROMIUM){const n=getStyle(t,\"::-webkit-scrollbar\"),l=\"x\"===e?n.height:n.width,i=parseFloat(l);if(!Number.isNaN(i)&&!Number.isInteger(i))return getSubpixelScrollbarSize(l,i)}return n}","export function getDocumentWidth({documentElement:t}){return Math.max(t.scrollWidth,t.clientWidth,t.getBoundingClientRect().width)}","import{BOX_EDGE,SCROLLABLE_OVERFLOWS}from\"./constants.js\";import{getStyle}from\"./getStyle.js\";import{getPreciseScrollbarSize}from\"./getPreciseScrollbarSize.js\";import{isDocumentElement}from\"./isDocumentElement.js\";export function getElementWidth(t,e=BOX_EDGE.border){let{width:r}=t.getBoundingClientRect();if(e===BOX_EDGE.border)return r;const o=getStyle(t);return e===BOX_EDGE.margin?(r+=Math.max(0,parseFloat(o.marginLeft)||0),r+=Math.max(0,parseFloat(o.marginRight)||0),r):(r-=parseFloat(o.borderLeftWidth)||0,r-=parseFloat(o.borderRightWidth)||0,e===BOX_EDGE.scrollbar?r:(!isDocumentElement(t)&&SCROLLABLE_OVERFLOWS.has(o.overflowY)&&(r-=getPreciseScrollbarSize(t,\"y\",Math.round(r)-t.clientWidth)),e===BOX_EDGE.padding||(r-=parseFloat(o.paddingLeft)||0,r-=parseFloat(o.paddingRight)||0),r))}","import{INCLUDE_WINDOW_SCROLLBAR,BOX_EDGE}from\"./utils/constants.js\";import{isWindow}from\"./utils/isWindow.js\";import{isDocument}from\"./utils/isDocument.js\";import{getWindowHeight}from\"./utils/getWindowHeight.js\";import{getDocumentHeight}from\"./utils/getDocumentHeight.js\";import{getElementHeight}from\"./utils/getElementHeight.js\";export function getHeight(t,e=BOX_EDGE.border){return isWindow(t)?getWindowHeight(t,INCLUDE_WINDOW_SCROLLBAR[e]):isDocument(t)?getDocumentHeight(t):getElementHeight(t,e)}","import{getPreciseScrollbarSize}from\"./getPreciseScrollbarSize.js\";export function getWindowHeight(e,r=!1){if(r)return e.innerHeight;const{innerHeight:t,document:i}=e,{documentElement:n}=i,{clientHeight:c}=n;return t-getPreciseScrollbarSize(n,\"x\",t-c)}","export function getDocumentHeight({documentElement:t}){return Math.max(t.scrollHeight,t.clientHeight,t.getBoundingClientRect().height)}","import{BOX_EDGE,SCROLLABLE_OVERFLOWS}from\"./constants.js\";import{getStyle}from\"./getStyle.js\";import{getPreciseScrollbarSize}from\"./getPreciseScrollbarSize.js\";import{isDocumentElement}from\"./isDocumentElement.js\";export function getElementHeight(t,e=BOX_EDGE.border){let{height:r}=t.getBoundingClientRect();if(e===BOX_EDGE.border)return r;const o=getStyle(t);return e===BOX_EDGE.margin?(r+=Math.max(0,parseFloat(o.marginTop)||0),r+=Math.max(0,parseFloat(o.marginBottom)||0),r):(r-=parseFloat(o.borderTopWidth)||0,r-=parseFloat(o.borderBottomWidth)||0,e===BOX_EDGE.scrollbar?r:(!isDocumentElement(t)&&SCROLLABLE_OVERFLOWS.has(o.overflowX)&&(r-=getPreciseScrollbarSize(t,\"x\",Math.round(r)-t.clientHeight)),e===BOX_EDGE.padding||(r-=parseFloat(o.paddingTop)||0,r-=parseFloat(o.paddingBottom)||0),r))}","import{isRectObject}from\"./utils/isRectObject.js\";import{isDocument}from\"./utils/isDocument.js\";import{getOffsetFromDocument}from\"./utils/getOffsetFromDocument.js\";export function getOffset(t,e){const o=isRectObject(t)?{left:t.left,top:t.top}:Array.isArray(t)?getOffsetFromDocument(...t):getOffsetFromDocument(t);if(e&&!isDocument(e)){const t=isRectObject(e)?e:Array.isArray(e)?getOffsetFromDocument(e[0],e[1]):getOffsetFromDocument(e);o.left-=t.left,o.top-=t.top}return o}","export function isRectObject(t){return t?.constructor===Object}","import{BOX_EDGE}from\"./constants.js\";import{getStyle}from\"./getStyle.js\";import{isDocument}from\"./isDocument.js\";import{isWindow}from\"./isWindow.js\";export function getOffsetFromDocument(t,o=BOX_EDGE.border){const e={left:0,top:0};if(isDocument(t))return e;if(isWindow(t))return e.left+=t.scrollX||0,e.top+=t.scrollY||0,e;const r=t.ownerDocument.defaultView;r&&(e.left+=r.scrollX||0,e.top+=r.scrollY||0);const n=t.getBoundingClientRect();if(e.left+=n.left,e.top+=n.top,o===BOX_EDGE.border)return e;const l=getStyle(t);return o===BOX_EDGE.margin?(e.left-=Math.max(0,parseFloat(l.marginLeft)||0),e.top-=Math.max(0,parseFloat(l.marginTop)||0),e):(e.left+=parseFloat(l.borderLeftWidth)||0,e.top+=parseFloat(l.borderTopWidth)||0,o===BOX_EDGE.scrollbar||o===BOX_EDGE.padding||(e.left+=parseFloat(l.paddingLeft)||0,e.top+=parseFloat(l.paddingTop)||0),e)}","import{getNormalizedRect}from\"./utils/getNormalizedRect.js\";export function getIntersection(t,...e){const o={...getNormalizedRect(t),right:0,bottom:0};for(const t of e){const e=getNormalizedRect(t),i=Math.max(o.left,e.left),h=Math.min(o.left+o.width,e.left+e.width);if(h<=i)return null;const r=Math.max(o.top,e.top),l=Math.min(o.top+o.height,e.height+e.top);if(l<=r)return null;o.left=i,o.top=r,o.width=h-i,o.height=l-r}return o.right=o.left+o.width,o.bottom=o.top+o.height,o}","import{getStyle}from\"./utils/getStyle.js\";import{getContainingBlock}from\"./getContainingBlock.js\";import{isWindow}from\"./utils/isWindow.js\";export function getOffsetContainer(n,t={}){const i=getStyle(n),{display:o}=i;if(\"none\"===o||\"contents\"===o)return null;const e=t.position||getStyle(n).position,{skipDisplayNone:s,container:r}=t;switch(e){case\"relative\":return n;case\"fixed\":return getContainingBlock(n,{container:r,position:e,skipDisplayNone:s});case\"absolute\":{const t=getContainingBlock(n,{container:r,position:e,skipDisplayNone:s});return isWindow(t)?n.ownerDocument:t}default:return null}}","import{getNormalizedRect}from\"./utils/getNormalizedRect.js\";export function getOverflow(t,e){const o=getNormalizedRect(t),i=getNormalizedRect(e);return{left:i.left-o.left,right:o.left+o.width-(i.left+i.width),top:i.top-o.top,bottom:o.top+o.height-(i.top+i.height)}}","const STYLE_DECLARATION_CACHE: WeakMap<Element, WeakRef<CSSStyleDeclaration>> = new WeakMap();\n\n/**\n * Returns element's CSS Style Declaration. Caches reference to the declaration\n * object weakly for faster access.\n */\nexport function getStyle(element: Element) {\n  let styleDeclaration: CSSStyleDeclaration | undefined =\n    STYLE_DECLARATION_CACHE.get(element)?.deref();\n\n  if (!styleDeclaration) {\n    styleDeclaration = window.getComputedStyle(element, null);\n    STYLE_DECLARATION_CACHE.set(element, new WeakRef(styleDeclaration));\n  }\n\n  return styleDeclaration;\n}\n","import { getOffset } from 'mezr';\n\n/**\n * Calculate the offset difference two elements.\n */\nexport function getOffsetDiff(\n  elemA: Element | Window | Document,\n  elemB: Element | Window | Document,\n  result: { left: number; top: number } = { left: 0, top: 0 },\n) {\n  result.left = 0;\n  result.top = 0;\n\n  // If elements are same let's return early.\n  if (elemA === elemB) return result;\n\n  // Finally, let's calculate the offset diff.\n  const offsetA = getOffset([elemA, 'padding']);\n  const offsetB = getOffset([elemB, 'padding']);\n  result.left = offsetB.left - offsetA.left;\n  result.top = offsetB.top - offsetA.top;\n\n  return result;\n}\n","import { ticker, tickerReadPhase, tickerWritePhase } from '../../singletons/ticker.js';\n\nimport { Draggable, DraggablePluginMap } from '../draggable.js';\n\nimport { Sensor } from '../../sensors/sensor.js';\n\nimport {\n  AutoScrollItem,\n  AutoScrollItemSpeedCallback,\n  AutoScrollItemEventCallback,\n  AutoScrollItemTarget,\n  autoScrollSmoothSpeed,\n} from '../../auto-scroll/auto-scroll.js';\n\nimport { autoScroll } from '../../singletons/auto-scroll.js';\n\nimport { Point, Writeable } from '../../types.js';\n\nconst AUTOSCROLL_POSITION = { x: 0, y: 0 };\n\nconst AUTOSCROLL_CLIENT_RECT = { left: 0, top: 0, width: 0, height: 0 };\n\nfunction getDefaultSettings<S extends Sensor[], E extends S[number]['events']>() {\n  return {\n    targets: [],\n    inertAreaSize: 0.2,\n    speed: autoScrollSmoothSpeed(),\n    smoothStop: false,\n    getPosition: (draggable: Draggable<S, E>) => {\n      const { drag } = draggable;\n      const primaryItem = drag?.items[0];\n\n      // Try to use the first item for the autoscroll data.\n      if (primaryItem) {\n        AUTOSCROLL_POSITION.x = primaryItem.position.x;\n        AUTOSCROLL_POSITION.y = primaryItem.position.y;\n      }\n      // Fallback to the sensor's clientX/clientY values.\n      else {\n        const e = drag && (drag.event || drag.startEvent);\n        AUTOSCROLL_POSITION.x = e ? e.x : 0;\n        AUTOSCROLL_POSITION.y = e ? e.y : 0;\n      }\n\n      return AUTOSCROLL_POSITION;\n    },\n    getClientRect: (draggable: Draggable<S, E>) => {\n      const { drag } = draggable;\n      const primaryItem = drag?.items[0];\n\n      // Try to use the first item for the autoscroll data.\n      if (primaryItem && primaryItem.element) {\n        const { left, top, width, height } = primaryItem.clientRect;\n        AUTOSCROLL_CLIENT_RECT.left = left;\n        AUTOSCROLL_CLIENT_RECT.top = top;\n        AUTOSCROLL_CLIENT_RECT.width = width;\n        AUTOSCROLL_CLIENT_RECT.height = height;\n      }\n      // Fallback to the sensor's clientX/clientY values and a static size of\n      // 50x50px.\n      else {\n        const e = drag && (drag.event || drag.startEvent);\n        AUTOSCROLL_CLIENT_RECT.left = e ? e.x - 25 : 0;\n        AUTOSCROLL_CLIENT_RECT.top = e ? e.y - 25 : 0;\n        AUTOSCROLL_CLIENT_RECT.width = e ? 50 : 0;\n        AUTOSCROLL_CLIENT_RECT.height = e ? 50 : 0;\n      }\n\n      return AUTOSCROLL_CLIENT_RECT;\n    },\n    onStart: null,\n    onStop: null,\n  };\n}\n\nclass DraggableAutoScrollProxy<S extends Sensor[], E extends S[number]['events']>\n  implements AutoScrollItem\n{\n  protected _draggableAutoScroll: DraggableAutoScroll<S, E>;\n  protected _draggable: Draggable<S, E>;\n  protected _position: AutoScrollItem['position'];\n  protected _clientRect: AutoScrollItem['clientRect'];\n\n  constructor(draggableAutoScroll: DraggableAutoScroll<S, E>, draggable: Draggable<S, E>) {\n    this._draggableAutoScroll = draggableAutoScroll;\n    this._draggable = draggable;\n    this._position = { x: 0, y: 0 };\n    this._clientRect = { left: 0, top: 0, width: 0, height: 0 };\n  }\n\n  private _getSettings() {\n    return this._draggableAutoScroll.settings;\n  }\n\n  get targets() {\n    let { targets } = this._getSettings();\n    if (typeof targets === 'function') {\n      targets = targets(this._draggable);\n    }\n    return targets;\n  }\n\n  get position() {\n    let { getPosition } = this._getSettings();\n    if (typeof getPosition === 'function') {\n      const position = getPosition(this._draggable);\n      this._position.x = position.x;\n      this._position.y = position.y;\n    } else {\n      this._position.x = 0;\n      this._position.y = 0;\n    }\n    return this._position;\n  }\n\n  get clientRect() {\n    let { getClientRect } = this._getSettings();\n    if (typeof getClientRect === 'function') {\n      const { left, top, width, height } = getClientRect(this._draggable);\n      this._clientRect.left = left;\n      this._clientRect.top = top;\n      this._clientRect.width = width;\n      this._clientRect.height = height;\n    } else {\n      this._clientRect.left = 0;\n      this._clientRect.top = 0;\n      this._clientRect.width = 0;\n      this._clientRect.height = 0;\n    }\n    return this._clientRect;\n  }\n\n  get inertAreaSize() {\n    return this._getSettings().inertAreaSize;\n  }\n\n  get smoothStop() {\n    return this._getSettings().smoothStop;\n  }\n\n  get speed() {\n    return this._getSettings().speed;\n  }\n\n  get onStart() {\n    return this._getSettings().onStart;\n  }\n\n  get onStop() {\n    return this._getSettings().onStop;\n  }\n\n  onPrepareScrollEffect() {\n    const updateId = this._draggable['_updateId'];\n    ticker.off(tickerReadPhase, updateId);\n    ticker.off(tickerWritePhase, updateId);\n    this._draggable['_preparePositionUpdate']();\n  }\n\n  onApplyScrollEffect() {\n    this._draggable['_applyPositionUpdate']();\n  }\n}\n\nexport interface DraggableAutoScrollSettings<S extends Sensor[], E extends S[number]['events']> {\n  targets: AutoScrollItemTarget[] | ((draggable: Draggable<S, E>) => AutoScrollItemTarget[]);\n  inertAreaSize: number;\n  speed: number | AutoScrollItemSpeedCallback;\n  smoothStop: boolean;\n  getPosition: ((draggable: Draggable<S, E>) => Point) | null;\n  getClientRect:\n    | ((draggable: Draggable<S, E>) => {\n        left: number;\n        top: number;\n        width: number;\n        height: number;\n      })\n    | null;\n  onStart: AutoScrollItemEventCallback | null;\n  onStop: AutoScrollItemEventCallback | null;\n}\n\nexport type DraggableAutoScrollOptions<S extends Sensor[], E extends S[number]['events']> = Partial<\n  DraggableAutoScrollSettings<S, E>\n>;\n\nexport class DraggableAutoScroll<\n  S extends Sensor[] = Sensor[],\n  E extends S[number]['events'] = S[number]['events'],\n> {\n  readonly name: 'autoscroll';\n  readonly version: string;\n  readonly settings: DraggableAutoScrollSettings<S, E>;\n  protected _autoScrollProxy: DraggableAutoScrollProxy<S, E> | null;\n\n  constructor(draggable: Draggable<S, E>, options: DraggableAutoScrollOptions<S, E> = {}) {\n    this.name = 'autoscroll';\n    this.version = '0.0.2';\n    this.settings = this._parseSettings(options);\n    this._autoScrollProxy = null;\n\n    draggable.on('start', () => {\n      if (!this._autoScrollProxy) {\n        this._autoScrollProxy = new DraggableAutoScrollProxy(this, draggable);\n        autoScroll.addItem(this._autoScrollProxy);\n      }\n    });\n\n    draggable.on('end', () => {\n      if (this._autoScrollProxy) {\n        autoScroll.removeItem(this._autoScrollProxy);\n        this._autoScrollProxy = null;\n      }\n    });\n  }\n\n  protected _parseSettings(\n    options?: Partial<this['settings']>,\n    defaults: this['settings'] = getDefaultSettings(),\n  ): this['settings'] {\n    const {\n      targets = defaults.targets,\n      inertAreaSize = defaults.inertAreaSize,\n      speed = defaults.speed,\n      smoothStop = defaults.smoothStop,\n      getPosition = defaults.getPosition,\n      getClientRect = defaults.getClientRect,\n      onStart = defaults.onStart,\n      onStop = defaults.onStop,\n    } = options || {};\n\n    return {\n      targets,\n      inertAreaSize,\n      speed,\n      smoothStop,\n      getPosition,\n      getClientRect,\n      onStart,\n      onStop,\n    };\n  }\n\n  updateSettings(options: Partial<this['settings']> = {}) {\n    (this as Writeable<this>).settings = this._parseSettings(options, this.settings);\n  }\n}\n\nexport function autoScrollPlugin<\n  S extends Sensor[],\n  E extends S[number]['events'],\n  P extends DraggablePluginMap,\n>(options?: DraggableAutoScrollOptions<S, E>) {\n  return (draggable: Draggable<S, E, P>) => {\n    const p = new DraggableAutoScroll(draggable, options);\n    const d = draggable as typeof draggable & {\n      plugins: { [p.name]: typeof p };\n    };\n    d.plugins[p.name] = p;\n    return d;\n  };\n}\n","import { Emitter, EventListenerId } from 'eventti';\n\nimport { getDistance, getRect } from 'mezr';\n\nimport { Point, Rect, RectExtended } from '../types.js';\n\nimport { Pool } from '../pool.js';\n\nimport { ticker, tickerReadPhase, tickerWritePhase } from '../singletons/ticker.js';\n\nimport { getIntersectionScore } from '../utils/get-intersection-score.js';\n\nimport { getScrollElement } from '../utils/get-scroll-element.js';\n\nimport { getScrollLeft } from '../utils/get-scroll-left.js';\n\nimport { getScrollLeftMax } from '../utils/get-scroll-left-max.js';\n\nimport { getScrollTop } from '../utils/get-scroll-top.js';\n\nimport { getScrollTopMax } from '../utils/get-scroll-top-max.js';\n\nimport { isIntersecting } from '../utils/is-intersecting.js';\n\n//\n// CONSTANTS\n//\n\nconst R1: RectExtended = {\n  width: 0,\n  height: 0,\n  left: 0,\n  right: 0,\n  top: 0,\n  bottom: 0,\n};\n\nconst R2: RectExtended = { ...R1 };\n\nconst DEFAULT_THRESHOLD = 50;\n\nconst SPEED_DATA: AutoScrollSpeedData = {\n  direction: 'none',\n  threshold: 0,\n  distance: 0,\n  value: 0,\n  maxValue: 0,\n  duration: 0,\n  speed: 0,\n  deltaTime: 0,\n  isEnding: false,\n};\n\nexport const AUTO_SCROLL_AXIS = {\n  x: 1,\n  y: 2,\n} as const;\n\nexport const AUTO_SCROLL_AXIS_DIRECTION = {\n  forward: 4,\n  reverse: 8,\n} as const;\n\nconst AUTO_SCROLL_DIRECTION_X = {\n  none: 0,\n  left: (AUTO_SCROLL_AXIS.x | AUTO_SCROLL_AXIS_DIRECTION.reverse) as 9,\n  right: (AUTO_SCROLL_AXIS.x | AUTO_SCROLL_AXIS_DIRECTION.forward) as 5,\n} as const;\n\nconst AUTO_SCROLL_DIRECTION_Y = {\n  none: 0,\n  up: (AUTO_SCROLL_AXIS.y | AUTO_SCROLL_AXIS_DIRECTION.reverse) as 10,\n  down: (AUTO_SCROLL_AXIS.y | AUTO_SCROLL_AXIS_DIRECTION.forward) as 6,\n} as const;\n\nexport const AUTO_SCROLL_DIRECTION = {\n  ...AUTO_SCROLL_DIRECTION_X,\n  ...AUTO_SCROLL_DIRECTION_Y,\n} as const;\n\nfunction getDirectionAsString(direction: number) {\n  switch (direction) {\n    case AUTO_SCROLL_DIRECTION_X.none:\n    case AUTO_SCROLL_DIRECTION_Y.none:\n      return 'none';\n    case AUTO_SCROLL_DIRECTION_X.left:\n      return 'left';\n    case AUTO_SCROLL_DIRECTION_X.right:\n      return 'right';\n    case AUTO_SCROLL_DIRECTION_Y.up:\n      return 'up';\n    case AUTO_SCROLL_DIRECTION_Y.down:\n      return 'down';\n    default:\n      throw new Error(`Unknown direction value: ${direction}`);\n  }\n}\n\nfunction getPaddedRect(rect: RectExtended, padding: AutoScrollTargetPadding, result: RectExtended) {\n  let { left = 0, right = 0, top = 0, bottom = 0 } = padding;\n\n  // Don't allow negative padding.\n  left = Math.max(0, left);\n  right = Math.max(0, right);\n  top = Math.max(0, top);\n  bottom = Math.max(0, bottom);\n\n  result.width = rect.width + left + right;\n  result.height = rect.height + top + bottom;\n  result.left = rect.left - left;\n  result.top = rect.top - top;\n  result.right = rect.right + right;\n  result.bottom = rect.bottom + bottom;\n\n  return result;\n}\n\nfunction isScrolledToMax(scrollValue: number, maxScrollValue: number) {\n  // In some scenarios the scrollValue and/or maxScrollValue can be a float\n  // with subpixel values which might cause some funky scenarios where the\n  // element tries to scroll to the end but never actually reaches it. In such\n  // cases we want to do some rounding to detect that the element has actually\n  // reached the end of the scroll.\n  return Math.ceil(scrollValue) >= Math.floor(maxScrollValue);\n}\n\n//\n// PRIVATE TYPES\n//\n\ntype AutoScrollAxis = (typeof AUTO_SCROLL_AXIS)[keyof typeof AUTO_SCROLL_AXIS];\n\ntype AutoScrollDirectionX = (typeof AUTO_SCROLL_DIRECTION_X)[keyof typeof AUTO_SCROLL_DIRECTION_X];\n\ntype AutoScrollDirectionY = (typeof AUTO_SCROLL_DIRECTION_Y)[keyof typeof AUTO_SCROLL_DIRECTION_Y];\n\ntype AutoScrollDirection = (typeof AUTO_SCROLL_DIRECTION)[keyof typeof AUTO_SCROLL_DIRECTION];\n\ninterface AutoScrollSpeedData {\n  direction: ReturnType<typeof getDirectionAsString>;\n  threshold: number;\n  distance: number;\n  value: number;\n  maxValue: number;\n  duration: number;\n  speed: number;\n  deltaTime: number;\n  isEnding: boolean;\n}\n\ntype AutoScrollTargetPadding = {\n  left?: number;\n  right?: number;\n  top?: number;\n  bottom?: number;\n};\n\n//\n// PUBLIC TYPES\n//\n\nexport interface AutoScrollItem {\n  readonly targets: AutoScrollItemTarget[];\n  readonly clientRect: Rect;\n  readonly position: Point;\n  readonly inertAreaSize: number;\n  readonly smoothStop: boolean;\n  readonly speed: number | AutoScrollItemSpeedCallback;\n  readonly onStart?: AutoScrollItemEventCallback | null;\n  readonly onStop?: AutoScrollItemEventCallback | null;\n  readonly onPrepareScrollEffect?: AutoScrollItemEffectCallback | null;\n  readonly onApplyScrollEffect?: AutoScrollItemEffectCallback | null;\n}\n\nexport interface AutoScrollSettings {\n  overlapCheckInterval: number;\n}\n\nexport interface AutoScrollOptions extends Partial<AutoScrollSettings> {}\n\nexport interface AutoScrollEventCallbacks {\n  beforescroll(): void;\n  afterscroll(): void;\n}\n\nexport interface AutoScrollItemTarget {\n  element: Window | Element;\n  axis?: 'x' | 'y' | 'xy';\n  priority?: number;\n  threshold?: number;\n  padding?: AutoScrollTargetPadding;\n  scrollPadding?: AutoScrollTargetPadding;\n}\n\nexport type AutoScrollItemEventCallback = (\n  scrollElement: Window | Element,\n  scrollDirection: ReturnType<typeof getDirectionAsString>,\n) => void;\n\nexport type AutoScrollItemEffectCallback = () => void;\n\nexport type AutoScrollItemSpeedCallback = (\n  scrollElement: Window | Element,\n  scrollData: AutoScrollSpeedData,\n) => number;\n\n//\n// PRIVATE UTILS\n//\n\nfunction computeThreshold(idealThreshold: number, targetSize: number) {\n  return Math.min(targetSize / 2, idealThreshold);\n}\n\nfunction computeEdgeOffset(\n  threshold: number,\n  inertAreaSize: number,\n  itemSize: number,\n  targetSize: number,\n) {\n  return Math.max(0, itemSize + threshold * 2 + targetSize * inertAreaSize - targetSize) / 2;\n}\n\nclass AutoScrollItemData {\n  positionX: number;\n  positionY: number;\n  directionX: AutoScrollDirectionX;\n  directionY: AutoScrollDirectionY;\n  overlapCheckRequestTime: number;\n\n  constructor() {\n    this.positionX = 0;\n    this.positionY = 0;\n    this.directionX = AUTO_SCROLL_DIRECTION.none;\n    this.directionY = AUTO_SCROLL_DIRECTION.none;\n    this.overlapCheckRequestTime = 0;\n  }\n}\n\nclass AutoScrollAction {\n  element: Element | Window | null;\n  requestX: AutoScrollRequest | null;\n  requestY: AutoScrollRequest | null;\n  scrollLeft: number;\n  scrollTop: number;\n\n  constructor() {\n    this.element = null;\n    this.requestX = null;\n    this.requestY = null;\n    this.scrollLeft = 0;\n    this.scrollTop = 0;\n  }\n\n  reset() {\n    if (this.requestX) this.requestX.action = null;\n    if (this.requestY) this.requestY.action = null;\n    this.element = null;\n    this.requestX = null;\n    this.requestY = null;\n    this.scrollLeft = 0;\n    this.scrollTop = 0;\n  }\n\n  addRequest(request: AutoScrollRequest) {\n    if (AUTO_SCROLL_AXIS.x & request.direction) {\n      this.requestX && this.removeRequest(this.requestX);\n      this.requestX = request;\n    } else {\n      this.requestY && this.removeRequest(this.requestY);\n      this.requestY = request;\n    }\n    request.action = this;\n  }\n\n  removeRequest(request: AutoScrollRequest) {\n    if (this.requestX === request) {\n      this.requestX = null;\n      request.action = null;\n    } else if (this.requestY === request) {\n      this.requestY = null;\n      request.action = null;\n    }\n  }\n\n  computeScrollValues() {\n    if (!this.element) return;\n    this.scrollLeft = this.requestX ? this.requestX.value : getScrollLeft(this.element);\n    this.scrollTop = this.requestY ? this.requestY.value : getScrollTop(this.element);\n  }\n\n  scroll() {\n    if (!this.element) return;\n\n    if (this.element.scrollTo) {\n      this.element.scrollTo(this.scrollLeft, this.scrollTop);\n    } else {\n      (this.element as Element).scrollLeft = this.scrollLeft;\n      (this.element as Element).scrollTop = this.scrollTop;\n    }\n  }\n}\n\nclass AutoScrollRequest {\n  item: AutoScrollItem | null;\n  element: Element | Window | null;\n  isActive: boolean;\n  isEnding: boolean;\n  direction: AutoScrollDirection;\n  value: number;\n  maxValue: number;\n  threshold: number;\n  distance: number;\n  deltaTime: number;\n  speed: number;\n  duration: number;\n  action: AutoScrollAction | null;\n\n  constructor() {\n    this.item = null;\n    this.element = null;\n    this.isActive = false;\n    this.isEnding = false;\n    this.direction = 0;\n    this.value = NaN;\n    this.maxValue = 0;\n    this.threshold = 0;\n    this.distance = 0;\n    this.deltaTime = 0;\n    this.speed = 0;\n    this.duration = 0;\n    this.action = null;\n  }\n\n  reset() {\n    if (this.isActive) this.onStop();\n    this.item = null;\n    this.element = null;\n    this.isActive = false;\n    this.isEnding = false;\n    this.direction = 0;\n    this.value = NaN;\n    this.maxValue = 0;\n    this.threshold = 0;\n    this.distance = 0;\n    this.deltaTime = 0;\n    this.speed = 0;\n    this.duration = 0;\n    this.action = null;\n  }\n\n  hasReachedEnd() {\n    return AUTO_SCROLL_AXIS_DIRECTION.forward & this.direction\n      ? isScrolledToMax(this.value, this.maxValue)\n      : this.value <= 0;\n  }\n\n  computeCurrentScrollValue() {\n    if (!this.element) return 0;\n\n    if (this.value !== this.value) {\n      return AUTO_SCROLL_AXIS.x & this.direction\n        ? getScrollLeft(this.element)\n        : getScrollTop(this.element);\n    }\n\n    return Math.max(0, Math.min(this.value, this.maxValue));\n  }\n\n  computeNextScrollValue() {\n    const delta = this.speed * (this.deltaTime / 1000);\n    const nextValue =\n      AUTO_SCROLL_AXIS_DIRECTION.forward & this.direction ? this.value + delta : this.value - delta;\n    return Math.max(0, Math.min(nextValue, this.maxValue));\n  }\n\n  computeSpeed() {\n    if (!this.item || !this.element) return 0;\n    const { speed } = this.item;\n    if (typeof speed === 'function') {\n      SPEED_DATA.direction = getDirectionAsString(this.direction);\n      SPEED_DATA.threshold = this.threshold;\n      SPEED_DATA.distance = this.distance;\n      SPEED_DATA.value = this.value;\n      SPEED_DATA.maxValue = this.maxValue;\n      SPEED_DATA.duration = this.duration;\n      SPEED_DATA.speed = this.speed;\n      SPEED_DATA.deltaTime = this.deltaTime;\n      SPEED_DATA.isEnding = this.isEnding;\n      return speed(this.element, SPEED_DATA);\n    } else {\n      return speed;\n    }\n  }\n\n  tick(deltaTime: number) {\n    if (!this.isActive) {\n      this.isActive = true;\n      this.onStart();\n    }\n    this.deltaTime = deltaTime;\n    this.value = this.computeCurrentScrollValue();\n    this.speed = this.computeSpeed();\n    this.value = this.computeNextScrollValue();\n    this.duration += deltaTime;\n    return this.value;\n  }\n\n  onStart() {\n    if (!this.item || !this.element) return;\n    const { onStart } = this.item;\n    if (typeof onStart === 'function') {\n      onStart(this.element, getDirectionAsString(this.direction));\n    }\n  }\n\n  onStop() {\n    if (!this.item || !this.element) return;\n    const { onStop } = this.item;\n    if (typeof onStop === 'function') {\n      onStop(this.element, getDirectionAsString(this.direction));\n    }\n  }\n}\n\n//\n// PUBLIC UTILS\n//\n\nexport function autoScrollSmoothSpeed(\n  // Pixels per second.\n  maxSpeed = 500,\n  // Time in seconds, how long it will take to accelerate from 0 to maxSpeed.\n  accelerationFactor = 0.5,\n  // Time in seconds, how long it will take to decelerate maxSpeed to 0.\n  decelerationFactor = 0.25,\n): AutoScrollItemSpeedCallback {\n  const acceleration = maxSpeed * (accelerationFactor > 0 ? 1 / accelerationFactor : Infinity);\n  const deceleration = maxSpeed * (decelerationFactor > 0 ? 1 / decelerationFactor : Infinity);\n  return function (_element, data) {\n    let targetSpeed = 0;\n    if (!data.isEnding) {\n      if (data.threshold > 0) {\n        const factor = data.threshold - Math.max(0, data.distance);\n        targetSpeed = (maxSpeed / data.threshold) * factor;\n      } else {\n        targetSpeed = maxSpeed;\n      }\n    }\n\n    const currentSpeed = data.speed;\n    if (currentSpeed === targetSpeed) return targetSpeed;\n\n    let nextSpeed = targetSpeed;\n    if (currentSpeed < targetSpeed) {\n      nextSpeed = currentSpeed + acceleration * (data.deltaTime / 1000);\n      return Math.min(targetSpeed, nextSpeed);\n    } else {\n      nextSpeed = currentSpeed - deceleration * (data.deltaTime / 1000);\n      return Math.max(targetSpeed, nextSpeed);\n    }\n  };\n}\n\n//\n// AUTOSCROLL MAIN CLASS\n//\n\nexport class AutoScroll {\n  readonly items: AutoScrollItem[];\n  readonly settings: AutoScrollSettings;\n  protected _isDestroyed: boolean;\n  protected _isTicking: boolean;\n  protected _tickTime: number;\n  protected _tickDeltaTime: number;\n  protected _itemData: Map<AutoScrollItem, AutoScrollItemData>;\n  protected _actions: AutoScrollAction[];\n  protected _requests: {\n    [AUTO_SCROLL_AXIS.x]: Map<AutoScrollItem, AutoScrollRequest>;\n    [AUTO_SCROLL_AXIS.y]: Map<AutoScrollItem, AutoScrollRequest>;\n  };\n  protected _requestPool: Pool<AutoScrollRequest>;\n  protected _actionPool: Pool<AutoScrollAction>;\n  protected _emitter: Emitter<{\n    beforescroll: () => void;\n    afterscroll: () => void;\n  }>;\n\n  constructor(options: AutoScrollOptions = {}) {\n    const { overlapCheckInterval = 150 } = options;\n\n    this.items = [];\n    this.settings = {\n      overlapCheckInterval,\n    };\n\n    this._actions = [];\n    this._isDestroyed = false;\n    this._isTicking = false;\n    this._tickTime = 0;\n    this._tickDeltaTime = 0;\n    this._requests = {\n      [AUTO_SCROLL_AXIS.x]: new Map(),\n      [AUTO_SCROLL_AXIS.y]: new Map(),\n    };\n    this._itemData = new Map();\n    this._requestPool = new Pool<AutoScrollRequest>(\n      () => new AutoScrollRequest(),\n      (request) => request.reset(),\n    );\n    this._actionPool = new Pool<AutoScrollAction>(\n      () => new AutoScrollAction(),\n      (action) => action.reset(),\n    );\n\n    this._emitter = new Emitter();\n\n    this._frameRead = this._frameRead.bind(this);\n    this._frameWrite = this._frameWrite.bind(this);\n  }\n\n  protected _frameRead(time: number) {\n    if (this._isDestroyed) return;\n    if (time && this._tickTime) {\n      this._tickDeltaTime = time - this._tickTime;\n      this._tickTime = time;\n      this._updateItems();\n      this._updateRequests();\n      this._updateActions();\n    } else {\n      this._tickTime = time;\n      this._tickDeltaTime = 0;\n    }\n  }\n\n  protected _frameWrite() {\n    if (this._isDestroyed) return;\n    this._applyActions();\n  }\n\n  protected _startTicking() {\n    if (this._isTicking) return;\n    this._isTicking = true;\n    ticker.on(tickerReadPhase, this._frameRead, this._frameRead);\n    ticker.on(tickerWritePhase, this._frameWrite, this._frameWrite);\n  }\n\n  protected _stopTicking() {\n    if (!this._isTicking) return;\n    this._isTicking = false;\n    this._tickTime = 0;\n    this._tickDeltaTime = 0;\n    ticker.off(tickerReadPhase, this._frameRead);\n    ticker.off(tickerWritePhase, this._frameWrite);\n  }\n\n  protected _getItemClientRect(\n    item: AutoScrollItem,\n    result: RectExtended = { width: 0, height: 0, left: 0, right: 0, top: 0, bottom: 0 },\n  ) {\n    const { clientRect } = item;\n    result.left = clientRect.left;\n    result.top = clientRect.top;\n    result.width = clientRect.width;\n    result.height = clientRect.height;\n    result.right = clientRect.left + clientRect.width;\n    result.bottom = clientRect.top + clientRect.height;\n    return result;\n  }\n\n  protected _requestItemScroll(\n    item: AutoScrollItem,\n    axis: AutoScrollAxis,\n    element: Window | Element,\n    direction: AutoScrollDirection,\n    threshold: number,\n    distance: number,\n    maxValue: number,\n  ) {\n    const reqMap = this._requests[axis];\n    let request = reqMap.get(item);\n\n    if (request) {\n      if (request.element !== element || request.direction !== direction) {\n        request.reset();\n      }\n    } else {\n      request = this._requestPool.pick();\n      reqMap.set(item, request);\n    }\n\n    request.item = item;\n    request.element = element;\n    request.direction = direction;\n    request.threshold = threshold;\n    request.distance = distance;\n    request.maxValue = maxValue;\n  }\n\n  protected _cancelItemScroll(item: AutoScrollItem, axis: AutoScrollAxis) {\n    const reqMap = this._requests[axis];\n    const request = reqMap.get(item);\n    if (!request) return;\n\n    if (request.action) request.action.removeRequest(request);\n    this._requestPool.put(request);\n    reqMap.delete(item);\n  }\n\n  protected _checkItemOverlap(item: AutoScrollItem, checkX: boolean, checkY: boolean) {\n    const { inertAreaSize, targets } = item;\n    if (!targets.length) {\n      checkX && this._cancelItemScroll(item, AUTO_SCROLL_AXIS.x);\n      checkY && this._cancelItemScroll(item, AUTO_SCROLL_AXIS.y);\n      return;\n    }\n\n    const itemData = this._itemData.get(item);\n    const moveDirectionX = itemData?.directionX;\n    const moveDirectionY = itemData?.directionY;\n    if (!moveDirectionX && !moveDirectionY) {\n      checkX && this._cancelItemScroll(item, AUTO_SCROLL_AXIS.x);\n      checkY && this._cancelItemScroll(item, AUTO_SCROLL_AXIS.y);\n      return;\n    }\n\n    const itemRect = this._getItemClientRect(item, R1);\n\n    let xElement: Window | Element | null = null;\n    let xPriority = -Infinity;\n    let xThreshold = 0;\n    let xScore = -Infinity;\n    let xDirection: AutoScrollDirectionX = AUTO_SCROLL_DIRECTION.none;\n    let xDistance = 0;\n    let xMaxScroll = 0;\n\n    let yElement: Window | Element | null = null;\n    let yPriority = -Infinity;\n    let yThreshold = 0;\n    let yScore = -Infinity;\n    let yDirection: AutoScrollDirectionY = AUTO_SCROLL_DIRECTION.none;\n    let yDistance = 0;\n    let yMaxScroll = 0;\n\n    let i = 0;\n    for (; i < targets.length; i++) {\n      const target = targets[i];\n      const targetThreshold =\n        typeof target.threshold === 'number' ? target.threshold : DEFAULT_THRESHOLD;\n      const testAxisX = !!(checkX && moveDirectionX && target.axis !== 'y');\n      const testAxisY = !!(checkY && moveDirectionY && target.axis !== 'x');\n      const testPriority = target.priority || 0;\n\n      // Ignore this item if it's x-axis and y-axis priority is lower than\n      // the currently matching item's.\n      if ((!testAxisX || testPriority < xPriority) && (!testAxisY || testPriority < yPriority)) {\n        continue;\n      }\n\n      const testElement = getScrollElement(target.element || target);\n      const testMaxScrollX = testAxisX ? getScrollLeftMax(testElement) : -1;\n      const testMaxScrollY = testAxisY ? getScrollTopMax(testElement) : -1;\n\n      // Ignore this item if there is no possibility to scroll.\n      if (testMaxScrollX <= 0 && testMaxScrollY <= 0) continue;\n\n      const testRect = getRect([testElement, 'padding'], window);\n      let testScore = getIntersectionScore(itemRect, testRect) || -Infinity;\n\n      // If the item has no overlap with the target.\n      if (testScore === -Infinity) {\n        // If the target has virtual extra padding defined and it's padded\n        // version overlaps with item then let's compute the shortest distance\n        // between item and target and use that value (negated) as testScore.\n        if (\n          target.padding &&\n          isIntersecting(itemRect, getPaddedRect(testRect, target.padding, R2))\n        ) {\n          testScore = -(getDistance(itemRect, testRect) || 0);\n        }\n        // Otherwise let's ignore this target.\n        else {\n          continue;\n        }\n      }\n\n      // Test x-axis.\n      if (\n        testAxisX &&\n        testPriority >= xPriority &&\n        testMaxScrollX > 0 &&\n        (testPriority > xPriority || testScore > xScore)\n      ) {\n        let testDistance = 0;\n        let testDirection: AutoScrollDirectionX = AUTO_SCROLL_DIRECTION.none;\n        const testThreshold = computeThreshold(targetThreshold, testRect.width);\n        const testEdgeOffset = computeEdgeOffset(\n          testThreshold,\n          inertAreaSize,\n          itemRect.width,\n          testRect.width,\n        );\n\n        if (moveDirectionX === AUTO_SCROLL_DIRECTION.right) {\n          testDistance = testRect.right + testEdgeOffset - itemRect.right;\n          if (\n            testDistance <= testThreshold &&\n            !isScrolledToMax(getScrollLeft(testElement), testMaxScrollX)\n          ) {\n            testDirection = AUTO_SCROLL_DIRECTION.right;\n          }\n        } else if (moveDirectionX === AUTO_SCROLL_DIRECTION.left) {\n          testDistance = itemRect.left - (testRect.left - testEdgeOffset);\n          if (testDistance <= testThreshold && getScrollLeft(testElement) > 0) {\n            testDirection = AUTO_SCROLL_DIRECTION.left;\n          }\n        }\n\n        if (testDirection) {\n          xElement = testElement;\n          xPriority = testPriority;\n          xThreshold = testThreshold;\n          xScore = testScore;\n          xDirection = testDirection;\n          xDistance = testDistance;\n          xMaxScroll = testMaxScrollX;\n        }\n      }\n\n      // Test y-axis.\n      if (\n        testAxisY &&\n        testPriority >= yPriority &&\n        testMaxScrollY > 0 &&\n        (testPriority > yPriority || testScore > yScore)\n      ) {\n        let testDistance = 0;\n        let testDirection: AutoScrollDirectionY = AUTO_SCROLL_DIRECTION_Y.none;\n        const testThreshold = computeThreshold(targetThreshold, testRect.height);\n        const testEdgeOffset = computeEdgeOffset(\n          testThreshold,\n          inertAreaSize,\n          itemRect.height,\n          testRect.height,\n        );\n\n        if (moveDirectionY === AUTO_SCROLL_DIRECTION.down) {\n          testDistance = testRect.bottom + testEdgeOffset - itemRect.bottom;\n          if (\n            testDistance <= testThreshold &&\n            !isScrolledToMax(getScrollTop(testElement), testMaxScrollY)\n          ) {\n            testDirection = AUTO_SCROLL_DIRECTION.down;\n          }\n        } else if (moveDirectionY === AUTO_SCROLL_DIRECTION.up) {\n          testDistance = itemRect.top - (testRect.top - testEdgeOffset);\n          if (testDistance <= testThreshold && getScrollTop(testElement) > 0) {\n            testDirection = AUTO_SCROLL_DIRECTION.up;\n          }\n        }\n\n        if (testDirection) {\n          yElement = testElement;\n          yPriority = testPriority;\n          yThreshold = testThreshold;\n          yScore = testScore;\n          yDirection = testDirection;\n          yDistance = testDistance;\n          yMaxScroll = testMaxScrollY;\n        }\n      }\n    }\n\n    // Request or cancel x-axis scroll.\n    if (checkX) {\n      if (xElement && xDirection) {\n        this._requestItemScroll(\n          item,\n          AUTO_SCROLL_AXIS.x,\n          xElement,\n          xDirection,\n          xThreshold,\n          xDistance,\n          xMaxScroll,\n        );\n      } else {\n        this._cancelItemScroll(item, AUTO_SCROLL_AXIS.x);\n      }\n    }\n\n    // Request or cancel y-axis scroll.\n    if (checkY) {\n      if (yElement && yDirection) {\n        this._requestItemScroll(\n          item,\n          AUTO_SCROLL_AXIS.y,\n          yElement,\n          yDirection,\n          yThreshold,\n          yDistance,\n          yMaxScroll,\n        );\n      } else {\n        this._cancelItemScroll(item, AUTO_SCROLL_AXIS.y);\n      }\n    }\n  }\n\n  protected _updateScrollRequest(scrollRequest: AutoScrollRequest) {\n    const item = scrollRequest.item!;\n    const { inertAreaSize, smoothStop, targets } = item;\n    const itemRect = this._getItemClientRect(item, R1);\n    let hasReachedEnd = null;\n\n    let i = 0;\n    for (; i < targets.length; i++) {\n      const target = targets[i];\n\n      // Make sure we have a matching element.\n      const testElement = getScrollElement(target.element || target);\n      if (testElement !== scrollRequest.element) continue;\n\n      // Make sure we have a matching axis.\n      const testIsAxisX = !!(AUTO_SCROLL_AXIS.x & scrollRequest.direction);\n      if (testIsAxisX) {\n        if (target.axis === 'y') continue;\n      } else {\n        if (target.axis === 'x') continue;\n      }\n\n      // Make sure the element is still scrollable.\n      const testMaxScroll = testIsAxisX\n        ? getScrollLeftMax(testElement)\n        : getScrollTopMax(testElement);\n      if (testMaxScroll <= 0) {\n        break;\n      }\n\n      const testRect = getRect([testElement, 'padding'], window);\n      const testScore = getIntersectionScore(itemRect, testRect) || -Infinity;\n\n      // If the item has no overlap with the target nor the padded target rect\n      // let's stop scrolling.\n      if (testScore === -Infinity) {\n        const padding = target.scrollPadding || target.padding;\n        if (!(padding && isIntersecting(itemRect, getPaddedRect(testRect, padding, R2)))) {\n          break;\n        }\n      }\n\n      // Compute threshold.\n      const targetThreshold =\n        typeof target.threshold === 'number' ? target.threshold : DEFAULT_THRESHOLD;\n      const testThreshold = computeThreshold(\n        targetThreshold,\n        testIsAxisX ? testRect.width : testRect.height,\n      );\n\n      // Compute edge offset.\n      const testEdgeOffset = computeEdgeOffset(\n        testThreshold,\n        inertAreaSize,\n        testIsAxisX ? itemRect.width : itemRect.height,\n        testIsAxisX ? testRect.width : testRect.height,\n      );\n\n      // Compute distance (based on current direction).\n      let testDistance = 0;\n      if (scrollRequest.direction === AUTO_SCROLL_DIRECTION.left) {\n        testDistance = itemRect.left - (testRect.left - testEdgeOffset);\n      } else if (scrollRequest.direction === AUTO_SCROLL_DIRECTION.right) {\n        testDistance = testRect.right + testEdgeOffset - itemRect.right;\n      } else if (scrollRequest.direction === AUTO_SCROLL_DIRECTION.up) {\n        testDistance = itemRect.top - (testRect.top - testEdgeOffset);\n      } else {\n        testDistance = testRect.bottom + testEdgeOffset - itemRect.bottom;\n      }\n\n      // Stop scrolling if threshold is not exceeded.\n      if (testDistance > testThreshold) {\n        break;\n      }\n\n      // Stop scrolling if we have reached max scroll value.\n      const testScroll = testIsAxisX ? getScrollLeft(testElement) : getScrollTop(testElement);\n      hasReachedEnd =\n        AUTO_SCROLL_AXIS_DIRECTION.forward & scrollRequest.direction\n          ? isScrolledToMax(testScroll, testMaxScroll)\n          : testScroll <= 0;\n      if (hasReachedEnd) break;\n\n      // Scrolling can continue, let's update the values.\n      scrollRequest.maxValue = testMaxScroll;\n      scrollRequest.threshold = testThreshold;\n      scrollRequest.distance = testDistance;\n      scrollRequest.isEnding = false;\n      return true;\n    }\n\n    // Before we end the request, let's see if we need to stop the scrolling\n    // smoothly or immediately.\n    if (smoothStop === true && scrollRequest.speed > 0) {\n      if (hasReachedEnd === null) hasReachedEnd = scrollRequest.hasReachedEnd();\n      scrollRequest.isEnding = hasReachedEnd ? false : true;\n    } else {\n      scrollRequest.isEnding = false;\n    }\n\n    return scrollRequest.isEnding;\n  }\n\n  protected _updateItems() {\n    for (let i = 0; i < this.items.length; i++) {\n      const item = this.items[i];\n      const itemData = this._itemData.get(item)!;\n      const { x, y } = item.position;\n      const prevX = itemData.positionX;\n      const prevY = itemData.positionY;\n\n      // If there is no change in position -> skip.\n      if (x === prevX && y === prevY) {\n        continue;\n      }\n\n      // Update direction x.\n      itemData.directionX =\n        x > prevX\n          ? AUTO_SCROLL_DIRECTION.right\n          : x < prevX\n            ? AUTO_SCROLL_DIRECTION.left\n            : itemData.directionX;\n\n      // Update direction y.\n      itemData.directionY =\n        y > prevY\n          ? AUTO_SCROLL_DIRECTION.down\n          : y < prevY\n            ? AUTO_SCROLL_DIRECTION.up\n            : itemData.directionY;\n\n      // Update positions.\n      itemData.positionX = x;\n      itemData.positionY = y;\n\n      // Request overlap check (if not already requested).\n      if (itemData.overlapCheckRequestTime === 0) {\n        itemData.overlapCheckRequestTime = this._tickTime;\n      }\n    }\n  }\n\n  protected _updateRequests() {\n    const items = this.items;\n    const requestsX = this._requests[AUTO_SCROLL_AXIS.x];\n    const requestsY = this._requests[AUTO_SCROLL_AXIS.y];\n\n    let i = 0;\n    for (; i < items.length; i++) {\n      const item = items[i];\n      const itemData = this._itemData.get(item)!;\n      const checkTime = itemData.overlapCheckRequestTime;\n      let needsCheck =\n        checkTime > 0 && this._tickTime - checkTime > this.settings.overlapCheckInterval;\n\n      let checkX = true;\n      const reqX = requestsX.get(item);\n      if (reqX && reqX.isActive) {\n        checkX = !this._updateScrollRequest(reqX);\n        if (checkX) {\n          needsCheck = true;\n          this._cancelItemScroll(item, AUTO_SCROLL_AXIS.x);\n        }\n      }\n\n      let checkY = true;\n      const reqY = requestsY.get(item);\n      if (reqY && reqY.isActive) {\n        checkY = !this._updateScrollRequest(reqY);\n        if (checkY) {\n          needsCheck = true;\n          this._cancelItemScroll(item, AUTO_SCROLL_AXIS.y);\n        }\n      }\n\n      if (needsCheck) {\n        itemData.overlapCheckRequestTime = 0;\n        this._checkItemOverlap(item, checkX, checkY);\n      }\n    }\n  }\n\n  protected _requestAction(request: AutoScrollRequest, axis: AutoScrollAxis) {\n    const isAxisX = axis === AUTO_SCROLL_AXIS.x;\n    let action: AutoScrollAction | null = null;\n\n    let i = 0;\n    for (; i < this._actions.length; i++) {\n      action = this._actions[i];\n\n      // If the action's request does not match the request's -> skip.\n      if (request.element !== action.element) {\n        action = null;\n        continue;\n      }\n\n      // If the request and action share the same element, but the request slot\n      // for the requested axis is already reserved let's ignore and cancel this\n      // request.\n      if (isAxisX ? action.requestX : action.requestY) {\n        this._cancelItemScroll(request.item!, axis);\n        return;\n      }\n\n      // Seems like we have found our action, let's break the loop.\n      break;\n    }\n\n    if (!action) action = this._actionPool.pick();\n    action.element = request.element;\n    action.addRequest(request);\n\n    request.tick(this._tickDeltaTime);\n    this._actions.push(action);\n  }\n\n  protected _updateActions() {\n    let i = 0;\n\n    // Generate actions.\n    for (i = 0; i < this.items.length; i++) {\n      const item = this.items[i];\n      const reqX = this._requests[AUTO_SCROLL_AXIS.x].get(item);\n      const reqY = this._requests[AUTO_SCROLL_AXIS.y].get(item);\n      if (reqX) this._requestAction(reqX, AUTO_SCROLL_AXIS.x);\n      if (reqY) this._requestAction(reqY, AUTO_SCROLL_AXIS.y);\n    }\n\n    // Compute scroll values.\n    for (i = 0; i < this._actions.length; i++) {\n      this._actions[i].computeScrollValues();\n    }\n  }\n\n  protected _applyActions() {\n    // No actions -> no scrolling.\n    if (!this._actions.length) return;\n\n    // TODO: Would be nice to emit also the elements that will be scrolled,\n    // to which direction they will be scrolled and how much they will be\n    // scrolled.\n    this._emitter.emit('beforescroll');\n\n    let i = 0;\n\n    // Scroll all the required elements.\n    for (i = 0; i < this._actions.length; i++) {\n      this._actions[i].scroll();\n      this._actionPool.put(this._actions[i]);\n    }\n\n    // Reset actions.\n    this._actions.length = 0;\n\n    // Call after scroll callbacks for all items that were scrolled.\n    let item: AutoScrollItem;\n    for (i = 0; i < this.items.length; i++) {\n      item = this.items[i];\n      if (item.onPrepareScrollEffect) {\n        item.onPrepareScrollEffect();\n      }\n    }\n    for (i = 0; i < this.items.length; i++) {\n      item = this.items[i];\n      if (item.onApplyScrollEffect) {\n        item.onApplyScrollEffect();\n      }\n    }\n\n    // TODO: Would be nice to emit also the elements that were scrolled,\n    // to which direction they were scrolled and how much they were scrolled.\n    this._emitter.emit('afterscroll');\n  }\n\n  /**\n   * Bind a listener.\n   */\n  on<T extends keyof AutoScrollEventCallbacks>(\n    type: T,\n    listener: AutoScrollEventCallbacks[T],\n    listenerId?: EventListenerId,\n  ): EventListenerId {\n    return this._emitter.on(type, listener, listenerId);\n  }\n\n  /**\n   * Unbind a listener.\n   */\n  off<T extends keyof AutoScrollEventCallbacks>(type: T, listenerId: EventListenerId): void {\n    this._emitter.off(type, listenerId);\n  }\n\n  addItem(item: AutoScrollItem) {\n    if (this._isDestroyed || this._itemData.has(item)) return;\n\n    const { x, y } = item.position;\n    const itemData = new AutoScrollItemData();\n\n    itemData.positionX = x;\n    itemData.positionY = y;\n    itemData.directionX = AUTO_SCROLL_DIRECTION.none;\n    itemData.directionY = AUTO_SCROLL_DIRECTION.none;\n    itemData.overlapCheckRequestTime = this._tickTime;\n\n    this._itemData.set(item, itemData);\n    this.items.push(item);\n    if (!this._isTicking) this._startTicking();\n  }\n\n  removeItem(item: AutoScrollItem) {\n    if (this._isDestroyed) return;\n\n    const index = this.items.indexOf(item);\n    if (index === -1) return;\n\n    if (this._requests[AUTO_SCROLL_AXIS.x].get(item)) {\n      this._cancelItemScroll(item, AUTO_SCROLL_AXIS.x);\n      this._requests[AUTO_SCROLL_AXIS.x].delete(item);\n    }\n\n    if (this._requests[AUTO_SCROLL_AXIS.y].get(item)) {\n      this._cancelItemScroll(item, AUTO_SCROLL_AXIS.y);\n      this._requests[AUTO_SCROLL_AXIS.y].delete(item);\n    }\n\n    this._itemData.delete(item);\n    this.items.splice(index, 1);\n\n    if (this._isTicking && !this.items.length) {\n      this._stopTicking();\n    }\n  }\n\n  isDestroyed() {\n    return this._isDestroyed;\n  }\n\n  isItemScrollingX(item: AutoScrollItem) {\n    return !!this._requests[AUTO_SCROLL_AXIS.x].get(item)?.isActive;\n  }\n\n  isItemScrollingY(item: AutoScrollItem) {\n    return !!this._requests[AUTO_SCROLL_AXIS.y].get(item)?.isActive;\n  }\n\n  isItemScrolling(item: AutoScrollItem) {\n    return this.isItemScrollingX(item) || this.isItemScrollingY(item);\n  }\n\n  updateSettings(options: AutoScrollOptions = {}) {\n    const { overlapCheckInterval = this.settings.overlapCheckInterval } = options;\n    this.settings.overlapCheckInterval = overlapCheckInterval;\n  }\n\n  destroy() {\n    if (this._isDestroyed) return;\n\n    const items = this.items.slice(0);\n    let i = 0;\n    for (; i < items.length; i++) {\n      this.removeItem(items[i]);\n    }\n\n    this._actions.length = 0;\n    this._requestPool.reset();\n    this._actionPool.reset();\n    this._emitter.off();\n\n    this._isDestroyed = true;\n  }\n}\n","export class Pool<T> {\n  protected _data: T[];\n  protected _createObject: () => T;\n  protected _onPut: ((object: T) => void) | undefined;\n\n  constructor(createObject: () => T, onPut?: (object: T) => void) {\n    this._data = [];\n    this._createObject = createObject;\n    this._onPut = onPut;\n  }\n\n  pick() {\n    return this._data.length ? (this._data.pop() as T) : this._createObject();\n  }\n\n  put(object: T) {\n    if (this._data.indexOf(object) === -1) {\n      this._onPut && this._onPut(object);\n      this._data.push(object);\n    }\n  }\n\n  reset() {\n    this._data.length = 0;\n  }\n}\n","import { getIntersectionArea } from './get-intersection-area.js';\n\nimport { RectExtended } from '../types.js';\n\n/**\n * Calculate how many percent the intersection area of two rectangles is from\n * the maximum potential intersection area between the rectangles.\n */\nexport function getIntersectionScore(a: RectExtended, b: RectExtended) {\n  const area = getIntersectionArea(a, b);\n  if (!area) return 0;\n  const maxArea = Math.min(a.width, b.width) * Math.min(a.height, b.height);\n  return (area / maxArea) * 100;\n}\n","import { getIntersection } from 'mezr';\n\nimport { RectExtended } from '../types.js';\n\n/**\n * Calculate intersection area between two rectangle.\n */\nexport function getIntersectionArea(a: RectExtended, b: RectExtended) {\n  const intersection = getIntersection(a, b);\n  return intersection ? intersection.width * intersection.height : 0;\n}\n","import { isWindow } from './is-window.js';\n\nexport function getScrollElement(element: Element | Window) {\n  if (isWindow(element) || element === document.documentElement || element === document.body) {\n    return window;\n  } else {\n    return element;\n  }\n}\n","/**\n * Check if the current value is a window.\n */\nexport function isWindow(value: any): value is Window {\n  return value instanceof Window;\n}\n","import { isWindow } from './is-window.js';\n\nexport function getScrollLeft(element: Element | Window) {\n  return isWindow(element) ? element.pageXOffset : element.scrollLeft;\n}\n","import { isWindow } from './is-window.js';\n\nexport function getScrollLeftMax(element: Element | Window) {\n  if (isWindow(element)) element = document.documentElement;\n  return element.scrollWidth - element.clientWidth;\n}\n","import { isWindow } from './is-window.js';\n\nexport function getScrollTop(element: Element | Window) {\n  return isWindow(element) ? element.pageYOffset : element.scrollTop;\n}\n","import { isWindow } from './is-window.js';\n\nexport function getScrollTopMax(element: Element | Window) {\n  if (isWindow(element)) element = document.documentElement;\n  return element.scrollHeight - element.clientHeight;\n}\n","import { RectExtended } from '../types.js';\n\n/**\n * Check if two rectangles intersect.\n */\nexport function isIntersecting(a: RectExtended, b: RectExtended) {\n  return !(a.right <= b.left || b.right <= a.left || a.bottom <= b.top || b.bottom <= a.top);\n}\n","import { AutoScroll } from '../auto-scroll/auto-scroll.js';\n\nexport const autoScroll = new AutoScroll();\n","import { Sensor } from '../sensors/sensor.js';\n\nimport { Draggable } from '../draggable/draggable.js';\n\nimport { PointerSensor, PointerSensorEvents } from '../sensors/pointer-sensor.js';\n\nimport { getScrollableAncestors } from './get-scrollable-ancestors.js';\n\nimport { isScrollable } from './is-scrollable.js';\n\nfunction getScrollables(element: Element) {\n  const scrollables: (Element | Window)[] = [];\n\n  if (isScrollable(element)) {\n    scrollables.push(element);\n  }\n\n  getScrollableAncestors(element, scrollables);\n\n  return scrollables;\n}\n\nexport function createPointerSensorStartPredicate<\n  S extends (Sensor | PointerSensor)[] = (Sensor | PointerSensor)[],\n  D extends Draggable<S> = Draggable<S>,\n>(\n  options: {\n    timeout?: number;\n    fallback?: D['settings']['startPredicate'];\n  } = {},\n) {\n  let dragAllowed: boolean | undefined = undefined;\n\n  let startTimeStamp: number = 0;\n\n  let targetElement: Element | null = null;\n\n  let timer: number | undefined = undefined;\n\n  const { timeout = 250, fallback = () => true } = options;\n\n  const onContextMenu = (e: Event) => e.preventDefault();\n\n  const onTouchMove = (e: TouchEvent) => {\n    if (!startTimeStamp) return;\n\n    if (dragAllowed) {\n      e.cancelable && e.preventDefault();\n      return;\n    }\n\n    if (dragAllowed === undefined) {\n      if (e.cancelable && e.timeStamp - startTimeStamp > timeout) {\n        dragAllowed = true;\n        e.preventDefault();\n      } else {\n        dragAllowed = false;\n      }\n    }\n  };\n\n  const pointerSensorStartPredicate: D['settings']['startPredicate'] = (data) => {\n    if (!(data.sensor instanceof PointerSensor)) {\n      return fallback(data);\n    }\n\n    const { draggable, sensor, event } = data;\n    const e = event as PointerSensorEvents['start'] | PointerSensorEvents['move'];\n\n    if (e.pointerType === 'touch') {\n      // On first event (touchstart/pointerdown) we need to store the drag start\n      // data and bind listeners for touchmove and contextmenu.\n      if (\n        e.type === 'start' &&\n        (e.srcEvent.type === 'pointerdown' || e.srcEvent.type === 'touchstart')\n      ) {\n        // Prevent potentially scrollable nodes from scrolling to make sure\n        // native scrolling does not interfere with dragging.\n        targetElement = e.target as Element | null;\n        const scrollables = targetElement ? getScrollables(targetElement) : [];\n        scrollables.forEach((scrollable) => {\n          scrollable.addEventListener('touchmove', onTouchMove as EventListener, {\n            passive: false,\n            capture: true,\n          });\n        });\n\n        const dragEndListener = () => {\n          if (!startTimeStamp) return;\n\n          // Unbind listeners.\n          draggable.off('end', dragEndListener);\n          draggable.sensors.forEach((sensor) => {\n            if (sensor instanceof PointerSensor) {\n              sensor.off('end', dragEndListener);\n            }\n          });\n          targetElement?.removeEventListener('contextmenu', onContextMenu);\n          scrollables.forEach((scrollable) => {\n            scrollable.removeEventListener('touchmove', onTouchMove as EventListener, {\n              capture: true,\n            });\n          });\n\n          // Reset state.\n          startTimeStamp = 0;\n          dragAllowed = undefined;\n          targetElement = null;\n          timer = void window.clearTimeout(timer);\n        };\n\n        // Set start state.\n        dragAllowed = undefined;\n        startTimeStamp = e.srcEvent.timeStamp;\n\n        // Prevent context menu popping up.\n        targetElement?.addEventListener('contextmenu', onContextMenu);\n\n        // Reset data on drag end.\n        draggable.on('end', dragEndListener);\n        draggable.sensors.forEach((sensor) => {\n          if (sensor instanceof PointerSensor) {\n            sensor.off('end', dragEndListener);\n          }\n        });\n\n        // If we have timeout defined, let's set a timer that force starts\n        // the drag process after the timeout.\n        // TODO: This will start drag sometimes when it's not actually possible\n        // to prevent the native scrolling on touch devices. We'd need a way\n        // to check if the first touchstart/touchmove is cancelable. Needs\n        // testing on real devices. The funky thing is that we seem to need to\n        // get one touchmove event to check if we can prevent native scrolling\n        // but that is kind of too late already.. let's see if we can detect\n        // that earlier somehow.\n        if (timeout > 0) {\n          timer = window.setTimeout(() => {\n            draggable.resolveStartPredicate(sensor);\n            dragAllowed = true;\n            timer = undefined;\n          }, timeout);\n        }\n      }\n\n      return dragAllowed;\n    }\n\n    // On mouse/pen let's allow starting drag immediately if mouse's left button\n    // is pressed down.\n    if (e.type === 'start' && !(e.srcEvent as MouseEvent | PointerEvent).button) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  return pointerSensorStartPredicate;\n}\n","import { isScrollable } from './is-scrollable.js';\nimport { isDocument } from './is-document.js';\n\n/**\n * Compute the element's scrollable ancestor elements.\n */\nexport function getScrollableAncestors(\n  element: Element | Document | null,\n  result: (Element | Window)[] = [],\n) {\n  let parent = element?.parentNode;\n\n  while (parent && !isDocument(parent)) {\n    if (parent instanceof Element) {\n      if (isScrollable(parent)) result.push(parent);\n      parent = parent.parentNode;\n    } else if (parent instanceof ShadowRoot) {\n      parent = parent.host;\n    } else {\n      parent = parent.parentNode;\n    }\n  }\n\n  // Always push window to the results (as last scrollable element).\n  result.push(window);\n\n  return result;\n}\n","import { getStyle } from './get-style.js';\n\nconst SCROLLABLE_OVERFLOWS = new Set(['auto', 'scroll', 'overlay']);\n\n/**\n * Check if element is scrollable.\n */\nexport function isScrollable(element: Element) {\n  const style = getStyle(element);\n  return !!(SCROLLABLE_OVERFLOWS.has(style.overflowY) || SCROLLABLE_OVERFLOWS.has(style.overflowX));\n}\n","/**\n * Check if the current value is a document.\n */\nexport function isDocument(value: any): value is Document {\n  return value instanceof Document;\n}\n","import { SensorStartEvent, SensorMoveEvent } from '../sensors/sensor.js';\n\nimport { DraggableDragItem } from 'draggable/draggable-drag-item.js';\n\nfunction round(value: number, multipleOf: number) {\n  return Math.round(value / multipleOf) * multipleOf;\n}\n\nfunction getAxisChange(gridSize: number, snapPosition: number, sensorPosition: number) {\n  let change = sensorPosition - snapPosition;\n  let changeAbs = Math.abs(change);\n  if (changeAbs >= gridSize) {\n    const overflow = changeAbs % gridSize;\n    return round(change > 0 ? change - overflow : change + overflow, gridSize);\n  }\n  return 0;\n}\n\nexport function createSnapModifier(gridWidth: number, gridHeight: number) {\n  return function snapModifier({\n    startEvent,\n    event,\n    item,\n  }: {\n    startEvent: SensorStartEvent | SensorMoveEvent;\n    event: SensorMoveEvent;\n    item: DraggableDragItem;\n  }) {\n    let { __snapX__ = startEvent.x, __snapY__ = startEvent.y } = item.data;\n\n    const changeX = getAxisChange(gridWidth, __snapX__, event.x);\n    const changeY = getAxisChange(gridHeight, __snapY__, event.y);\n\n    if (changeX) {\n      item.data.__snapX__ = __snapX__ + changeX;\n    }\n    if (changeY) {\n      item.data.__snapY__ = __snapY__ + changeY;\n    }\n\n    return {\n      x: changeX,\n      y: changeY,\n    };\n  };\n}\n"],"names":[],"version":3,"file":"index.659e82a6.js.map"}