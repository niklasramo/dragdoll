{"mappings":"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","sources":["<anon>","examples/001-draggable-basic/index.ts","src/index.ts","src/sensors/sensor.ts","src/sensors/base-sensor.ts","node_modules/eventti/dist/eventti.js","src/sensors/base-motion-sensor.ts","src/singletons/ticker.ts","node_modules/tikki/dist/tikki.js","src/sensors/pointer-sensor.ts","src/utils/get-pointer-event-data.ts","src/utils/get-pointer-type.ts","src/utils/get-pointer-id.ts","src/utils/parse-listener-options.ts","src/constants.ts","src/utils/parse-source-events.ts","src/sensors/keyboard-sensor.ts","src/sensors/keyboard-motion-sensor.ts","src/draggable/draggable.ts","src/draggable/draggable-drag.ts","src/draggable/draggable-drag-item.ts","node_modules/mezr/dist/esm/index.js","node_modules/mezr/dist/esm/getContainingBlock.js","node_modules/mezr/dist/esm/utils/getStyle.js","node_modules/mezr/dist/esm/utils/isContainingBlockForFixedElement.js","node_modules/mezr/dist/esm/utils/constants.js","node_modules/mezr/dist/esm/utils/isBlockElement.js","node_modules/mezr/dist/esm/utils/isContainingBlockForAbsoluteElement.js","node_modules/mezr/dist/esm/utils/isDocumentElement.js","node_modules/mezr/dist/esm/getDistance.js","node_modules/mezr/dist/esm/utils/getDistanceBetweenRects.js","node_modules/mezr/dist/esm/utils/isIntersecting.js","node_modules/mezr/dist/esm/utils/getDistanceBetweenPoints.js","node_modules/mezr/dist/esm/utils/getNormalizedRect.js","node_modules/mezr/dist/esm/getRect.js","node_modules/mezr/dist/esm/getWidth.js","node_modules/mezr/dist/esm/utils/isWindow.js","node_modules/mezr/dist/esm/utils/isDocument.js","node_modules/mezr/dist/esm/utils/getWindowWidth.js","node_modules/mezr/dist/esm/utils/getPreciseScrollbarSize.js","node_modules/mezr/dist/esm/utils/getDocumentWidth.js","node_modules/mezr/dist/esm/utils/getElementWidth.js","node_modules/mezr/dist/esm/getHeight.js","node_modules/mezr/dist/esm/utils/getWindowHeight.js","node_modules/mezr/dist/esm/utils/getDocumentHeight.js","node_modules/mezr/dist/esm/utils/getElementHeight.js","node_modules/mezr/dist/esm/getOffset.js","node_modules/mezr/dist/esm/utils/isRectObject.js","node_modules/mezr/dist/esm/utils/getOffsetFromDocument.js","node_modules/mezr/dist/esm/getIntersection.js","node_modules/mezr/dist/esm/getOffsetContainer.js","node_modules/mezr/dist/esm/getOverflow.js","src/utils/get-style.ts","src/utils/get-offset-diff.ts","src/draggable/plugins/auto-scroll-plugin.ts","src/auto-scroll/auto-scroll.ts","src/pool.ts","src/utils/get-intersection-score.ts","src/utils/get-intersection-area.ts","src/utils/get-scroll-element.ts","src/utils/is-window.ts","src/utils/get-scroll-left.ts","src/utils/get-scroll-left-max.ts","src/utils/get-scroll-top.ts","src/utils/get-scroll-top-max.ts","src/utils/is-intersecting.ts","src/singletons/auto-scroll.ts","src/utils/create-pointer-sensor-start-predicate.ts","src/utils/get-scrollable-ancestors.ts","src/utils/is-scrollable.ts","src/utils/is-document.ts","src/utils/create-snap-modifier.ts"],"sourcesContent":["const $e792636b9b5c481d$export$61fde4a8bbe7f5d5 = {\n    start: \"start\",\n    move: \"move\",\n    cancel: \"cancel\",\n    end: \"end\",\n    destroy: \"destroy\"\n};\n\n\nfunction $882b296db6123935$var$getOrCreateEventData(e, t) {\n    let i = e.get(t);\n    return i || (i = new $882b296db6123935$var$EventData, e.set(t, i)), i;\n}\nclass $882b296db6123935$var$EventData {\n    constructor(){\n        this.idMap = new Map, this.fnMap = new Map, this.onceList = new Set, this.emitList = null;\n    }\n    add(e, t, i, s, n) {\n        if (!n && this.fnMap.has(e)) throw new Error(\"Emitter: tried to add an existing event listener to an event!\");\n        if (this.idMap.has(i)) switch(s){\n            case \"throw\":\n                throw new Error(\"Emitter: tried to add an existing event listener id to an event!\");\n            case \"ignore\":\n                return i;\n            default:\n                this.delId(i, \"update\" === s);\n        }\n        let r = this.fnMap.get(e);\n        return r || (r = new Set, this.fnMap.set(e, r)), r.add(i), this.idMap.set(i, e), t && this.onceList.add(i), this.emitList && this.emitList.push(e), i;\n    }\n    delId(e, t = !1) {\n        const i = this.idMap.get(e);\n        if (!i) return;\n        const s = this.fnMap.get(i);\n        t || this.idMap.delete(e), this.onceList.delete(e), s.delete(e), s.size || this.fnMap.delete(i), this.emitList = null;\n    }\n    delFn(e) {\n        const t = this.fnMap.get(e);\n        t && (t.forEach((e)=>{\n            this.onceList.delete(e), this.idMap.delete(e);\n        }), this.fnMap.delete(e), this.emitList = null);\n    }\n}\nclass $882b296db6123935$export$4293555f241ae35a {\n    constructor(e = {}){\n        const { idDedupeMode: t = \"replace\", allowDuplicateListeners: i = !0 } = e;\n        this.idDedupeMode = t, this.allowDuplicateListeners = i, this._events = new Map;\n    }\n    _getListeners(e) {\n        const t = this._events.get(e);\n        if (!t) return null;\n        const { idMap: i, onceList: s } = t;\n        if (!i.size) return null;\n        const n = t.emitList || [\n            ...i.values()\n        ];\n        if (s.size) {\n            if (s.size === i.size) this._events.delete(e);\n            else for (const e of s)t.delId(e);\n        } else t.emitList = n;\n        return n;\n    }\n    on(e, t, i = Symbol()) {\n        return $882b296db6123935$var$getOrCreateEventData(this._events, e).add(t, !1, i, this.idDedupeMode, this.allowDuplicateListeners);\n    }\n    once(e, t, i = Symbol()) {\n        return $882b296db6123935$var$getOrCreateEventData(this._events, e).add(t, !0, i, this.idDedupeMode, this.allowDuplicateListeners);\n    }\n    off(e, t) {\n        if (void 0 === e) return void this._events.clear();\n        if (void 0 === t) return void this._events.delete(e);\n        const i = this._events.get(e);\n        i && (\"function\" == typeof t ? i.delFn(t) : i.delId(t), i.idMap.size || this._events.delete(e));\n    }\n    emit(e, ...t) {\n        const i = this._getListeners(e);\n        if (!i) return;\n        let s = 0, n = i.length;\n        for(; s < n; s++)i[s](...t);\n    }\n    listenerCount(e) {\n        var t;\n        if (void 0 === e) {\n            let e = 0;\n            return this._events.forEach((t, i)=>{\n                e += this.listenerCount(i);\n            }), e;\n        }\n        return (null === (t = this._events.get(e)) || void 0 === t ? void 0 : t.idMap.size) || 0;\n    }\n}\n\n\n\nclass $597a58f01afe9fb7$export$2176a6ff266bf511 {\n    constructor(){\n        this.drag = null;\n        this.isDestroyed = false;\n        this._emitter = new (0, $882b296db6123935$export$4293555f241ae35a)();\n    }\n    _createDragData(data) {\n        return {\n            x: data.x,\n            y: data.y\n        };\n    }\n    _updateDragData(data) {\n        if (!this.drag) return;\n        this.drag.x = data.x;\n        this.drag.y = data.y;\n    }\n    _resetDragData() {\n        this.drag = null;\n    }\n    _start(data) {\n        if (this.isDestroyed || this.drag) return;\n        this.drag = this._createDragData(data);\n        this._emitter.emit((0, $e792636b9b5c481d$export$61fde4a8bbe7f5d5).start, data);\n    }\n    _move(data) {\n        if (!this.drag) return;\n        this._updateDragData(data);\n        this._emitter.emit((0, $e792636b9b5c481d$export$61fde4a8bbe7f5d5).move, data);\n    }\n    _end(data) {\n        if (!this.drag) return;\n        this._updateDragData(data);\n        this._emitter.emit((0, $e792636b9b5c481d$export$61fde4a8bbe7f5d5).end, data);\n        this._resetDragData();\n    }\n    _cancel(data) {\n        if (!this.drag) return;\n        this._updateDragData(data);\n        this._emitter.emit((0, $e792636b9b5c481d$export$61fde4a8bbe7f5d5).cancel, data);\n        this._resetDragData();\n    }\n    on(eventName, listener, listenerId) {\n        return this._emitter.on(eventName, listener, listenerId);\n    }\n    off(eventName, listener) {\n        this._emitter.off(eventName, listener);\n    }\n    cancel() {\n        if (!this.drag) return;\n        this._emitter.emit((0, $e792636b9b5c481d$export$61fde4a8bbe7f5d5).cancel, {\n            type: (0, $e792636b9b5c481d$export$61fde4a8bbe7f5d5).cancel,\n            x: this.drag.x,\n            y: this.drag.y\n        });\n        this._resetDragData();\n    }\n    destroy() {\n        if (this.isDestroyed) return;\n        this.isDestroyed = true;\n        this.cancel();\n        this._emitter.emit((0, $e792636b9b5c481d$export$61fde4a8bbe7f5d5).destroy, {\n            type: (0, $e792636b9b5c481d$export$61fde4a8bbe7f5d5).destroy\n        });\n        this._emitter.off();\n    }\n}\n\n\n\n\nfunction $df4a713e26511813$export$789135d3cf084551(e = 60) {\n    if (\"function\" == typeof requestAnimationFrame && \"function\" == typeof cancelAnimationFrame) return (e)=>{\n        const t = requestAnimationFrame(e);\n        return ()=>cancelAnimationFrame(t);\n    };\n    {\n        const t = 1e3 / e, i = \"undefined\" == typeof performance ? ()=>Date.now() : ()=>performance.now();\n        return (e)=>{\n            const r = setTimeout(()=>e(i()), t);\n            return ()=>clearTimeout(r);\n        };\n    }\n}\nvar $df4a713e26511813$export$ef9b1dc363f184d9;\n!function(e) {\n    e[e.PAUSED = 1] = \"PAUSED\", e[e.ON_DEMAND = 2] = \"ON_DEMAND\", e[e.CONTINUOUS = 3] = \"CONTINUOUS\";\n}($df4a713e26511813$export$ef9b1dc363f184d9 || ($df4a713e26511813$export$ef9b1dc363f184d9 = {}));\nclass $df4a713e26511813$export$39c54bcc89dcee11 {\n    constructor(e = {}){\n        const { phases: t = [], autoTick: i = $df4a713e26511813$export$ef9b1dc363f184d9.ON_DEMAND, allowDuplicateListeners: r = !0, idDedupeMode: s = \"replace\", requestFrame: n = $df4a713e26511813$export$789135d3cf084551() } = e;\n        this.phases = t, this._autoTick = i, this._requestFrame = n, this._cancelFrame = null, this._queue = [], this._emitter = new (0, $882b296db6123935$export$4293555f241ae35a)({\n            allowDuplicateListeners: r,\n            idDedupeMode: s\n        }), this.tick = this.tick.bind(this);\n    }\n    get requestFrame() {\n        return this._requestFrame;\n    }\n    set requestFrame(e) {\n        this._requestFrame = e, this._kickstart();\n    }\n    get autoTick() {\n        return this._autoTick;\n    }\n    set autoTick(e) {\n        this._autoTick = e, this._kickstart();\n    }\n    get allowDuplicateListeners() {\n        return this._emitter.allowDuplicateListeners;\n    }\n    set allowDuplicateListeners(e) {\n        this._emitter.allowDuplicateListeners = e;\n    }\n    get idDedupeMode() {\n        return this._emitter.idDedupeMode;\n    }\n    set idDedupeMode(e) {\n        this._emitter.idDedupeMode = e;\n    }\n    tick(...e) {\n        this._cancelFrame = null;\n        const { _queue: t } = this;\n        if (t.length) throw new Error(\"Ticker: Can't tick before the previous tick has finished!\");\n        this._request();\n        const { phases: i, _emitter: r } = this;\n        let s, n, a, c, u, o;\n        for(s = 0, a = i.length; s < a; s++)o = r._getListeners(i[s]), o && t.push(o);\n        for(s = 0, a = t.length; s < a; s++)for(u = t[s], n = 0, c = u.length; n < c; n++)u[n](...e);\n        t.length = 0, this._autoTick !== $df4a713e26511813$export$ef9b1dc363f184d9.ON_DEMAND || r.listenerCount() || this._cancel();\n    }\n    on(e, t, i) {\n        const r = this._emitter.on(e, t, i);\n        return this._request(), r;\n    }\n    once(e, t, i) {\n        const r = this._emitter.once(e, t, i);\n        return this._request(), r;\n    }\n    off(e, t) {\n        return this._emitter.off(e, t);\n    }\n    listenerCount(e) {\n        return this._emitter.listenerCount(e);\n    }\n    _request() {\n        this._requestFrame && !this._cancelFrame && this._autoTick >= $df4a713e26511813$export$ef9b1dc363f184d9.ON_DEMAND && (this._cancelFrame = this._requestFrame(this.tick));\n    }\n    _cancel() {\n        this._cancelFrame && (this._cancelFrame(), this._cancelFrame = null);\n    }\n    _kickstart() {\n        this._autoTick === $df4a713e26511813$export$ef9b1dc363f184d9.ON_DEMAND ? this._emitter.listenerCount() && this._request() : this._autoTick === $df4a713e26511813$export$ef9b1dc363f184d9.CONTINUOUS ? this._request() : this._cancel();\n    }\n}\nfunction $df4a713e26511813$export$4d497fac909c98f0(e) {\n    return (t)=>{\n        const i = e.requestAnimationFrame(t);\n        return ()=>e.cancelAnimationFrame(i);\n    };\n}\n\n\nlet $c1fd6b62e08b3d47$export$9138efc7ba4fca22 = Symbol();\nlet $c1fd6b62e08b3d47$export$5fd1e257088db342 = Symbol();\nlet $c1fd6b62e08b3d47$export$e94d57566be028aa = new (0, $df4a713e26511813$export$39c54bcc89dcee11)({\n    phases: [\n        $c1fd6b62e08b3d47$export$9138efc7ba4fca22,\n        $c1fd6b62e08b3d47$export$5fd1e257088db342\n    ]\n});\nfunction $c1fd6b62e08b3d47$export$9bc58717d06262f5(newTicker, readPhase, writePhase) {\n    $c1fd6b62e08b3d47$export$9138efc7ba4fca22 = readPhase;\n    $c1fd6b62e08b3d47$export$5fd1e257088db342 = writePhase;\n    $c1fd6b62e08b3d47$export$e94d57566be028aa = newTicker;\n}\n\n\nclass $75c93c044629d154$export$2f0ad9ba2f0800d extends (0, $597a58f01afe9fb7$export$2176a6ff266bf511) {\n    constructor(){\n        super();\n        this.drag = null;\n        this._direction = {\n            x: 0,\n            y: 0\n        };\n        this._speed = 0;\n        this._tick = this._tick.bind(this);\n    }\n    _createDragData(data) {\n        return {\n            ...super._createDragData(data),\n            time: 0,\n            deltaTime: 0\n        };\n    }\n    _start(data) {\n        if (this.isDestroyed || this.drag) return;\n        super._start(data);\n        (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).on((0, $c1fd6b62e08b3d47$export$9138efc7ba4fca22), this._tick);\n    }\n    _end(data) {\n        if (!this.drag) return;\n        (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).off((0, $c1fd6b62e08b3d47$export$9138efc7ba4fca22), this._tick);\n        super._end(data);\n    }\n    _cancel(data) {\n        if (!this.drag) return;\n        (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).off((0, $c1fd6b62e08b3d47$export$9138efc7ba4fca22), this._tick);\n        super._cancel(data);\n    }\n    _tick(time) {\n        if (!this.drag) return;\n        if (time && this.drag.time) {\n            // Update tick time and delta time.\n            this.drag.deltaTime = time - this.drag.time;\n            this.drag.time = time;\n            // Emit tick event.\n            const tickEvent = {\n                type: \"tick\",\n                time: this.drag.time,\n                deltaTime: this.drag.deltaTime\n            };\n            this._emitter.emit(\"tick\", tickEvent);\n            // Make sure the sensor is still active.\n            if (!this.drag) return;\n            // Compute the movement offset (delta) by applying time factor to\n            // the speed. The speed is assumed to be provided as pixels-per-second.\n            const speedFactor = this._speed * (this.drag.deltaTime / 1000);\n            const deltaX = this._direction.x * speedFactor;\n            const deltaY = this._direction.y * speedFactor;\n            // Trigger move event if the clientX/Y needs change. Note that calling\n            // this._move() automatically updates clientX/Y values also so we don't\n            // need to do it here.\n            if (deltaX || deltaY) this._move({\n                type: \"move\",\n                x: this.drag.x + deltaX,\n                y: this.drag.y + deltaY\n            });\n        } else {\n            this.drag.time = time;\n            this.drag.deltaTime = 0;\n        }\n    }\n}\n\n\n\n\nfunction $63344f554ee4dd3f$export$6e8069a9617a39e2(e, id) {\n    // If we have a pointer event return the whole event if there's a match, and\n    // null otherwise.\n    if (\"pointerId\" in e) return e.pointerId === id ? e : null;\n    // For touch events let's check if there's a changed touch object that matches\n    // the pointerId in which case return the touch object.\n    if (\"changedTouches\" in e) {\n        let i = 0;\n        for(; i < e.changedTouches.length; i++){\n            if (e.changedTouches[i].identifier === id) return e.changedTouches[i];\n        }\n        return null;\n    }\n    // For mouse/other events let's assume there's only one pointer and just\n    // return the event.\n    return e;\n}\n\n\nfunction $19b680555f9c20ee$export$887a228355cf7d95(e) {\n    return \"pointerType\" in e ? e.pointerType : \"touches\" in e ? \"touch\" : \"mouse\";\n}\n\n\nfunction $ae2af31ed1bf7a8e$export$a845ff6c553b3014(e) {\n    // If we have pointer id available let's use it.\n    if (\"pointerId\" in e) return e.pointerId;\n    // For touch events let's get the first changed touch's identifier.\n    if (\"changedTouches\" in e) return e.changedTouches[0] ? e.changedTouches[0].identifier : null;\n    // For mouse/other events let's provide a static id. And let's make it a\n    // negative number so it has it has not chance of clashing with touch/pointer\n    // ids.\n    return -1;\n}\n\n\nconst $9ecda7333d28e490$export$e44ffb50cc242ec5 = typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\nconst $9ecda7333d28e490$export$ffcf6b6ce241bd05 = (()=>{\n    let isPassiveEventsSupported = false;\n    try {\n        const passiveOpts = Object.defineProperty({}, \"passive\", {\n            get: function() {\n                isPassiveEventsSupported = true;\n            }\n        });\n        // @ts-ignore\n        window.addEventListener(\"testPassive\", null, passiveOpts);\n        // @ts-ignore\n        window.removeEventListener(\"testPassive\", null, passiveOpts);\n    } catch (e) {}\n    return isPassiveEventsSupported;\n})();\nconst $9ecda7333d28e490$export$4af9b1d833a619de = $9ecda7333d28e490$export$e44ffb50cc242ec5 && \"ontouchstart\" in window;\nconst $9ecda7333d28e490$export$7728c852ca75bb6d = $9ecda7333d28e490$export$e44ffb50cc242ec5 && !!window.PointerEvent;\nconst $9ecda7333d28e490$export$af54264dae9065e6 = !!($9ecda7333d28e490$export$e44ffb50cc242ec5 && navigator.vendor && navigator.vendor.indexOf(\"Apple\") > -1 && navigator.userAgent && navigator.userAgent.indexOf(\"CriOS\") == -1 && navigator.userAgent.indexOf(\"FxiOS\") == -1);\n\n\nfunction $578e243b57046d15$export$4d6c83612522bb80(options = {}) {\n    const { capture: capture = true, passive: passive = true } = options;\n    if (0, $9ecda7333d28e490$export$ffcf6b6ce241bd05) return {\n        capture: capture,\n        passive: passive\n    };\n    else return {\n        capture: capture\n    };\n}\n\n\n\nfunction $8909cb6563132761$export$6475a94861c59472(sourceEvents) {\n    return sourceEvents === \"auto\" || sourceEvents === undefined ? (0, $9ecda7333d28e490$export$7728c852ca75bb6d) ? \"pointer\" : (0, $9ecda7333d28e490$export$4af9b1d833a619de) ? \"touch\" : \"mouse\" : sourceEvents;\n}\n\n\nconst $4998740c882fb340$var$POINTER_EVENTS = {\n    start: \"pointerdown\",\n    move: \"pointermove\",\n    cancel: \"pointercancel\",\n    end: \"pointerup\"\n};\nconst $4998740c882fb340$var$TOUCH_EVENTS = {\n    start: \"touchstart\",\n    move: \"touchmove\",\n    cancel: \"touchcancel\",\n    end: \"touchend\"\n};\nconst $4998740c882fb340$var$MOUSE_EVENTS = {\n    start: \"mousedown\",\n    move: \"mousemove\",\n    cancel: \"\",\n    end: \"mouseup\"\n};\nconst $4998740c882fb340$var$SOURCE_EVENTS = {\n    pointer: $4998740c882fb340$var$POINTER_EVENTS,\n    touch: $4998740c882fb340$var$TOUCH_EVENTS,\n    mouse: $4998740c882fb340$var$MOUSE_EVENTS\n};\nclass $4998740c882fb340$export$b26af955418d6638 {\n    constructor(element, options = {}){\n        const { listenerOptions: listenerOptions = {}, sourceEvents: sourceEvents = \"auto\", startPredicate: startPredicate = (e)=>\"button\" in e && e.button > 0 ? false : true } = options;\n        this.element = element;\n        this.drag = null;\n        this.isDestroyed = false;\n        this._areWindowListenersBound = false;\n        this._startPredicate = startPredicate;\n        this._listenerOptions = (0, $578e243b57046d15$export$4d6c83612522bb80)(listenerOptions);\n        this._sourceEvents = (0, $8909cb6563132761$export$6475a94861c59472)(sourceEvents);\n        this._emitter = new (0, $882b296db6123935$export$4293555f241ae35a)();\n        this._onStart = this._onStart.bind(this);\n        this._onMove = this._onMove.bind(this);\n        this._onCancel = this._onCancel.bind(this);\n        this._onEnd = this._onEnd.bind(this);\n        // Listen to start event.\n        element.addEventListener($4998740c882fb340$var$SOURCE_EVENTS[this._sourceEvents].start, this._onStart, this._listenerOptions);\n    }\n    /**\n   * Check if the provided event contains the tracked pointer id or in the case\n   * of touch event if the first changed touch is the tracked touch object and\n   * return the event or touch object. Otherwise return null.\n   */ _getTrackedPointerEventData(e) {\n        return this.drag ? (0, $63344f554ee4dd3f$export$6e8069a9617a39e2)(e, this.drag.pointerId) : null;\n    }\n    /**\n   * Listener for start event.\n   */ _onStart(e) {\n        if (this.isDestroyed || this.drag) return;\n        // Make sure start predicate is fulfilled.\n        if (!this._startPredicate(e)) return;\n        // Try to get pointer id.\n        const pointerId = (0, $ae2af31ed1bf7a8e$export$a845ff6c553b3014)(e);\n        if (pointerId === null) return;\n        // Try to get pointer.\n        const pointerEventData = (0, $63344f554ee4dd3f$export$6e8069a9617a39e2)(e, pointerId);\n        if (pointerEventData === null) return;\n        // Create drag data.\n        const dragData = {\n            pointerId: pointerId,\n            pointerType: (0, $19b680555f9c20ee$export$887a228355cf7d95)(e),\n            x: pointerEventData.clientX,\n            y: pointerEventData.clientY\n        };\n        // Set drag data.\n        this.drag = dragData;\n        // Emit start event.\n        const eventData = {\n            ...dragData,\n            type: (0, $e792636b9b5c481d$export$61fde4a8bbe7f5d5).start,\n            srcEvent: e,\n            target: pointerEventData.target\n        };\n        this._emitter.emit(eventData.type, eventData);\n        // If the drag procedure was not reset within the start procedure let's\n        // activate the instance (start listening to move/cancel/end events).\n        if (this.drag) this._bindWindowListeners();\n    }\n    /**\n   * Listener for move event.\n   */ _onMove(e) {\n        if (!this.drag) return;\n        const pointerEventData = this._getTrackedPointerEventData(e);\n        if (!pointerEventData) return;\n        this.drag.x = pointerEventData.clientX;\n        this.drag.y = pointerEventData.clientY;\n        const eventData = {\n            type: (0, $e792636b9b5c481d$export$61fde4a8bbe7f5d5).move,\n            srcEvent: e,\n            target: pointerEventData.target,\n            ...this.drag\n        };\n        this._emitter.emit(eventData.type, eventData);\n    }\n    /**\n   * Listener for cancel event.\n   */ _onCancel(e) {\n        if (!this.drag) return;\n        const pointerEventData = this._getTrackedPointerEventData(e);\n        if (!pointerEventData) return;\n        this.drag.x = pointerEventData.clientX;\n        this.drag.y = pointerEventData.clientY;\n        const eventData = {\n            type: (0, $e792636b9b5c481d$export$61fde4a8bbe7f5d5).cancel,\n            srcEvent: e,\n            target: pointerEventData.target,\n            ...this.drag\n        };\n        this._emitter.emit(eventData.type, eventData);\n        this._resetDrag();\n    }\n    /**\n   * Listener for end event.\n   */ _onEnd(e) {\n        if (!this.drag) return;\n        const pointerEventData = this._getTrackedPointerEventData(e);\n        if (!pointerEventData) return;\n        this.drag.x = pointerEventData.clientX;\n        this.drag.y = pointerEventData.clientY;\n        const eventData = {\n            type: (0, $e792636b9b5c481d$export$61fde4a8bbe7f5d5).end,\n            srcEvent: e,\n            target: pointerEventData.target,\n            ...this.drag\n        };\n        this._emitter.emit(eventData.type, eventData);\n        this._resetDrag();\n    }\n    /**\n   * Bind window event listeners for move/end/cancel.\n   */ _bindWindowListeners() {\n        if (this._areWindowListenersBound) return;\n        const { move: move, end: end, cancel: cancel } = $4998740c882fb340$var$SOURCE_EVENTS[this._sourceEvents];\n        window.addEventListener(move, this._onMove, this._listenerOptions);\n        window.addEventListener(end, this._onEnd, this._listenerOptions);\n        if (cancel) window.addEventListener(cancel, this._onCancel, this._listenerOptions);\n        this._areWindowListenersBound = true;\n    }\n    /**\n   * Unbind window event listeners for move/end/cancel.\n   */ _unbindWindowListeners() {\n        if (this._areWindowListenersBound) {\n            const { move: move, end: end, cancel: cancel } = $4998740c882fb340$var$SOURCE_EVENTS[this._sourceEvents];\n            window.removeEventListener(move, this._onMove, this._listenerOptions);\n            window.removeEventListener(end, this._onEnd, this._listenerOptions);\n            if (cancel) window.removeEventListener(cancel, this._onCancel, this._listenerOptions);\n            this._areWindowListenersBound = false;\n        }\n    }\n    /**\n   * Reset drag data.\n   */ _resetDrag() {\n        this.drag = null;\n        this._unbindWindowListeners();\n    }\n    /**\n   * Forcefully cancel the drag process.\n   */ cancel() {\n        if (!this.drag) return;\n        const eventData = {\n            type: (0, $e792636b9b5c481d$export$61fde4a8bbe7f5d5).cancel,\n            srcEvent: null,\n            target: null,\n            ...this.drag\n        };\n        this._emitter.emit(eventData.type, eventData);\n        this._resetDrag();\n    }\n    /**\n   * Update the instance's settings.\n   */ updateSettings(options) {\n        if (this.isDestroyed) return;\n        const { listenerOptions: listenerOptions, sourceEvents: sourceEvents, startPredicate: startPredicate } = options;\n        const nextSourceEvents = (0, $8909cb6563132761$export$6475a94861c59472)(sourceEvents);\n        const nextListenerOptions = (0, $578e243b57046d15$export$4d6c83612522bb80)(listenerOptions);\n        // Update start predicate if needed.\n        if (startPredicate && this._startPredicate !== startPredicate) this._startPredicate = startPredicate;\n        // Update listener options and/or source events if needed.\n        if (listenerOptions && (this._listenerOptions.capture !== nextListenerOptions.capture || this._listenerOptions.passive === nextListenerOptions.passive) || sourceEvents && this._sourceEvents !== nextSourceEvents) {\n            // Unbind start listener.\n            this.element.removeEventListener($4998740c882fb340$var$SOURCE_EVENTS[this._sourceEvents].start, this._onStart, this._listenerOptions);\n            // Unbind window listeners.\n            this._unbindWindowListeners();\n            // Cancel current drag process.\n            this.cancel();\n            // Update options to instace.\n            if (sourceEvents) this._sourceEvents = nextSourceEvents;\n            if (listenerOptions && nextListenerOptions) this._listenerOptions = nextListenerOptions;\n            // Rebind start listener with new options.\n            this.element.addEventListener($4998740c882fb340$var$SOURCE_EVENTS[this._sourceEvents].start, this._onStart, this._listenerOptions);\n        }\n    }\n    /**\n   * Bind a drag event listener.\n   */ on(eventName, listener, listenerId) {\n        return this._emitter.on(eventName, listener, listenerId);\n    }\n    /**\n   * Unbind a drag event listener.\n   */ off(eventName, listener) {\n        this._emitter.off(eventName, listener);\n    }\n    /**\n   * Destroy the instance and unbind all drag event listeners.\n   */ destroy() {\n        if (this.isDestroyed) return;\n        // Mark as destroyed.\n        this.isDestroyed = true;\n        // Cancel any ongoing drag process.\n        this.cancel();\n        // Emit destroy event.\n        this._emitter.emit((0, $e792636b9b5c481d$export$61fde4a8bbe7f5d5).destroy, {\n            type: (0, $e792636b9b5c481d$export$61fde4a8bbe7f5d5).destroy\n        });\n        // Destroy emitter.\n        this._emitter.off();\n        // Unbind start event listeners.\n        this.element.removeEventListener($4998740c882fb340$var$SOURCE_EVENTS[this._sourceEvents].start, this._onStart, this._listenerOptions);\n    }\n}\n\n\n\nclass $eecb4a66666e90e7$export$44d67f2a438aeba9 extends (0, $597a58f01afe9fb7$export$2176a6ff266bf511) {\n    constructor(options = {}){\n        super();\n        const { moveDistance: moveDistance = 25, startPredicate: startPredicate = (e)=>{\n            if (e.key === \"Enter\" || e.key === \" \") {\n                if (document.activeElement && document.activeElement !== document.body) {\n                    const { left: left, top: top } = document.activeElement.getBoundingClientRect();\n                    return {\n                        x: left,\n                        y: top\n                    };\n                }\n            }\n            return null;\n        }, movePredicate: movePredicate = (e, sensor, moveDistance)=>{\n            if (!sensor.drag) return null;\n            switch(e.key){\n                case \"ArrowLeft\":\n                    return {\n                        x: sensor.drag.x - moveDistance.x,\n                        y: sensor.drag.y\n                    };\n                case \"ArrowRight\":\n                    return {\n                        x: sensor.drag.x + moveDistance.x,\n                        y: sensor.drag.y\n                    };\n                case \"ArrowUp\":\n                    return {\n                        x: sensor.drag.x,\n                        y: sensor.drag.y - moveDistance.y\n                    };\n                case \"ArrowDown\":\n                    return {\n                        x: sensor.drag.x,\n                        y: sensor.drag.y + moveDistance.y\n                    };\n                default:\n                    return null;\n            }\n        }, cancelPredicate: cancelPredicate = (e, sensor)=>{\n            if (sensor.drag && e.key === \"Escape\") return {\n                x: sensor.drag.x,\n                y: sensor.drag.y\n            };\n            return null;\n        }, endPredicate: endPredicate = (e, sensor)=>{\n            if (sensor.drag && (e.key === \"Enter\" || e.key === \" \")) return {\n                x: sensor.drag.x,\n                y: sensor.drag.y\n            };\n            return null;\n        } } = options;\n        this._moveDistance = typeof moveDistance === \"number\" ? {\n            x: moveDistance,\n            y: moveDistance\n        } : {\n            ...moveDistance\n        };\n        this._startPredicate = startPredicate;\n        this._movePredicate = movePredicate;\n        this._cancelPredicate = cancelPredicate;\n        this._endPredicate = endPredicate;\n        this.cancel = this.cancel.bind(this);\n        this._onKeyDown = this._onKeyDown.bind(this);\n        document.addEventListener(\"keydown\", this._onKeyDown);\n        window.addEventListener(\"blur\", this.cancel);\n        window.addEventListener(\"visibilitychange\", this.cancel);\n    }\n    _onKeyDown(e) {\n        // Handle start.\n        if (!this.drag) {\n            const startPosition = this._startPredicate(e, this, this._moveDistance);\n            if (startPosition) {\n                e.preventDefault();\n                this._start({\n                    type: \"start\",\n                    x: startPosition.x,\n                    y: startPosition.y,\n                    srcEvent: e\n                });\n            }\n            return;\n        }\n        // Handle cancel.\n        const cancelPosition = this._cancelPredicate(e, this, this._moveDistance);\n        if (cancelPosition) {\n            e.preventDefault();\n            this._cancel({\n                type: \"cancel\",\n                x: cancelPosition.x,\n                y: cancelPosition.y,\n                srcEvent: e\n            });\n            return;\n        }\n        // Handle end.\n        const endPosition = this._endPredicate(e, this, this._moveDistance);\n        if (endPosition) {\n            e.preventDefault();\n            this._end({\n                type: \"end\",\n                x: endPosition.x,\n                y: endPosition.y,\n                srcEvent: e\n            });\n            return;\n        }\n        // Handle move.\n        const movePosition = this._movePredicate(e, this, this._moveDistance);\n        if (movePosition) {\n            e.preventDefault();\n            this._move({\n                type: \"move\",\n                x: movePosition.x,\n                y: movePosition.y,\n                srcEvent: e\n            });\n            return;\n        }\n    }\n    updateSettings(options = {}) {\n        if (options.moveDistance !== undefined) {\n            if (typeof options.moveDistance === \"number\") {\n                this._moveDistance.x = options.moveDistance;\n                this._moveDistance.y = options.moveDistance;\n            } else {\n                this._moveDistance.x = options.moveDistance.x;\n                this._moveDistance.y = options.moveDistance.y;\n            }\n        }\n        if (options.startPredicate !== undefined) this._startPredicate = options.startPredicate;\n        if (options.movePredicate !== undefined) this._movePredicate = options.movePredicate;\n        if (options.cancelPredicate !== undefined) this._cancelPredicate = options.cancelPredicate;\n        if (options.endPredicate !== undefined) this._endPredicate = options.endPredicate;\n    }\n    destroy() {\n        if (this.isDestroyed) return;\n        super.destroy();\n        document.removeEventListener(\"keydown\", this._onKeyDown);\n        window.removeEventListener(\"blur\", this.cancel);\n        window.removeEventListener(\"visibilitychange\", this.cancel);\n    }\n}\n\n\n\nconst $5f12a12b1bebeb44$var$KEY_TYPES = [\n    \"start\",\n    \"cancel\",\n    \"end\",\n    \"moveLeft\",\n    \"moveRight\",\n    \"moveUp\",\n    \"moveDown\"\n];\nfunction $5f12a12b1bebeb44$var$getEarliestTimestamp(keys, timestamps) {\n    if (!keys.size || !timestamps.size) return Infinity;\n    let result = Infinity;\n    for (const key of keys){\n        const timestamp = timestamps.get(key);\n        if (timestamp !== undefined && timestamp < result) result = timestamp;\n    }\n    return result;\n}\nclass $5f12a12b1bebeb44$export$436f6efcc297171 extends (0, $75c93c044629d154$export$2f0ad9ba2f0800d) {\n    constructor(options = {}){\n        super();\n        const { startPredicate: startPredicate = ()=>{\n            if (document.activeElement) {\n                const { left: left, top: top } = document.activeElement.getBoundingClientRect();\n                return {\n                    x: left,\n                    y: top\n                };\n            }\n            return null;\n        }, computeSpeed: computeSpeed = ()=>500, startKeys: startKeys = [\n            \" \",\n            \"Enter\"\n        ], moveLeftKeys: moveLeftKeys = [\n            \"ArrowLeft\"\n        ], moveRightKeys: moveRightKeys = [\n            \"ArrowRight\"\n        ], moveUpKeys: moveUpKeys = [\n            \"ArrowUp\"\n        ], moveDownKeys: moveDownKeys = [\n            \"ArrowDown\"\n        ], cancelKeys: cancelKeys = [\n            \"Escape\"\n        ], endKeys: endKeys = [\n            \" \",\n            \"Enter\"\n        ] } = options;\n        this._computeSpeed = computeSpeed;\n        this._startPredicate = startPredicate;\n        this._startKeys = new Set(startKeys);\n        this._cancelKeys = new Set(cancelKeys);\n        this._endKeys = new Set(endKeys);\n        this._moveLeftKeys = new Set(moveLeftKeys);\n        this._moveRightKeys = new Set(moveRightKeys);\n        this._moveUpKeys = new Set(moveUpKeys);\n        this._moveDownKeys = new Set(moveDownKeys);\n        this._moveKeys = new Set([\n            ...moveLeftKeys,\n            ...moveRightKeys,\n            ...moveUpKeys,\n            ...moveDownKeys\n        ]);\n        this._moveKeyTimestamps = new Map();\n        this._onKeyDown = this._onKeyDown.bind(this);\n        this._onKeyUp = this._onKeyUp.bind(this);\n        this._onTick = this._onTick.bind(this);\n        this.on(\"tick\", this._onTick);\n        document.addEventListener(\"keydown\", this._onKeyDown);\n        document.addEventListener(\"keyup\", this._onKeyUp);\n        window.addEventListener(\"blur\", this.cancel);\n        window.addEventListener(\"visibilitychange\", this.cancel);\n    }\n    _end(data) {\n        if (!this.drag) return;\n        this._moveKeyTimestamps.clear();\n        this._direction.x = 0;\n        this._direction.y = 0;\n        super._end(data);\n    }\n    _cancel(data) {\n        if (!this.drag) return;\n        this._moveKeyTimestamps.clear();\n        this._direction.x = 0;\n        this._direction.y = 0;\n        super._cancel(data);\n    }\n    _updateDirection() {\n        const leftTime = $5f12a12b1bebeb44$var$getEarliestTimestamp(this._moveLeftKeys, this._moveKeyTimestamps);\n        const rightTime = $5f12a12b1bebeb44$var$getEarliestTimestamp(this._moveRightKeys, this._moveKeyTimestamps);\n        const upTime = $5f12a12b1bebeb44$var$getEarliestTimestamp(this._moveUpKeys, this._moveKeyTimestamps);\n        const downTime = $5f12a12b1bebeb44$var$getEarliestTimestamp(this._moveDownKeys, this._moveKeyTimestamps);\n        let x = leftTime === rightTime ? 0 : leftTime < rightTime ? -1 : 1;\n        let y = upTime === downTime ? 0 : upTime < downTime ? -1 : 1;\n        // If the direction is NE/NW/SE/SW we need to normalize the direction\n        // vector.\n        if (!(x === 0 || y === 0)) {\n            const normFactor = 1 / (Math.sqrt(x * x + y * y) || 1);\n            x *= normFactor;\n            y *= normFactor;\n        }\n        this._direction.x = x;\n        this._direction.y = y;\n    }\n    _onTick() {\n        this._speed = this._computeSpeed(this);\n    }\n    _onKeyUp(e) {\n        if (this._moveKeyTimestamps.get(e.key)) {\n            this._moveKeyTimestamps.delete(e.key);\n            this._updateDirection();\n        }\n    }\n    _onKeyDown(e) {\n        // Handle start.\n        if (!this.drag) {\n            if (this._startKeys.has(e.key)) {\n                const startPosition = this._startPredicate(e, this);\n                if (startPosition) {\n                    e.preventDefault();\n                    this._start({\n                        type: \"start\",\n                        x: startPosition.x,\n                        y: startPosition.y\n                    });\n                }\n            }\n            return;\n        }\n        // Handle cancel.\n        if (this._cancelKeys.has(e.key)) {\n            e.preventDefault();\n            this._cancel({\n                type: \"cancel\",\n                x: this.drag.x,\n                y: this.drag.y\n            });\n            return;\n        }\n        // Handle end.\n        if (this._endKeys.has(e.key)) {\n            e.preventDefault();\n            this._end({\n                type: \"end\",\n                x: this.drag.x,\n                y: this.drag.y\n            });\n            return;\n        }\n        // Handle move.\n        if (this._moveKeys.has(e.key)) {\n            e.preventDefault();\n            if (!this._moveKeyTimestamps.get(e.key)) {\n                this._moveKeyTimestamps.set(e.key, Date.now());\n                this._updateDirection();\n            }\n            return;\n        }\n    }\n    updateSettings(options = {}) {\n        let moveKeysMayNeedUpdate = false;\n        if (options.startPredicate !== undefined) this._startPredicate = options.startPredicate;\n        if (options.computeSpeed !== undefined) this._computeSpeed = options.computeSpeed;\n        $5f12a12b1bebeb44$var$KEY_TYPES.forEach((keyType, index)=>{\n            const name = `${keyType}Keys`;\n            const value = options[name];\n            if (value !== undefined) {\n                this[`_${name}`] = new Set(value);\n                if (index >= 3) moveKeysMayNeedUpdate = true;\n            }\n        });\n        if (moveKeysMayNeedUpdate) {\n            // Construct the next move keys array.\n            const nextMoveKeys = [\n                ...this._moveLeftKeys,\n                ...this._moveRightKeys,\n                ...this._moveUpKeys,\n                ...this._moveDownKeys\n            ];\n            // Check if the next move keys are equal to the current ones.\n            const areMoveKeysEqual = [\n                ...this._moveKeys\n            ].every((key, index)=>nextMoveKeys[index] === key);\n            // Update move keys if needed.\n            if (!areMoveKeysEqual) {\n                this._moveKeys = new Set(nextMoveKeys);\n                this._moveKeyTimestamps.clear();\n                this._updateDirection();\n            }\n        }\n    }\n    destroy() {\n        if (this.isDestroyed) return;\n        super.destroy();\n        this.off(\"tick\", this._onTick);\n        document.removeEventListener(\"keydown\", this._onKeyDown);\n        document.removeEventListener(\"keyup\", this._onKeyUp);\n        window.removeEventListener(\"blur\", this.cancel);\n        window.removeEventListener(\"visibilitychange\", this.cancel);\n    }\n}\n\n\n\n\nclass $128271867868f1db$export$12e4b40eac1bcb71 {\n    constructor(sensor, startEvent){\n        this.sensor = sensor;\n        this.isEnded = false;\n        this.event = startEvent;\n        this.prevEvent = startEvent;\n        this.startEvent = startEvent;\n        this.endEvent = null;\n        this.items = [];\n    }\n}\n\n\nconst $45554ebda029bd05$var$STYLE_DECLARATION_CACHE = new WeakMap;\nfunction $45554ebda029bd05$export$3d2f074408bd1b82(e, t) {\n    if (t) return window.getComputedStyle(e, t);\n    let C = $45554ebda029bd05$var$STYLE_DECLARATION_CACHE.get(e)?.deref();\n    return C || (C = window.getComputedStyle(e, null), $45554ebda029bd05$var$STYLE_DECLARATION_CACHE.set(e, new WeakRef(C))), C;\n}\n\n\nconst $70e6b31ea6202e28$export$e44ffb50cc242ec5 = \"undefined\" != typeof window && void 0 !== window.document;\nconst $70e6b31ea6202e28$export$af54264dae9065e6 = !!($70e6b31ea6202e28$export$e44ffb50cc242ec5 && navigator.vendor && navigator.vendor.indexOf(\"Apple\") > -1 && navigator.userAgent && -1 == navigator.userAgent.indexOf(\"CriOS\") && -1 == navigator.userAgent.indexOf(\"FxiOS\"));\nconst $70e6b31ea6202e28$export$11fd24d838ebde87 = {\n    content: \"content\",\n    padding: \"padding\",\n    scrollbar: \"scrollbar\",\n    border: \"border\",\n    margin: \"margin\"\n};\nconst $70e6b31ea6202e28$export$76e909bcfd8ba196 = {\n    [$70e6b31ea6202e28$export$11fd24d838ebde87.content]: !1,\n    [$70e6b31ea6202e28$export$11fd24d838ebde87.padding]: !1,\n    [$70e6b31ea6202e28$export$11fd24d838ebde87.scrollbar]: !0,\n    [$70e6b31ea6202e28$export$11fd24d838ebde87.border]: !0,\n    [$70e6b31ea6202e28$export$11fd24d838ebde87.margin]: !0\n};\nconst $70e6b31ea6202e28$export$d2ad2856e215d28e = new Set([\n    \"auto\",\n    \"scroll\"\n]);\nconst $70e6b31ea6202e28$export$cd414719242f618c = (()=>{\n    try {\n        return window.navigator.userAgentData.brands.some(({ brand: n })=>\"Chromium\" === n);\n    } catch (n) {\n        return !1;\n    }\n})();\n\n\n\n\nfunction $ac4a87157cb8fded$export$fab73c3646bf1f5e(e) {\n    switch((0, $45554ebda029bd05$export$3d2f074408bd1b82)(e).display){\n        case \"none\":\n            return null;\n        case \"inline\":\n        case \"contents\":\n            return !1;\n        default:\n            return !0;\n    }\n}\n\n\nfunction $19cb8cdbc5921691$export$e5ce114ae0e5f4e8(n) {\n    const t = (0, $45554ebda029bd05$export$3d2f074408bd1b82)(n);\n    if (!(0, $70e6b31ea6202e28$export$af54264dae9065e6)) {\n        const { filter: n } = t;\n        if (n && \"none\" !== n) return !0;\n        const { backdropFilter: e } = t;\n        if (e && \"none\" !== e) return !0;\n        const { willChange: i } = t;\n        if (i && (i.indexOf(\"filter\") > -1 || i.indexOf(\"backdrop-filter\") > -1)) return !0;\n    }\n    const e = (0, $ac4a87157cb8fded$export$fab73c3646bf1f5e)(n);\n    if (!e) return e;\n    const { transform: i } = t;\n    if (i && \"none\" !== i) return !0;\n    const { perspective: r } = t;\n    if (r && \"none\" !== r) return !0;\n    const { contentVisibility: o } = t;\n    if (o && \"auto\" === o) return !0;\n    const { contain: f } = t;\n    if (f && (\"strict\" === f || \"content\" === f || f.indexOf(\"paint\") > -1 || f.indexOf(\"layout\") > -1)) return !0;\n    const { willChange: c } = t;\n    return !(!c || !(c.indexOf(\"transform\") > -1 || c.indexOf(\"perspective\") > -1 || c.indexOf(\"contain\") > -1)) || !!((0, $70e6b31ea6202e28$export$af54264dae9065e6) && c && c.indexOf(\"filter\") > -1);\n}\n\n\n\n\nfunction $ea1829f02863f9a1$export$996cb64f2dabb66f(t) {\n    return \"static\" !== (0, $45554ebda029bd05$export$3d2f074408bd1b82)(t).position || (0, $19cb8cdbc5921691$export$e5ce114ae0e5f4e8)(t);\n}\n\n\n\nfunction $8d1ba90c23ec3360$export$d8a62a489b442872(e) {\n    return e instanceof HTMLHtmlElement;\n}\n\n\nfunction $1f38751365ebdabf$export$940d8225183e1404(e, t = {}) {\n    if ((0, $8d1ba90c23ec3360$export$d8a62a489b442872)(e)) return e.ownerDocument.defaultView;\n    const n = t.position || (0, $45554ebda029bd05$export$3d2f074408bd1b82)(e).position, { skipDisplayNone: i, container: o } = t;\n    switch(n){\n        case \"static\":\n        case \"relative\":\n        case \"sticky\":\n        case \"-webkit-sticky\":\n            {\n                let t = o || e.parentElement;\n                for(; t;){\n                    const e = (0, $ac4a87157cb8fded$export$fab73c3646bf1f5e)(t);\n                    if (e) return t;\n                    if (null === e && !i) return null;\n                    t = t.parentElement;\n                }\n                return e.ownerDocument.documentElement;\n            }\n        case \"absolute\":\n        case \"fixed\":\n            {\n                const t = \"fixed\" === n;\n                let l = o || e.parentElement;\n                for(; l;){\n                    const e = t ? (0, $19cb8cdbc5921691$export$e5ce114ae0e5f4e8)(l) : (0, $ea1829f02863f9a1$export$996cb64f2dabb66f)(l);\n                    if (!0 === e) return l;\n                    if (null === e && !i) return null;\n                    l = l.parentElement;\n                }\n                return e.ownerDocument.defaultView;\n            }\n        default:\n            return null;\n    }\n}\n\n\nfunction $15174ae68f2a890f$export$8d3dd0be5eb9f11f(t, e) {\n    return !(t.left + t.width <= e.left || e.left + e.width <= t.left || t.top + t.height <= e.top || e.top + e.height <= t.top);\n}\n\n\nfunction $6473c4721ef9a7f0$export$53137579a3174918(t, e, n, o) {\n    return Math.sqrt(Math.pow(n - t, 2) + Math.pow(o - e, 2));\n}\n\n\nfunction $1565a77b3ba33365$export$2d670be792dba464(t, e) {\n    if ((0, $15174ae68f2a890f$export$8d3dd0be5eb9f11f)(t, e)) return null;\n    const n = t.left + t.width, i = t.top + t.height, o = e.left + e.width, s = e.top + e.height;\n    return n <= e.left ? i <= e.top ? (0, $6473c4721ef9a7f0$export$53137579a3174918)(n, i, e.left, e.top) : t.top >= s ? (0, $6473c4721ef9a7f0$export$53137579a3174918)(n, t.top, e.left, s) : e.left - n : t.left >= o ? i <= e.top ? (0, $6473c4721ef9a7f0$export$53137579a3174918)(t.left, i, o, e.top) : t.top >= s ? (0, $6473c4721ef9a7f0$export$53137579a3174918)(t.left, t.top, o, s) : t.left - o : i <= e.top ? e.top - i : t.top - s;\n}\n\n\n\nfunction $0dd5d633d9254ede$export$5a096129d439f843(n) {\n    return n instanceof Window;\n}\n\n\nfunction $88986006632f0ab8$export$62858bae88b53fd0(n) {\n    return n instanceof Document;\n}\n\n\n\n\nconst $9a36d0396b9b09d4$var$SUBPIXEL_OFFSET = new Map;\nlet $9a36d0396b9b09d4$var$testStyleElement = null, $9a36d0396b9b09d4$var$testParentElement = null, $9a36d0396b9b09d4$var$testChildElement = null;\nfunction $9a36d0396b9b09d4$var$getSubpixelScrollbarSize(t, e) {\n    const n = t.split(\".\");\n    let l = $9a36d0396b9b09d4$var$SUBPIXEL_OFFSET.get(n[1]);\n    if (void 0 === l) {\n        $9a36d0396b9b09d4$var$testStyleElement || ($9a36d0396b9b09d4$var$testStyleElement = document.createElement(\"style\")), $9a36d0396b9b09d4$var$testStyleElement.innerHTML = `\\n      #mezr-scrollbar-test::-webkit-scrollbar {\\n        width: ${t} !important;\\n      }\\n    `, $9a36d0396b9b09d4$var$testParentElement && $9a36d0396b9b09d4$var$testChildElement || ($9a36d0396b9b09d4$var$testParentElement = document.createElement(\"div\"), $9a36d0396b9b09d4$var$testChildElement = document.createElement(\"div\"), $9a36d0396b9b09d4$var$testParentElement.appendChild($9a36d0396b9b09d4$var$testChildElement), $9a36d0396b9b09d4$var$testParentElement.id = \"mezr-scrollbar-test\", $9a36d0396b9b09d4$var$testParentElement.style.cssText = \"\\n        all: unset !important;\\n        position: fixed !important;\\n        top: -200px !important;\\n        left: 0px !important;\\n        width: 100px !important;\\n        height: 100px !important;\\n        overflow: scroll !important;\\n        pointer-events: none !important;\\n        visibility: hidden !important;\\n      \", $9a36d0396b9b09d4$var$testChildElement.style.cssText = \"\\n        all: unset !important;\\n        position: absolute !important;\\n        inset: 0 !important;\\n      \"), document.body.appendChild($9a36d0396b9b09d4$var$testStyleElement), document.body.appendChild($9a36d0396b9b09d4$var$testParentElement);\n        l = $9a36d0396b9b09d4$var$testParentElement.getBoundingClientRect().width - $9a36d0396b9b09d4$var$testChildElement.getBoundingClientRect().width - e, $9a36d0396b9b09d4$var$SUBPIXEL_OFFSET.set(n[1], l), document.body.removeChild($9a36d0396b9b09d4$var$testParentElement), document.body.removeChild($9a36d0396b9b09d4$var$testStyleElement);\n    }\n    return e + l;\n}\nfunction $9a36d0396b9b09d4$export$5ad86f4734d24a64(t, e, n) {\n    if (n <= 0) return 0;\n    if (0, $70e6b31ea6202e28$export$cd414719242f618c) {\n        const n = (0, $45554ebda029bd05$export$3d2f074408bd1b82)(t, \"::-webkit-scrollbar\"), l = \"x\" === e ? n.height : n.width, i = parseFloat(l);\n        if (!Number.isNaN(i) && !Number.isInteger(i)) return $9a36d0396b9b09d4$var$getSubpixelScrollbarSize(l, i);\n    }\n    return n;\n}\n\n\nfunction $9bae4574eed9d865$export$91cf85d6c980faa0(e, r = !1) {\n    if (r) return e.innerWidth;\n    const { innerWidth: t, document: i } = e, { documentElement: n } = i, { clientWidth: c } = n;\n    return t - (0, $9a36d0396b9b09d4$export$5ad86f4734d24a64)(n, \"y\", t - c);\n}\n\n\nfunction $50cb9a0c1dee19de$export$a76b7f4aaec6cdf4({ documentElement: t }) {\n    return Math.max(t.scrollWidth, t.clientWidth, t.getBoundingClientRect().width);\n}\n\n\n\n\n\n\nfunction $f1039b87670ca1f4$export$742d7f6cc44470f1(t, e = (0, $70e6b31ea6202e28$export$11fd24d838ebde87).border) {\n    let { width: r } = t.getBoundingClientRect();\n    if (e === (0, $70e6b31ea6202e28$export$11fd24d838ebde87).border) return r;\n    const o = (0, $45554ebda029bd05$export$3d2f074408bd1b82)(t);\n    return e === (0, $70e6b31ea6202e28$export$11fd24d838ebde87).margin ? (r += Math.max(0, parseFloat(o.marginLeft) || 0), r += Math.max(0, parseFloat(o.marginRight) || 0), r) : (r -= parseFloat(o.borderLeftWidth) || 0, r -= parseFloat(o.borderRightWidth) || 0, e === (0, $70e6b31ea6202e28$export$11fd24d838ebde87).scrollbar ? r : (!(0, $8d1ba90c23ec3360$export$d8a62a489b442872)(t) && (0, $70e6b31ea6202e28$export$d2ad2856e215d28e).has(o.overflowY) && (r -= (0, $9a36d0396b9b09d4$export$5ad86f4734d24a64)(t, \"y\", Math.round(r) - t.clientWidth)), e === (0, $70e6b31ea6202e28$export$11fd24d838ebde87).padding || (r -= parseFloat(o.paddingLeft) || 0, r -= parseFloat(o.paddingRight) || 0), r));\n}\n\n\nfunction $2e59c48b8f000a71$export$3c49c185de0c2bfc(t, i = (0, $70e6b31ea6202e28$export$11fd24d838ebde87).border) {\n    return (0, $0dd5d633d9254ede$export$5a096129d439f843)(t) ? (0, $9bae4574eed9d865$export$91cf85d6c980faa0)(t, (0, $70e6b31ea6202e28$export$76e909bcfd8ba196)[i]) : (0, $88986006632f0ab8$export$62858bae88b53fd0)(t) ? (0, $50cb9a0c1dee19de$export$a76b7f4aaec6cdf4)(t) : (0, $f1039b87670ca1f4$export$742d7f6cc44470f1)(t, i);\n}\n\n\n\n\n\n\nfunction $421143bc1c1515a1$export$a3648dbc3769cbf4(e, r = !1) {\n    if (r) return e.innerHeight;\n    const { innerHeight: t, document: i } = e, { documentElement: n } = i, { clientHeight: c } = n;\n    return t - (0, $9a36d0396b9b09d4$export$5ad86f4734d24a64)(n, \"x\", t - c);\n}\n\n\nfunction $8e302b6d23f55757$export$5806f5d4b3eb6a6a({ documentElement: t }) {\n    return Math.max(t.scrollHeight, t.clientHeight, t.getBoundingClientRect().height);\n}\n\n\n\n\n\n\nfunction $598de259e69a6df4$export$8e0f1520ce23a388(t, e = (0, $70e6b31ea6202e28$export$11fd24d838ebde87).border) {\n    let { height: r } = t.getBoundingClientRect();\n    if (e === (0, $70e6b31ea6202e28$export$11fd24d838ebde87).border) return r;\n    const o = (0, $45554ebda029bd05$export$3d2f074408bd1b82)(t);\n    return e === (0, $70e6b31ea6202e28$export$11fd24d838ebde87).margin ? (r += Math.max(0, parseFloat(o.marginTop) || 0), r += Math.max(0, parseFloat(o.marginBottom) || 0), r) : (r -= parseFloat(o.borderTopWidth) || 0, r -= parseFloat(o.borderBottomWidth) || 0, e === (0, $70e6b31ea6202e28$export$11fd24d838ebde87).scrollbar ? r : (!(0, $8d1ba90c23ec3360$export$d8a62a489b442872)(t) && (0, $70e6b31ea6202e28$export$d2ad2856e215d28e).has(o.overflowX) && (r -= (0, $9a36d0396b9b09d4$export$5ad86f4734d24a64)(t, \"x\", Math.round(r) - t.clientHeight)), e === (0, $70e6b31ea6202e28$export$11fd24d838ebde87).padding || (r -= parseFloat(o.paddingTop) || 0, r -= parseFloat(o.paddingBottom) || 0), r));\n}\n\n\nfunction $646cecfa59ec4923$export$c08559766941f856(t, e = (0, $70e6b31ea6202e28$export$11fd24d838ebde87).border) {\n    return (0, $0dd5d633d9254ede$export$5a096129d439f843)(t) ? (0, $421143bc1c1515a1$export$a3648dbc3769cbf4)(t, (0, $70e6b31ea6202e28$export$76e909bcfd8ba196)[e]) : (0, $88986006632f0ab8$export$62858bae88b53fd0)(t) ? (0, $8e302b6d23f55757$export$5806f5d4b3eb6a6a)(t) : (0, $598de259e69a6df4$export$8e0f1520ce23a388)(t, e);\n}\n\n\nfunction $4de8edd731addea8$export$ff047630cae37d8e(t) {\n    return t?.constructor === Object;\n}\n\n\n\n\n\n\n\nfunction $faeeed2de97ac6f7$export$9f1480883798e819(t, o = (0, $70e6b31ea6202e28$export$11fd24d838ebde87).border) {\n    const e = {\n        left: 0,\n        top: 0\n    };\n    if ((0, $88986006632f0ab8$export$62858bae88b53fd0)(t)) return e;\n    if ((0, $0dd5d633d9254ede$export$5a096129d439f843)(t)) return e.left += t.scrollX || 0, e.top += t.scrollY || 0, e;\n    const r = t.ownerDocument.defaultView;\n    r && (e.left += r.scrollX || 0, e.top += r.scrollY || 0);\n    const n = t.getBoundingClientRect();\n    if (e.left += n.left, e.top += n.top, o === (0, $70e6b31ea6202e28$export$11fd24d838ebde87).border) return e;\n    const l = (0, $45554ebda029bd05$export$3d2f074408bd1b82)(t);\n    return o === (0, $70e6b31ea6202e28$export$11fd24d838ebde87).margin ? (e.left -= Math.max(0, parseFloat(l.marginLeft) || 0), e.top -= Math.max(0, parseFloat(l.marginTop) || 0), e) : (e.left += parseFloat(l.borderLeftWidth) || 0, e.top += parseFloat(l.borderTopWidth) || 0, o === (0, $70e6b31ea6202e28$export$11fd24d838ebde87).scrollbar || o === (0, $70e6b31ea6202e28$export$11fd24d838ebde87).padding || (e.left += parseFloat(l.paddingLeft) || 0, e.top += parseFloat(l.paddingTop) || 0), e);\n}\n\n\nfunction $d927f435c3d7e8ab$export$622cea445a1c5b7d(t, e) {\n    const o = (0, $4de8edd731addea8$export$ff047630cae37d8e)(t) ? {\n        left: t.left,\n        top: t.top\n    } : Array.isArray(t) ? (0, $faeeed2de97ac6f7$export$9f1480883798e819)(...t) : (0, $faeeed2de97ac6f7$export$9f1480883798e819)(t);\n    if (e && !(0, $88986006632f0ab8$export$62858bae88b53fd0)(e)) {\n        const t = (0, $4de8edd731addea8$export$ff047630cae37d8e)(e) ? e : Array.isArray(e) ? (0, $faeeed2de97ac6f7$export$9f1480883798e819)(e[0], e[1]) : (0, $faeeed2de97ac6f7$export$9f1480883798e819)(e);\n        o.left -= t.left, o.top -= t.top;\n    }\n    return o;\n}\n\n\n\nfunction $4fec7741c67a29fc$export$4b834cebd9e5cebe(t, e) {\n    let i = 0, g = 0;\n    (0, $4de8edd731addea8$export$ff047630cae37d8e)(t) ? (i = t.width, g = t.height) : Array.isArray(t) ? (i = (0, $2e59c48b8f000a71$export$3c49c185de0c2bfc)(...t), g = (0, $646cecfa59ec4923$export$c08559766941f856)(...t)) : (i = (0, $2e59c48b8f000a71$export$3c49c185de0c2bfc)(t), g = (0, $646cecfa59ec4923$export$c08559766941f856)(t));\n    const r = (0, $d927f435c3d7e8ab$export$622cea445a1c5b7d)(t, e);\n    return {\n        width: i,\n        height: g,\n        ...r,\n        right: r.left + i,\n        bottom: r.top + g\n    };\n}\n\n\n\nfunction $3fe9db1ad94d3e7c$export$e4e616e82e79ab9d(t) {\n    return (0, $4de8edd731addea8$export$ff047630cae37d8e)(t) ? t : (0, $4fec7741c67a29fc$export$4b834cebd9e5cebe)(t);\n}\n\n\nfunction $2a599c00d4ed99d6$export$79376507b09a66f(e, t) {\n    const c = (0, $3fe9db1ad94d3e7c$export$e4e616e82e79ab9d)(e), i = (0, $3fe9db1ad94d3e7c$export$e4e616e82e79ab9d)(t);\n    return (0, $1565a77b3ba33365$export$2d670be792dba464)(c, i);\n}\n\n\n\n\nfunction $e931ad6985aacff5$export$72209efa88586d42(t, ...e) {\n    const o = {\n        ...(0, $3fe9db1ad94d3e7c$export$e4e616e82e79ab9d)(t),\n        right: 0,\n        bottom: 0\n    };\n    for (const t of e){\n        const e = (0, $3fe9db1ad94d3e7c$export$e4e616e82e79ab9d)(t), i = Math.max(o.left, e.left), h = Math.min(o.left + o.width, e.left + e.width);\n        if (h <= i) return null;\n        const r = Math.max(o.top, e.top), l = Math.min(o.top + o.height, e.height + e.top);\n        if (l <= r) return null;\n        o.left = i, o.top = r, o.width = h - i, o.height = l - r;\n    }\n    return o.right = o.left + o.width, o.bottom = o.top + o.height, o;\n}\n\n\n\n\n\n\nfunction $4effe6f7501c7f59$export$243d7fadef466e38(n, t = {}) {\n    const i = (0, $45554ebda029bd05$export$3d2f074408bd1b82)(n), { display: o } = i;\n    if (\"none\" === o || \"contents\" === o) return null;\n    const e = t.position || (0, $45554ebda029bd05$export$3d2f074408bd1b82)(n).position, { skipDisplayNone: s, container: r } = t;\n    switch(e){\n        case \"relative\":\n            return n;\n        case \"fixed\":\n            return (0, $1f38751365ebdabf$export$940d8225183e1404)(n, {\n                container: r,\n                position: e,\n                skipDisplayNone: s\n            });\n        case \"absolute\":\n            {\n                const t = (0, $1f38751365ebdabf$export$940d8225183e1404)(n, {\n                    container: r,\n                    position: e,\n                    skipDisplayNone: s\n                });\n                return (0, $0dd5d633d9254ede$export$5a096129d439f843)(t) ? n.ownerDocument : t;\n            }\n        default:\n            return null;\n    }\n}\n\n\n\nfunction $28b6730affddb905$export$f63a1e5ecde5e3c4(t, e) {\n    const o = (0, $3fe9db1ad94d3e7c$export$e4e616e82e79ab9d)(t), i = (0, $3fe9db1ad94d3e7c$export$e4e616e82e79ab9d)(e);\n    return {\n        left: i.left - o.left,\n        right: o.left + o.width - (i.left + i.width),\n        top: i.top - o.top,\n        bottom: o.top + o.height - (i.top + i.height)\n    };\n}\n\n\n\n\n\n\nconst $0c69ffc8ab90052a$var$STYLE_DECLARATION_CACHE = new WeakMap();\nfunction $0c69ffc8ab90052a$export$3d2f074408bd1b82(element) {\n    let styleDeclaration = $0c69ffc8ab90052a$var$STYLE_DECLARATION_CACHE.get(element)?.deref();\n    if (!styleDeclaration) {\n        styleDeclaration = window.getComputedStyle(element, null);\n        $0c69ffc8ab90052a$var$STYLE_DECLARATION_CACHE.set(element, new WeakRef(styleDeclaration));\n    }\n    return styleDeclaration;\n}\n\n\n\nfunction $5b850440d58ca286$export$5e94c6e790b2d913(elemA, elemB, result = {\n    left: 0,\n    top: 0\n}) {\n    result.left = 0;\n    result.top = 0;\n    // If elements are same let's return early.\n    if (elemA === elemB) return result;\n    // Finally, let's calculate the offset diff.\n    const offsetA = (0, $d927f435c3d7e8ab$export$622cea445a1c5b7d)([\n        elemA,\n        \"padding\"\n    ]);\n    const offsetB = (0, $d927f435c3d7e8ab$export$622cea445a1c5b7d)([\n        elemB,\n        \"padding\"\n    ]);\n    result.left = offsetB.left - offsetA.left;\n    result.top = offsetB.top - offsetA.top;\n    return result;\n}\n\n\nconst $6985a94cfe75e842$var$OFFSET_DIFF = {\n    left: 0,\n    top: 0\n};\nconst $6985a94cfe75e842$var$IDENTITY_MATRIX = \"matrix(1, 0, 0, 1, 0, 0)\";\nconst $6985a94cfe75e842$var$IDENTITY_MATRIX_3D = \"matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)\";\nclass $6985a94cfe75e842$export$b87fb2dc7f11ca52 {\n    constructor(element, draggable){\n        // Make sure the element is in DOM.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected\n        if (!element.isConnected) throw new Error(\"Element is not connected\");\n        // Make sure sensor is defined.\n        const sensor = draggable.drag?.sensor;\n        if (!sensor) throw new Error(\"Sensor is not defined\");\n        const item = this;\n        const style = (0, $0c69ffc8ab90052a$export$3d2f074408bd1b82)(element);\n        const clientRect = element.getBoundingClientRect();\n        this.data = {};\n        this.element = element;\n        this.frozenProps = null;\n        this.unfrozenProps = null;\n        this.position = {\n            x: 0,\n            y: 0\n        };\n        this._updateDiff = {\n            x: 0,\n            y: 0\n        };\n        this._moveDiff = {\n            x: 0,\n            y: 0\n        };\n        this._containerDiff = {\n            x: 0,\n            y: 0\n        };\n        // Use element's parent element as the element container.\n        const elementContainer = element.parentElement;\n        if (!elementContainer) throw new Error(\"Element does not have a parent element.\");\n        this.elementContainer = elementContainer;\n        // Compute element's offset container.\n        const elementOffsetContainer = (0, $4effe6f7501c7f59$export$243d7fadef466e38)(element);\n        if (!elementOffsetContainer) throw new Error(\"Offset container could not be computed for the element!\");\n        this.elementOffsetContainer = elementOffsetContainer;\n        // Get element's drag parent, default to element's parent element.\n        const dragContainer = draggable.settings.container || elementContainer;\n        this.dragContainer = dragContainer;\n        // Get drag container's offset container.\n        const dragOffsetContainer = dragContainer === elementContainer ? elementOffsetContainer : (0, $4effe6f7501c7f59$export$243d7fadef466e38)(element, {\n            container: dragContainer\n        });\n        if (!dragOffsetContainer) throw new Error(\"Drag offset container could not be computed for the element!\");\n        this.dragOffsetContainer = dragOffsetContainer;\n        // Store element's client rect.\n        {\n            const { left: left, top: top, width: width, height: height } = clientRect;\n            this.clientRect = {\n                left: left,\n                top: top,\n                width: width,\n                height: height\n            };\n        }\n        // If element's offset container is different than drag container's\n        // offset container let's compute the offset between the offset containers.\n        if (elementOffsetContainer !== dragOffsetContainer) {\n            const { left: left, top: top } = (0, $5b850440d58ca286$export$5e94c6e790b2d913)(dragOffsetContainer, elementOffsetContainer, $6985a94cfe75e842$var$OFFSET_DIFF);\n            this._containerDiff.x = left;\n            this._containerDiff.y = top;\n        }\n        // Store element's initial transform.\n        const { transform: transform } = style;\n        if (transform && transform !== \"none\" && transform !== $6985a94cfe75e842$var$IDENTITY_MATRIX && transform !== $6985a94cfe75e842$var$IDENTITY_MATRIX_3D) this.initialTransform = transform;\n        else this.initialTransform = \"\";\n        // Get element's initial position. This position is relative to the\n        // properties the user is using to move the element. For example, if the\n        // user is using the `translate` transform to move the element then the\n        // initial position will be relative to the `translate` transform and the\n        // position here should reflect the transform value delta.\n        const { x: x, y: y } = draggable.settings.getStartPosition({\n            draggable: draggable,\n            sensor: sensor,\n            item: item,\n            style: style\n        });\n        this.position.x = x;\n        this.position.y = y;\n        // Get element's frozen props.\n        const frozenProps = draggable.settings.getFrozenProps({\n            draggable: draggable,\n            sensor: sensor,\n            item: item,\n            style: style\n        });\n        if (Array.isArray(frozenProps)) {\n            if (frozenProps.length) {\n                const props = {};\n                for (const prop of frozenProps)props[prop] = style[prop];\n                this.frozenProps = props;\n            } else this.frozenProps = null;\n        } else this.frozenProps = frozenProps;\n        // Lastly, let's compute the unfrozen props. We store the current inline\n        // style values for all frozen props so that we can restore them after the\n        // drag process is over.\n        if (this.frozenProps) {\n            const unfrozenProps = {};\n            for(const key in this.frozenProps)if (this.frozenProps.hasOwnProperty(key)) unfrozenProps[key] = element.style[key];\n            this.unfrozenProps = unfrozenProps;\n        }\n    }\n    updateSize(dimensions) {\n        if (dimensions) {\n            this.clientRect.width = dimensions.width;\n            this.clientRect.height = dimensions.height;\n        } else {\n            const rect = this.element.getBoundingClientRect();\n            this.clientRect.width = rect.width;\n            this.clientRect.height = rect.height;\n        }\n    }\n}\n\n\n\n\nconst $e9cd0e353e15b4ae$var$SCROLL_LISTENER_OPTIONS = (0, $9ecda7333d28e490$export$ffcf6b6ce241bd05) ? {\n    capture: true,\n    passive: true\n} : true;\nconst $e9cd0e353e15b4ae$var$OFFSET_DIFF = {\n    left: 0,\n    top: 0\n};\nconst $e9cd0e353e15b4ae$var$POSITION_CHANGE = {\n    x: 0,\n    y: 0\n};\nvar $e9cd0e353e15b4ae$var$DraggableStartPredicateState;\n(function(DraggableStartPredicateState) {\n    DraggableStartPredicateState[DraggableStartPredicateState[\"PENDING\"] = 0] = \"PENDING\";\n    DraggableStartPredicateState[DraggableStartPredicateState[\"RESOLVED\"] = 1] = \"RESOLVED\";\n    DraggableStartPredicateState[DraggableStartPredicateState[\"REJECTED\"] = 2] = \"REJECTED\";\n})($e9cd0e353e15b4ae$var$DraggableStartPredicateState || ($e9cd0e353e15b4ae$var$DraggableStartPredicateState = {}));\nfunction $e9cd0e353e15b4ae$var$getDefaultSettings() {\n    return {\n        container: null,\n        startPredicate: ()=>true,\n        getElements: ()=>null,\n        releaseElements: ()=>null,\n        getFrozenProps: ()=>null,\n        getStartPosition: ()=>{\n            return {\n                x: 0,\n                y: 0\n            };\n        },\n        setPosition: ({ item: item, x: x, y: y })=>{\n            item.element.style.transform = `translate(${x}px, ${y}px) ${item.initialTransform}`;\n        },\n        getPositionChange: ({ event: event, prevEvent: prevEvent })=>{\n            $e9cd0e353e15b4ae$var$POSITION_CHANGE.x = event.x - prevEvent.x;\n            $e9cd0e353e15b4ae$var$POSITION_CHANGE.y = event.y - prevEvent.y;\n            return $e9cd0e353e15b4ae$var$POSITION_CHANGE;\n        }\n    };\n}\nclass $e9cd0e353e15b4ae$export$f2a139e5d18b9882 {\n    constructor(sensors, options = {}){\n        this.sensors = sensors;\n        this.settings = this._parseSettings(options);\n        this.plugins = {};\n        this.drag = null;\n        this.isDestroyed = false;\n        this._sensorData = new Map();\n        this._emitter = new (0, $882b296db6123935$export$4293555f241ae35a)();\n        this._startId = Symbol();\n        this._moveId = Symbol();\n        this._updateId = Symbol();\n        // Bind methods (that need binding).\n        this._onMove = this._onMove.bind(this);\n        this._onScroll = this._onScroll.bind(this);\n        this._onEnd = this._onEnd.bind(this);\n        this._prepareStart = this._prepareStart.bind(this);\n        this._applyStart = this._applyStart.bind(this);\n        this._prepareMove = this._prepareMove.bind(this);\n        this._applyMove = this._applyMove.bind(this);\n        this._preparePositionUpdate = this._preparePositionUpdate.bind(this);\n        this._applyPositionUpdate = this._applyPositionUpdate.bind(this);\n        // Bind drag sensor events.\n        this.sensors.forEach((sensor)=>{\n            this._sensorData.set(sensor, {\n                predicateState: 0,\n                predicateEvent: null,\n                onMove: (e)=>this._onMove(e, sensor),\n                onEnd: (e)=>this._onEnd(e, sensor)\n            });\n            const { onMove: onMove, onEnd: onEnd } = this._sensorData.get(sensor);\n            sensor.on(\"start\", onMove);\n            sensor.on(\"move\", onMove);\n            sensor.on(\"cancel\", onEnd);\n            sensor.on(\"end\", onEnd);\n            sensor.on(\"destroy\", onEnd);\n        });\n    }\n    _parseSettings(options, defaults = $e9cd0e353e15b4ae$var$getDefaultSettings()) {\n        const { container: container = defaults.container, startPredicate: startPredicate = defaults.startPredicate, getElements: getElements = defaults.getElements, releaseElements: releaseElements = defaults.releaseElements, getFrozenProps: getFrozenProps = defaults.getFrozenProps, getStartPosition: getStartPosition = defaults.getStartPosition, setPosition: setPosition = defaults.setPosition, getPositionChange: getPositionChange = defaults.getPositionChange } = options || {};\n        return {\n            container: container,\n            startPredicate: startPredicate,\n            getElements: getElements,\n            releaseElements: releaseElements,\n            getFrozenProps: getFrozenProps,\n            getStartPosition: getStartPosition,\n            setPosition: setPosition,\n            getPositionChange: getPositionChange\n        };\n    }\n    _emit(type, ...e) {\n        this._emitter.emit(type, ...e);\n    }\n    _onMove(e, sensor) {\n        const sensorData = this._sensorData.get(sensor);\n        if (!sensorData) return;\n        switch(sensorData.predicateState){\n            case 0:\n                {\n                    sensorData.predicateEvent = e;\n                    // Check if drag should start.\n                    const shouldStart = this.settings.startPredicate({\n                        draggable: this,\n                        sensor: sensor,\n                        event: e\n                    });\n                    // Resolve procedure (start move process).\n                    if (shouldStart === true) this.resolveStartPredicate(sensor);\n                    else if (shouldStart === false) this.rejectStartPredicate(sensor);\n                    break;\n                }\n            case 1:\n                // Move the element if dragging is active.\n                if (this.drag) {\n                    this.drag.event = e;\n                    (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).once((0, $c1fd6b62e08b3d47$export$9138efc7ba4fca22), this._prepareMove, this._moveId);\n                    (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).once((0, $c1fd6b62e08b3d47$export$5fd1e257088db342), this._applyMove, this._moveId);\n                }\n                break;\n        }\n    }\n    _onScroll() {\n        this.updatePosition();\n    }\n    _onEnd(e, sensor) {\n        const sensorData = this._sensorData.get(sensor);\n        if (!sensorData) return;\n        // If there is no active drag yet, let's reset the sensor's start predicate\n        // so that it can try starting drag again.\n        if (!this.drag) {\n            sensorData.predicateState = 0;\n            sensorData.predicateEvent = null;\n        } else if (sensorData.predicateState === 1) {\n            this.drag.endEvent = e;\n            this._sensorData.forEach((data)=>{\n                data.predicateState = 0;\n                data.predicateEvent = null;\n            });\n            this.stop();\n        }\n    }\n    _prepareStart() {\n        const drag = this.drag;\n        if (!drag) return;\n        // Get elements that we'll need to move with the drag.\n        // NB: It is okay if there are no elements and thus no items. The drag\n        // process will process as usual, but nothing is moving by default.\n        const elements = this.settings.getElements({\n            draggable: this,\n            sensor: drag.sensor,\n            startEvent: drag.startEvent\n        }) || [];\n        // Create drag items.\n        drag.items = elements.map((element)=>{\n            return new (0, $6985a94cfe75e842$export$b87fb2dc7f11ca52)(element, this);\n        });\n        // Emit preparestart event.\n        this._emit(\"preparestart\", drag.startEvent);\n    }\n    _applyStart() {\n        const drag = this.drag;\n        if (!drag) return;\n        const { container: container } = this.settings;\n        for (const item of drag.items){\n            // Append element within the container element if such is provided.\n            if (container && item.element.parentElement !== container) {\n                container.appendChild(item.element);\n                item.position.x += item._containerDiff.x;\n                item.position.y += item._containerDiff.y;\n            }\n            // Freeze element's props if such are provided.\n            if (item.frozenProps) Object.assign(item.element.style, item.frozenProps);\n            // Set the element's start position.\n            this.settings.setPosition({\n                phase: \"start\",\n                draggable: this,\n                sensor: drag.sensor,\n                item: item,\n                x: item.position.x,\n                y: item.position.y\n            });\n        }\n        // Bind scroll listeners.\n        window.addEventListener(\"scroll\", this._onScroll, $e9cd0e353e15b4ae$var$SCROLL_LISTENER_OPTIONS);\n        // Emit start event.\n        this._emit(\"start\", drag.startEvent);\n    }\n    _prepareMove() {\n        const drag = this.drag;\n        if (!drag) return;\n        // Get next event and previous event so we can compute the movement\n        // difference between the clientX/Y values.\n        const { event: event, prevEvent: prevEvent, startEvent: startEvent, sensor: sensor } = drag;\n        if (event === prevEvent) return;\n        for (const item of drag.items){\n            // Compute how much x and y needs to be transformed.\n            const { x: changeX, y: changeY } = this.settings.getPositionChange({\n                draggable: this,\n                sensor: sensor,\n                item: item,\n                event: event,\n                prevEvent: prevEvent,\n                startEvent: startEvent\n            });\n            // Update horizontal position data.\n            if (changeX) {\n                item.position.x += changeX;\n                item.clientRect.left += changeX;\n                item._moveDiff.x += changeX;\n            }\n            // Update vertical position data.\n            if (changeY) {\n                item.position.y += changeY;\n                item.clientRect.top += changeY;\n                item._moveDiff.y += changeY;\n            }\n        }\n        // Store next event as previous event.\n        drag.prevEvent = event;\n        // Emit preparemove event.\n        this._emit(\"preparemove\", event);\n    }\n    _applyMove() {\n        const drag = this.drag;\n        if (!drag) return;\n        // Reset movement diff and move the element.\n        for (const item of drag.items){\n            item._moveDiff.x = 0;\n            item._moveDiff.y = 0;\n            this.settings.setPosition({\n                phase: \"move\",\n                draggable: this,\n                sensor: drag.sensor,\n                item: item,\n                x: item.position.x,\n                y: item.position.y\n            });\n        }\n        // Emit move event.\n        if (drag.event) this._emit(\"move\", drag.event);\n    }\n    _preparePositionUpdate() {\n        const { drag: drag } = this;\n        if (!drag) return;\n        for (const item of drag.items){\n            // Update container diff.\n            if (item.elementOffsetContainer !== item.dragOffsetContainer) {\n                const { left: left, top: top } = (0, $5b850440d58ca286$export$5e94c6e790b2d913)(item.dragOffsetContainer, item.elementOffsetContainer, $e9cd0e353e15b4ae$var$OFFSET_DIFF);\n                item._containerDiff.x = left;\n                item._containerDiff.y = top;\n            }\n            const { left: left, top: top, width: width, height: height } = item.element.getBoundingClientRect();\n            // Update horizontal position data.\n            const updateDiffX = item.clientRect.left - item._moveDiff.x - left;\n            item.position.x = item.position.x - item._updateDiff.x + updateDiffX;\n            item._updateDiff.x = updateDiffX;\n            // Update vertical position data.\n            const updateDiffY = item.clientRect.top - item._moveDiff.y - top;\n            item.position.y = item.position.y - item._updateDiff.y + updateDiffY;\n            item._updateDiff.y = updateDiffY;\n            // Update item client size. This is not necessary for the drag process,\n            // but since we're computing the bounding client rect, we might as well\n            // update the size in the process. The size is used by the auto-scroll\n            // plugin and possibly some other third-party plugins.\n            item.clientRect.width = width;\n            item.clientRect.height = height;\n        }\n    }\n    _applyPositionUpdate() {\n        const { drag: drag } = this;\n        if (!drag) return;\n        for (const item of drag.items){\n            item._updateDiff.x = 0;\n            item._updateDiff.y = 0;\n            this.settings.setPosition({\n                phase: \"move\",\n                draggable: this,\n                sensor: drag.sensor,\n                item: item,\n                x: item.position.x,\n                y: item.position.y\n            });\n        }\n    }\n    on(eventName, listener, listenerId) {\n        return this._emitter.on(eventName, listener, listenerId);\n    }\n    off(eventName, listener) {\n        this._emitter.off(eventName, listener);\n    }\n    resolveStartPredicate(sensor, e) {\n        const sensorData = this._sensorData.get(sensor);\n        if (!sensorData) return;\n        const startEvent = e || sensorData.predicateEvent;\n        if (sensorData.predicateState === 0 && startEvent) {\n            // Resolve the provided sensor's start predicate.\n            sensorData.predicateState = 1;\n            sensorData.predicateEvent = null;\n            this.drag = new (0, $128271867868f1db$export$12e4b40eac1bcb71)(sensor, startEvent);\n            // Reject other sensors' start predicates.\n            this._sensorData.forEach((data, s)=>{\n                if (s === sensor) return;\n                data.predicateState = 2;\n                data.predicateEvent = null;\n            });\n            // Queue drag start.\n            (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).once((0, $c1fd6b62e08b3d47$export$9138efc7ba4fca22), this._prepareStart, this._startId);\n            (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).once((0, $c1fd6b62e08b3d47$export$5fd1e257088db342), this._applyStart, this._startId);\n        }\n    }\n    rejectStartPredicate(sensor) {\n        const sensorData = this._sensorData.get(sensor);\n        if (sensorData?.predicateState === 0) {\n            sensorData.predicateState = 2;\n            sensorData.predicateEvent = null;\n        }\n    }\n    stop() {\n        const drag = this.drag;\n        if (!drag || drag.isEnded) return;\n        // Mark drag process as ended.\n        drag.isEnded = true;\n        // Cancel all queued ticks.\n        (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).off((0, $c1fd6b62e08b3d47$export$9138efc7ba4fca22), this._startId);\n        (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).off((0, $c1fd6b62e08b3d47$export$5fd1e257088db342), this._startId);\n        (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).off((0, $c1fd6b62e08b3d47$export$9138efc7ba4fca22), this._moveId);\n        (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).off((0, $c1fd6b62e08b3d47$export$5fd1e257088db342), this._moveId);\n        (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).off((0, $c1fd6b62e08b3d47$export$9138efc7ba4fca22), this._updateId);\n        (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).off((0, $c1fd6b62e08b3d47$export$5fd1e257088db342), this._updateId);\n        // Unbind scroll listener.\n        window.removeEventListener(\"scroll\", this._onScroll, $e9cd0e353e15b4ae$var$SCROLL_LISTENER_OPTIONS);\n        // Move elements within the root container and collect all elements\n        // to an elements array.\n        const elements = [];\n        for (const item of drag.items){\n            elements.push(item.element);\n            if (item.elementContainer && item.element.parentElement !== item.elementContainer) {\n                item.position.x -= item._containerDiff.x;\n                item.position.y -= item._containerDiff.y;\n                item._containerDiff.x = 0;\n                item._containerDiff.y = 0;\n                item.elementContainer.appendChild(item.element);\n            }\n            // Unfreeze element's props if such are provided.\n            if (item.unfrozenProps) for(const key in item.unfrozenProps)item.element.style[key] = item.unfrozenProps[key] || \"\";\n            // Set final position after drag.\n            this.settings.setPosition({\n                phase: \"end\",\n                draggable: this,\n                sensor: drag.sensor,\n                item: item,\n                x: item.position.x,\n                y: item.position.y\n            });\n        }\n        // Call \"releaseElements\" callback.\n        if (elements.length) this.settings.releaseElements({\n            draggable: this,\n            sensor: drag.sensor,\n            elements: elements\n        });\n        // Emit end event.\n        this._emit(\"end\", drag.endEvent);\n        // Reset drag data.\n        this.drag = null;\n    }\n    updatePosition(instant = false) {\n        if (!this.drag) return;\n        if (instant) {\n            this._preparePositionUpdate();\n            this._applyPositionUpdate();\n        } else {\n            (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).once((0, $c1fd6b62e08b3d47$export$9138efc7ba4fca22), this._preparePositionUpdate, this._updateId);\n            (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).once((0, $c1fd6b62e08b3d47$export$5fd1e257088db342), this._applyPositionUpdate, this._updateId);\n        }\n    }\n    updateSettings(options = {}) {\n        this.settings = this._parseSettings(options, this.settings);\n    }\n    use(plugin) {\n        return plugin(this);\n    }\n    destroy() {\n        if (this.isDestroyed) return;\n        this.isDestroyed = true;\n        this.stop();\n        this._sensorData.forEach(({ onMove: onMove, onEnd: onEnd }, sensor)=>{\n            sensor.off(\"start\", onMove);\n            sensor.off(\"move\", onMove);\n            sensor.off(\"cancel\", onEnd);\n            sensor.off(\"end\", onEnd);\n            sensor.off(\"destroy\", onEnd);\n        });\n        this._sensorData.clear();\n        this._emit(\"destroy\");\n        this._emitter.off();\n    }\n}\n\n\n\n\n\nclass $f045deb6d07519b3$export$14963ee5c8637e11 {\n    constructor(createObject, onPut){\n        this._data = [];\n        this._createObject = createObject;\n        this._onPut = onPut;\n    }\n    pick() {\n        return this._data.length ? this._data.pop() : this._createObject();\n    }\n    put(object) {\n        if (this._data.indexOf(object) === -1) {\n            this._onPut && this._onPut(object);\n            this._data.push(object);\n        }\n    }\n    reset() {\n        this._data.length = 0;\n    }\n}\n\n\n\n\nfunction $7d9b910efbacee79$export$f3fe0e9a60cde324(a, b) {\n    const intersection = (0, $e931ad6985aacff5$export$72209efa88586d42)(a, b);\n    return intersection ? intersection.width * intersection.height : 0;\n}\n\n\nfunction $6551604847fd2088$export$25b3e1e24e1ba229(a, b) {\n    const area = (0, $7d9b910efbacee79$export$f3fe0e9a60cde324)(a, b);\n    if (!area) return 0;\n    const maxArea = Math.min(a.width, b.width) * Math.min(a.height, b.height);\n    return area / maxArea * 100;\n}\n\n\n/**\n * Check if the current value is a window.\n */ function $f293b2d920f66b53$export$5a096129d439f843(value) {\n    return value instanceof Window;\n}\n\n\nfunction $1d5c880696869e94$export$31d37ff78a483ce2(element) {\n    if ((0, $f293b2d920f66b53$export$5a096129d439f843)(element) || element === document.documentElement || element === document.body) return window;\n    else return element;\n}\n\n\n\nfunction $8e79f2bef02bf7a3$export$1389d168952b34b5(element) {\n    return (0, $f293b2d920f66b53$export$5a096129d439f843)(element) ? element.pageXOffset : element.scrollLeft;\n}\n\n\n\nfunction $6a48622145310dd6$export$c16047c7a398106d(element) {\n    if ((0, $f293b2d920f66b53$export$5a096129d439f843)(element)) element = document.documentElement;\n    return element.scrollWidth - element.clientWidth;\n}\n\n\n\nfunction $b796ea00009cfb0f$export$c4a223a8ba9e4ea5(element) {\n    return (0, $f293b2d920f66b53$export$5a096129d439f843)(element) ? element.pageYOffset : element.scrollTop;\n}\n\n\n\nfunction $6ba3127b64f1801b$export$39d53b245a98193e(element) {\n    if ((0, $f293b2d920f66b53$export$5a096129d439f843)(element)) element = document.documentElement;\n    return element.scrollHeight - element.clientHeight;\n}\n\n\nfunction $dce4f2a3d0d356ef$export$8d3dd0be5eb9f11f(a, b) {\n    return !(a.right <= b.left || b.right <= a.left || a.bottom <= b.top || b.bottom <= a.top);\n}\n\n\n//\n// CONSTANTS\n//\nconst $292e4d9baf691c8b$var$R1 = {\n    width: 0,\n    height: 0,\n    left: 0,\n    right: 0,\n    top: 0,\n    bottom: 0\n};\nconst $292e4d9baf691c8b$var$R2 = {\n    ...$292e4d9baf691c8b$var$R1\n};\nconst $292e4d9baf691c8b$var$DEFAULT_THRESHOLD = 50;\nconst $292e4d9baf691c8b$var$SPEED_DATA = {\n    direction: \"none\",\n    threshold: 0,\n    distance: 0,\n    value: 0,\n    maxValue: 0,\n    duration: 0,\n    speed: 0,\n    deltaTime: 0,\n    isEnding: false\n};\nconst $292e4d9baf691c8b$export$5bbd74ab6c855dff = {\n    x: 1,\n    y: 2\n};\nconst $292e4d9baf691c8b$export$3eeb7a7b68c92567 = {\n    forward: 4,\n    reverse: 8\n};\nconst $292e4d9baf691c8b$var$AUTO_SCROLL_DIRECTION_X = {\n    none: 0,\n    left: $292e4d9baf691c8b$export$5bbd74ab6c855dff.x | $292e4d9baf691c8b$export$3eeb7a7b68c92567.reverse,\n    right: $292e4d9baf691c8b$export$5bbd74ab6c855dff.x | $292e4d9baf691c8b$export$3eeb7a7b68c92567.forward\n};\nconst $292e4d9baf691c8b$var$AUTO_SCROLL_DIRECTION_Y = {\n    none: 0,\n    up: $292e4d9baf691c8b$export$5bbd74ab6c855dff.y | $292e4d9baf691c8b$export$3eeb7a7b68c92567.reverse,\n    down: $292e4d9baf691c8b$export$5bbd74ab6c855dff.y | $292e4d9baf691c8b$export$3eeb7a7b68c92567.forward\n};\nconst $292e4d9baf691c8b$export$c9fbd1f9176bc8ed = {\n    ...$292e4d9baf691c8b$var$AUTO_SCROLL_DIRECTION_X,\n    ...$292e4d9baf691c8b$var$AUTO_SCROLL_DIRECTION_Y\n};\nfunction $292e4d9baf691c8b$var$getDirectionAsString(direction) {\n    switch(direction){\n        case $292e4d9baf691c8b$var$AUTO_SCROLL_DIRECTION_X.none:\n        case $292e4d9baf691c8b$var$AUTO_SCROLL_DIRECTION_Y.none:\n            return \"none\";\n        case $292e4d9baf691c8b$var$AUTO_SCROLL_DIRECTION_X.left:\n            return \"left\";\n        case $292e4d9baf691c8b$var$AUTO_SCROLL_DIRECTION_X.right:\n            return \"right\";\n        case $292e4d9baf691c8b$var$AUTO_SCROLL_DIRECTION_Y.up:\n            return \"up\";\n        case $292e4d9baf691c8b$var$AUTO_SCROLL_DIRECTION_Y.down:\n            return \"down\";\n        default:\n            throw new Error(`Unknown direction value: ${direction}`);\n    }\n}\nfunction $292e4d9baf691c8b$var$getPaddedRect(rect, padding, result) {\n    let { left: left = 0, right: right = 0, top: top = 0, bottom: bottom = 0 } = padding;\n    // Don't allow negative padding.\n    left = Math.max(0, left);\n    right = Math.max(0, right);\n    top = Math.max(0, top);\n    bottom = Math.max(0, bottom);\n    result.width = rect.width + left + right;\n    result.height = rect.height + top + bottom;\n    result.left = rect.left - left;\n    result.top = rect.top - top;\n    result.right = rect.right + right;\n    result.bottom = rect.bottom + bottom;\n    return result;\n}\nfunction $292e4d9baf691c8b$var$isScrolledToMax(scrollValue, maxScrollValue) {\n    // In some scenarios the scrollValue and/or maxScrollValue can be a float\n    // with subpixel values which might cause some funky scenarios where the\n    // element tries to scroll to the end but never actually reaches it. In such\n    // cases we want to do some rounding to detect that the element has actually\n    // reached the end of the scroll.\n    return Math.ceil(scrollValue) >= Math.floor(maxScrollValue);\n}\n//\n// PRIVATE UTILS\n//\nfunction $292e4d9baf691c8b$var$computeThreshold(idealThreshold, targetSize) {\n    return Math.min(targetSize / 2, idealThreshold);\n}\nfunction $292e4d9baf691c8b$var$computeEdgeOffset(threshold, inertAreaSize, itemSize, targetSize) {\n    return Math.max(0, itemSize + threshold * 2 + targetSize * inertAreaSize - targetSize) / 2;\n}\nclass $292e4d9baf691c8b$var$AutoScrollItemData {\n    constructor(){\n        this.positionX = 0;\n        this.positionY = 0;\n        this.directionX = $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.none;\n        this.directionY = $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.none;\n        this.overlapCheckRequestTime = 0;\n    }\n}\nclass $292e4d9baf691c8b$var$AutoScrollAction {\n    constructor(){\n        this.element = null;\n        this.requestX = null;\n        this.requestY = null;\n        this.scrollLeft = 0;\n        this.scrollTop = 0;\n    }\n    reset() {\n        if (this.requestX) this.requestX.action = null;\n        if (this.requestY) this.requestY.action = null;\n        this.element = null;\n        this.requestX = null;\n        this.requestY = null;\n        this.scrollLeft = 0;\n        this.scrollTop = 0;\n    }\n    addRequest(request) {\n        if ($292e4d9baf691c8b$export$5bbd74ab6c855dff.x & request.direction) {\n            this.requestX && this.removeRequest(this.requestX);\n            this.requestX = request;\n        } else {\n            this.requestY && this.removeRequest(this.requestY);\n            this.requestY = request;\n        }\n        request.action = this;\n    }\n    removeRequest(request) {\n        if (this.requestX === request) {\n            this.requestX = null;\n            request.action = null;\n        } else if (this.requestY === request) {\n            this.requestY = null;\n            request.action = null;\n        }\n    }\n    computeScrollValues() {\n        if (!this.element) return;\n        this.scrollLeft = this.requestX ? this.requestX.value : (0, $8e79f2bef02bf7a3$export$1389d168952b34b5)(this.element);\n        this.scrollTop = this.requestY ? this.requestY.value : (0, $b796ea00009cfb0f$export$c4a223a8ba9e4ea5)(this.element);\n    }\n    scroll() {\n        if (!this.element) return;\n        if (this.element.scrollTo) this.element.scrollTo(this.scrollLeft, this.scrollTop);\n        else {\n            this.element.scrollLeft = this.scrollLeft;\n            this.element.scrollTop = this.scrollTop;\n        }\n    }\n}\nclass $292e4d9baf691c8b$var$AutoScrollRequest {\n    constructor(){\n        this.item = null;\n        this.element = null;\n        this.isActive = false;\n        this.isEnding = false;\n        this.direction = 0;\n        this.value = NaN;\n        this.maxValue = 0;\n        this.threshold = 0;\n        this.distance = 0;\n        this.deltaTime = 0;\n        this.speed = 0;\n        this.duration = 0;\n        this.action = null;\n    }\n    reset() {\n        if (this.isActive) this.onStop();\n        this.item = null;\n        this.element = null;\n        this.isActive = false;\n        this.isEnding = false;\n        this.direction = 0;\n        this.value = NaN;\n        this.maxValue = 0;\n        this.threshold = 0;\n        this.distance = 0;\n        this.deltaTime = 0;\n        this.speed = 0;\n        this.duration = 0;\n        this.action = null;\n    }\n    hasReachedEnd() {\n        return $292e4d9baf691c8b$export$3eeb7a7b68c92567.forward & this.direction ? $292e4d9baf691c8b$var$isScrolledToMax(this.value, this.maxValue) : this.value <= 0;\n    }\n    computeCurrentScrollValue() {\n        if (!this.element) return 0;\n        if (this.value !== this.value) return $292e4d9baf691c8b$export$5bbd74ab6c855dff.x & this.direction ? (0, $8e79f2bef02bf7a3$export$1389d168952b34b5)(this.element) : (0, $b796ea00009cfb0f$export$c4a223a8ba9e4ea5)(this.element);\n        return Math.max(0, Math.min(this.value, this.maxValue));\n    }\n    computeNextScrollValue() {\n        const delta = this.speed * (this.deltaTime / 1000);\n        const nextValue = $292e4d9baf691c8b$export$3eeb7a7b68c92567.forward & this.direction ? this.value + delta : this.value - delta;\n        return Math.max(0, Math.min(nextValue, this.maxValue));\n    }\n    computeSpeed() {\n        if (!this.item || !this.element) return 0;\n        const { speed: speed } = this.item;\n        if (typeof speed === \"function\") {\n            $292e4d9baf691c8b$var$SPEED_DATA.direction = $292e4d9baf691c8b$var$getDirectionAsString(this.direction);\n            $292e4d9baf691c8b$var$SPEED_DATA.threshold = this.threshold;\n            $292e4d9baf691c8b$var$SPEED_DATA.distance = this.distance;\n            $292e4d9baf691c8b$var$SPEED_DATA.value = this.value;\n            $292e4d9baf691c8b$var$SPEED_DATA.maxValue = this.maxValue;\n            $292e4d9baf691c8b$var$SPEED_DATA.duration = this.duration;\n            $292e4d9baf691c8b$var$SPEED_DATA.speed = this.speed;\n            $292e4d9baf691c8b$var$SPEED_DATA.deltaTime = this.deltaTime;\n            $292e4d9baf691c8b$var$SPEED_DATA.isEnding = this.isEnding;\n            return speed(this.element, $292e4d9baf691c8b$var$SPEED_DATA);\n        } else return speed;\n    }\n    tick(deltaTime) {\n        if (!this.isActive) {\n            this.isActive = true;\n            this.onStart();\n        }\n        this.deltaTime = deltaTime;\n        this.value = this.computeCurrentScrollValue();\n        this.speed = this.computeSpeed();\n        this.value = this.computeNextScrollValue();\n        this.duration += deltaTime;\n        return this.value;\n    }\n    onStart() {\n        if (!this.item || !this.element) return;\n        const { onStart: onStart } = this.item;\n        if (typeof onStart === \"function\") onStart(this.element, $292e4d9baf691c8b$var$getDirectionAsString(this.direction));\n    }\n    onStop() {\n        if (!this.item || !this.element) return;\n        const { onStop: onStop } = this.item;\n        if (typeof onStop === \"function\") onStop(this.element, $292e4d9baf691c8b$var$getDirectionAsString(this.direction));\n    }\n}\nfunction $292e4d9baf691c8b$export$55a384729d91296b(// Pixels per second.\nmaxSpeed = 500, // Time in seconds, how long it will take to accelerate from 0 to maxSpeed.\naccelerationFactor = 0.5, // Time in seconds, how long it will take to decelerate maxSpeed to 0.\ndecelerationFactor = 0.25) {\n    const acceleration = maxSpeed * (accelerationFactor > 0 ? 1 / accelerationFactor : Infinity);\n    const deceleration = maxSpeed * (decelerationFactor > 0 ? 1 / decelerationFactor : Infinity);\n    return function(_element, data) {\n        let targetSpeed = 0;\n        if (!data.isEnding) {\n            if (data.threshold > 0) {\n                const factor = data.threshold - Math.max(0, data.distance);\n                targetSpeed = maxSpeed / data.threshold * factor;\n            } else targetSpeed = maxSpeed;\n        }\n        const currentSpeed = data.speed;\n        if (currentSpeed === targetSpeed) return targetSpeed;\n        let nextSpeed = targetSpeed;\n        if (currentSpeed < targetSpeed) {\n            nextSpeed = currentSpeed + acceleration * (data.deltaTime / 1000);\n            return Math.min(targetSpeed, nextSpeed);\n        } else {\n            nextSpeed = currentSpeed - deceleration * (data.deltaTime / 1000);\n            return Math.max(targetSpeed, nextSpeed);\n        }\n    };\n}\nclass $292e4d9baf691c8b$export$3fb39aee5567f02e {\n    constructor(options = {}){\n        const { overlapCheckInterval: overlapCheckInterval = 150 } = options;\n        this.items = [];\n        this.settings = {\n            overlapCheckInterval: overlapCheckInterval\n        };\n        this._actions = [];\n        this._isDestroyed = false;\n        this._isTicking = false;\n        this._tickTime = 0;\n        this._tickDeltaTime = 0;\n        this._requests = {\n            [$292e4d9baf691c8b$export$5bbd74ab6c855dff.x]: new Map(),\n            [$292e4d9baf691c8b$export$5bbd74ab6c855dff.y]: new Map()\n        };\n        this._itemData = new Map();\n        this._requestPool = new (0, $f045deb6d07519b3$export$14963ee5c8637e11)(()=>new $292e4d9baf691c8b$var$AutoScrollRequest(), (request)=>request.reset());\n        this._actionPool = new (0, $f045deb6d07519b3$export$14963ee5c8637e11)(()=>new $292e4d9baf691c8b$var$AutoScrollAction(), (action)=>action.reset());\n        this._emitter = new (0, $882b296db6123935$export$4293555f241ae35a)();\n        this._frameRead = this._frameRead.bind(this);\n        this._frameWrite = this._frameWrite.bind(this);\n    }\n    _frameRead(time) {\n        if (this._isDestroyed) return;\n        if (time && this._tickTime) {\n            this._tickDeltaTime = time - this._tickTime;\n            this._tickTime = time;\n            this._updateItems();\n            this._updateRequests();\n            this._updateActions();\n        } else {\n            this._tickTime = time;\n            this._tickDeltaTime = 0;\n        }\n    }\n    _frameWrite() {\n        if (this._isDestroyed) return;\n        this._applyActions();\n    }\n    _startTicking() {\n        if (this._isTicking) return;\n        this._isTicking = true;\n        (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).on((0, $c1fd6b62e08b3d47$export$9138efc7ba4fca22), this._frameRead);\n        (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).on((0, $c1fd6b62e08b3d47$export$5fd1e257088db342), this._frameWrite);\n    }\n    _stopTicking() {\n        if (!this._isTicking) return;\n        this._isTicking = false;\n        this._tickTime = 0;\n        this._tickDeltaTime = 0;\n        (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).off((0, $c1fd6b62e08b3d47$export$9138efc7ba4fca22), this._frameRead);\n        (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).off((0, $c1fd6b62e08b3d47$export$5fd1e257088db342), this._frameWrite);\n    }\n    _getItemClientRect(item, result = {\n        width: 0,\n        height: 0,\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n    }) {\n        const { clientRect: clientRect } = item;\n        result.left = clientRect.left;\n        result.top = clientRect.top;\n        result.width = clientRect.width;\n        result.height = clientRect.height;\n        result.right = clientRect.left + clientRect.width;\n        result.bottom = clientRect.top + clientRect.height;\n        return result;\n    }\n    _requestItemScroll(item, axis, element, direction, threshold, distance, maxValue) {\n        const reqMap = this._requests[axis];\n        let request = reqMap.get(item);\n        if (request) {\n            if (request.element !== element || request.direction !== direction) request.reset();\n        } else {\n            request = this._requestPool.pick();\n            reqMap.set(item, request);\n        }\n        request.item = item;\n        request.element = element;\n        request.direction = direction;\n        request.threshold = threshold;\n        request.distance = distance;\n        request.maxValue = maxValue;\n    }\n    _cancelItemScroll(item, axis) {\n        const reqMap = this._requests[axis];\n        const request = reqMap.get(item);\n        if (!request) return;\n        if (request.action) request.action.removeRequest(request);\n        this._requestPool.put(request);\n        reqMap.delete(item);\n    }\n    _checkItemOverlap(item, checkX, checkY) {\n        const { inertAreaSize: inertAreaSize, targets: targets } = item;\n        if (!targets.length) {\n            checkX && this._cancelItemScroll(item, $292e4d9baf691c8b$export$5bbd74ab6c855dff.x);\n            checkY && this._cancelItemScroll(item, $292e4d9baf691c8b$export$5bbd74ab6c855dff.y);\n            return;\n        }\n        const itemData = this._itemData.get(item);\n        const moveDirectionX = itemData?.directionX;\n        const moveDirectionY = itemData?.directionY;\n        if (!moveDirectionX && !moveDirectionY) {\n            checkX && this._cancelItemScroll(item, $292e4d9baf691c8b$export$5bbd74ab6c855dff.x);\n            checkY && this._cancelItemScroll(item, $292e4d9baf691c8b$export$5bbd74ab6c855dff.y);\n            return;\n        }\n        const itemRect = this._getItemClientRect(item, $292e4d9baf691c8b$var$R1);\n        let xElement = null;\n        let xPriority = -Infinity;\n        let xThreshold = 0;\n        let xScore = -Infinity;\n        let xDirection = $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.none;\n        let xDistance = 0;\n        let xMaxScroll = 0;\n        let yElement = null;\n        let yPriority = -Infinity;\n        let yThreshold = 0;\n        let yScore = -Infinity;\n        let yDirection = $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.none;\n        let yDistance = 0;\n        let yMaxScroll = 0;\n        let i = 0;\n        for(; i < targets.length; i++){\n            const target = targets[i];\n            const targetThreshold = typeof target.threshold === \"number\" ? target.threshold : $292e4d9baf691c8b$var$DEFAULT_THRESHOLD;\n            const testAxisX = !!(checkX && moveDirectionX && target.axis !== \"y\");\n            const testAxisY = !!(checkY && moveDirectionY && target.axis !== \"x\");\n            const testPriority = target.priority || 0;\n            // Ignore this item if it's x-axis and y-axis priority is lower than\n            // the currently matching item's.\n            if ((!testAxisX || testPriority < xPriority) && (!testAxisY || testPriority < yPriority)) continue;\n            const testElement = (0, $1d5c880696869e94$export$31d37ff78a483ce2)(target.element || target);\n            const testMaxScrollX = testAxisX ? (0, $6a48622145310dd6$export$c16047c7a398106d)(testElement) : -1;\n            const testMaxScrollY = testAxisY ? (0, $6ba3127b64f1801b$export$39d53b245a98193e)(testElement) : -1;\n            // Ignore this item if there is no possibility to scroll.\n            if (testMaxScrollX <= 0 && testMaxScrollY <= 0) continue;\n            const testRect = (0, $4fec7741c67a29fc$export$4b834cebd9e5cebe)([\n                testElement,\n                \"padding\"\n            ], window);\n            let testScore = (0, $6551604847fd2088$export$25b3e1e24e1ba229)(itemRect, testRect) || -Infinity;\n            // If the item has no overlap with the target.\n            if (testScore === -Infinity) {\n                // If the target has virtual extra padding defined and it's padded\n                // version overlaps with item then let's compute the shortest distance\n                // between item and target and use that value (negated) as testScore.\n                if (target.padding && (0, $dce4f2a3d0d356ef$export$8d3dd0be5eb9f11f)(itemRect, $292e4d9baf691c8b$var$getPaddedRect(testRect, target.padding, $292e4d9baf691c8b$var$R2))) testScore = -((0, $2a599c00d4ed99d6$export$79376507b09a66f)(itemRect, testRect) || 0);\n                else continue;\n            }\n            // Test x-axis.\n            if (testAxisX && testPriority >= xPriority && testMaxScrollX > 0 && (testPriority > xPriority || testScore > xScore)) {\n                let testDistance = 0;\n                let testDirection = $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.none;\n                const testThreshold = $292e4d9baf691c8b$var$computeThreshold(targetThreshold, testRect.width);\n                const testEdgeOffset = $292e4d9baf691c8b$var$computeEdgeOffset(testThreshold, inertAreaSize, itemRect.width, testRect.width);\n                if (moveDirectionX === $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.right) {\n                    testDistance = testRect.right + testEdgeOffset - itemRect.right;\n                    if (testDistance <= testThreshold && !$292e4d9baf691c8b$var$isScrolledToMax((0, $8e79f2bef02bf7a3$export$1389d168952b34b5)(testElement), testMaxScrollX)) testDirection = $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.right;\n                } else if (moveDirectionX === $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.left) {\n                    testDistance = itemRect.left - (testRect.left - testEdgeOffset);\n                    if (testDistance <= testThreshold && (0, $8e79f2bef02bf7a3$export$1389d168952b34b5)(testElement) > 0) testDirection = $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.left;\n                }\n                if (testDirection) {\n                    xElement = testElement;\n                    xPriority = testPriority;\n                    xThreshold = testThreshold;\n                    xScore = testScore;\n                    xDirection = testDirection;\n                    xDistance = testDistance;\n                    xMaxScroll = testMaxScrollX;\n                }\n            }\n            // Test y-axis.\n            if (testAxisY && testPriority >= yPriority && testMaxScrollY > 0 && (testPriority > yPriority || testScore > yScore)) {\n                let testDistance = 0;\n                let testDirection = $292e4d9baf691c8b$var$AUTO_SCROLL_DIRECTION_Y.none;\n                const testThreshold = $292e4d9baf691c8b$var$computeThreshold(targetThreshold, testRect.height);\n                const testEdgeOffset = $292e4d9baf691c8b$var$computeEdgeOffset(testThreshold, inertAreaSize, itemRect.height, testRect.height);\n                if (moveDirectionY === $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.down) {\n                    testDistance = testRect.bottom + testEdgeOffset - itemRect.bottom;\n                    if (testDistance <= testThreshold && !$292e4d9baf691c8b$var$isScrolledToMax((0, $b796ea00009cfb0f$export$c4a223a8ba9e4ea5)(testElement), testMaxScrollY)) testDirection = $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.down;\n                } else if (moveDirectionY === $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.up) {\n                    testDistance = itemRect.top - (testRect.top - testEdgeOffset);\n                    if (testDistance <= testThreshold && (0, $b796ea00009cfb0f$export$c4a223a8ba9e4ea5)(testElement) > 0) testDirection = $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.up;\n                }\n                if (testDirection) {\n                    yElement = testElement;\n                    yPriority = testPriority;\n                    yThreshold = testThreshold;\n                    yScore = testScore;\n                    yDirection = testDirection;\n                    yDistance = testDistance;\n                    yMaxScroll = testMaxScrollY;\n                }\n            }\n        }\n        // Request or cancel x-axis scroll.\n        if (checkX) {\n            if (xElement && xDirection) this._requestItemScroll(item, $292e4d9baf691c8b$export$5bbd74ab6c855dff.x, xElement, xDirection, xThreshold, xDistance, xMaxScroll);\n            else this._cancelItemScroll(item, $292e4d9baf691c8b$export$5bbd74ab6c855dff.x);\n        }\n        // Request or cancel y-axis scroll.\n        if (checkY) {\n            if (yElement && yDirection) this._requestItemScroll(item, $292e4d9baf691c8b$export$5bbd74ab6c855dff.y, yElement, yDirection, yThreshold, yDistance, yMaxScroll);\n            else this._cancelItemScroll(item, $292e4d9baf691c8b$export$5bbd74ab6c855dff.y);\n        }\n    }\n    _updateScrollRequest(scrollRequest) {\n        const item = scrollRequest.item;\n        const { inertAreaSize: inertAreaSize, smoothStop: smoothStop, targets: targets } = item;\n        const itemRect = this._getItemClientRect(item, $292e4d9baf691c8b$var$R1);\n        let hasReachedEnd = null;\n        let i = 0;\n        for(; i < targets.length; i++){\n            const target = targets[i];\n            // Make sure we have a matching element.\n            const testElement = (0, $1d5c880696869e94$export$31d37ff78a483ce2)(target.element || target);\n            if (testElement !== scrollRequest.element) continue;\n            // Make sure we have a matching axis.\n            const testIsAxisX = !!($292e4d9baf691c8b$export$5bbd74ab6c855dff.x & scrollRequest.direction);\n            if (testIsAxisX) {\n                if (target.axis === \"y\") continue;\n            } else {\n                if (target.axis === \"x\") continue;\n            }\n            // Make sure the element is still scrollable.\n            const testMaxScroll = testIsAxisX ? (0, $6a48622145310dd6$export$c16047c7a398106d)(testElement) : (0, $6ba3127b64f1801b$export$39d53b245a98193e)(testElement);\n            if (testMaxScroll <= 0) break;\n            const testRect = (0, $4fec7741c67a29fc$export$4b834cebd9e5cebe)([\n                testElement,\n                \"padding\"\n            ], window);\n            const testScore = (0, $6551604847fd2088$export$25b3e1e24e1ba229)(itemRect, testRect) || -Infinity;\n            // If the item has no overlap with the target nor the padded target rect\n            // let's stop scrolling.\n            if (testScore === -Infinity) {\n                const padding = target.scrollPadding || target.padding;\n                if (!(padding && (0, $dce4f2a3d0d356ef$export$8d3dd0be5eb9f11f)(itemRect, $292e4d9baf691c8b$var$getPaddedRect(testRect, padding, $292e4d9baf691c8b$var$R2)))) break;\n            }\n            // Compute threshold.\n            const targetThreshold = typeof target.threshold === \"number\" ? target.threshold : $292e4d9baf691c8b$var$DEFAULT_THRESHOLD;\n            const testThreshold = $292e4d9baf691c8b$var$computeThreshold(targetThreshold, testIsAxisX ? testRect.width : testRect.height);\n            // Compute edge offset.\n            const testEdgeOffset = $292e4d9baf691c8b$var$computeEdgeOffset(testThreshold, inertAreaSize, testIsAxisX ? itemRect.width : itemRect.height, testIsAxisX ? testRect.width : testRect.height);\n            // Compute distance (based on current direction).\n            let testDistance = 0;\n            if (scrollRequest.direction === $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.left) testDistance = itemRect.left - (testRect.left - testEdgeOffset);\n            else if (scrollRequest.direction === $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.right) testDistance = testRect.right + testEdgeOffset - itemRect.right;\n            else if (scrollRequest.direction === $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.up) testDistance = itemRect.top - (testRect.top - testEdgeOffset);\n            else testDistance = testRect.bottom + testEdgeOffset - itemRect.bottom;\n            // Stop scrolling if threshold is not exceeded.\n            if (testDistance > testThreshold) break;\n            // Stop scrolling if we have reached max scroll value.\n            const testScroll = testIsAxisX ? (0, $8e79f2bef02bf7a3$export$1389d168952b34b5)(testElement) : (0, $b796ea00009cfb0f$export$c4a223a8ba9e4ea5)(testElement);\n            hasReachedEnd = $292e4d9baf691c8b$export$3eeb7a7b68c92567.forward & scrollRequest.direction ? $292e4d9baf691c8b$var$isScrolledToMax(testScroll, testMaxScroll) : testScroll <= 0;\n            if (hasReachedEnd) break;\n            // Scrolling can continue, let's update the values.\n            scrollRequest.maxValue = testMaxScroll;\n            scrollRequest.threshold = testThreshold;\n            scrollRequest.distance = testDistance;\n            scrollRequest.isEnding = false;\n            return true;\n        }\n        // Before we end the request, let's see if we need to stop the scrolling\n        // smoothly or immediately.\n        if (smoothStop === true && scrollRequest.speed > 0) {\n            if (hasReachedEnd === null) hasReachedEnd = scrollRequest.hasReachedEnd();\n            scrollRequest.isEnding = hasReachedEnd ? false : true;\n        } else scrollRequest.isEnding = false;\n        return scrollRequest.isEnding;\n    }\n    _updateItems() {\n        for(let i = 0; i < this.items.length; i++){\n            const item = this.items[i];\n            const itemData = this._itemData.get(item);\n            const { x: x, y: y } = item.position;\n            const prevX = itemData.positionX;\n            const prevY = itemData.positionY;\n            // If there is no change in position -> skip.\n            if (x === prevX && y === prevY) continue;\n            // Update direction x.\n            itemData.directionX = x > prevX ? $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.right : x < prevX ? $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.left : itemData.directionX;\n            // Update direction y.\n            itemData.directionY = y > prevY ? $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.down : y < prevY ? $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.up : itemData.directionY;\n            // Update positions.\n            itemData.positionX = x;\n            itemData.positionY = y;\n            // Request overlap check (if not already requested).\n            if (itemData.overlapCheckRequestTime === 0) itemData.overlapCheckRequestTime = this._tickTime;\n        }\n    }\n    _updateRequests() {\n        const items = this.items;\n        const requestsX = this._requests[$292e4d9baf691c8b$export$5bbd74ab6c855dff.x];\n        const requestsY = this._requests[$292e4d9baf691c8b$export$5bbd74ab6c855dff.y];\n        let i = 0;\n        for(; i < items.length; i++){\n            const item = items[i];\n            const itemData = this._itemData.get(item);\n            const checkTime = itemData.overlapCheckRequestTime;\n            let needsCheck = checkTime > 0 && this._tickTime - checkTime > this.settings.overlapCheckInterval;\n            let checkX = true;\n            const reqX = requestsX.get(item);\n            if (reqX && reqX.isActive) {\n                checkX = !this._updateScrollRequest(reqX);\n                if (checkX) {\n                    needsCheck = true;\n                    this._cancelItemScroll(item, $292e4d9baf691c8b$export$5bbd74ab6c855dff.x);\n                }\n            }\n            let checkY = true;\n            const reqY = requestsY.get(item);\n            if (reqY && reqY.isActive) {\n                checkY = !this._updateScrollRequest(reqY);\n                if (checkY) {\n                    needsCheck = true;\n                    this._cancelItemScroll(item, $292e4d9baf691c8b$export$5bbd74ab6c855dff.y);\n                }\n            }\n            if (needsCheck) {\n                itemData.overlapCheckRequestTime = 0;\n                this._checkItemOverlap(item, checkX, checkY);\n            }\n        }\n    }\n    _requestAction(request, axis) {\n        const isAxisX = axis === $292e4d9baf691c8b$export$5bbd74ab6c855dff.x;\n        let action = null;\n        let i = 0;\n        for(; i < this._actions.length; i++){\n            action = this._actions[i];\n            // If the action's request does not match the request's -> skip.\n            if (request.element !== action.element) {\n                action = null;\n                continue;\n            }\n            // If the request and action share the same element, but the request slot\n            // for the requested axis is already reserved let's ignore and cancel this\n            // request.\n            if (isAxisX ? action.requestX : action.requestY) {\n                this._cancelItemScroll(request.item, axis);\n                return;\n            }\n            break;\n        }\n        if (!action) action = this._actionPool.pick();\n        action.element = request.element;\n        action.addRequest(request);\n        request.tick(this._tickDeltaTime);\n        this._actions.push(action);\n    }\n    _updateActions() {\n        let i = 0;\n        // Generate actions.\n        for(i = 0; i < this.items.length; i++){\n            const item = this.items[i];\n            const reqX = this._requests[$292e4d9baf691c8b$export$5bbd74ab6c855dff.x].get(item);\n            const reqY = this._requests[$292e4d9baf691c8b$export$5bbd74ab6c855dff.y].get(item);\n            if (reqX) this._requestAction(reqX, $292e4d9baf691c8b$export$5bbd74ab6c855dff.x);\n            if (reqY) this._requestAction(reqY, $292e4d9baf691c8b$export$5bbd74ab6c855dff.y);\n        }\n        // Compute scroll values.\n        for(i = 0; i < this._actions.length; i++)this._actions[i].computeScrollValues();\n    }\n    _applyActions() {\n        // No actions -> no scrolling.\n        if (!this._actions.length) return;\n        // TODO: Would be nice to emit also the elements that will be scrolled,\n        // to which direction they will be scrolled and how much they will be\n        // scrolled.\n        this._emitter.emit(\"beforescroll\");\n        let i = 0;\n        // Scroll all the required elements.\n        for(i = 0; i < this._actions.length; i++){\n            this._actions[i].scroll();\n            this._actionPool.put(this._actions[i]);\n        }\n        // Reset actions.\n        this._actions.length = 0;\n        // Call after scroll callbacks for all items that were scrolled.\n        let item;\n        for(i = 0; i < this.items.length; i++){\n            item = this.items[i];\n            if (item.onPrepareScrollEffect) item.onPrepareScrollEffect();\n        }\n        for(i = 0; i < this.items.length; i++){\n            item = this.items[i];\n            if (item.onApplyScrollEffect) item.onApplyScrollEffect();\n        }\n        // TODO: Would be nice to emit also the elements that were scrolled,\n        // to which direction they were scrolled and how much they were scrolled.\n        this._emitter.emit(\"afterscroll\");\n    }\n    /**\n   * Bind a listener.\n   */ on(eventName, listener) {\n        return this._emitter.on(eventName, listener);\n    }\n    /**\n   * Unbind a listener.\n   */ off(eventName, listener) {\n        this._emitter.off(eventName, listener);\n    }\n    addItem(item) {\n        if (this._isDestroyed || this._itemData.has(item)) return;\n        const { x: x, y: y } = item.position;\n        const itemData = new $292e4d9baf691c8b$var$AutoScrollItemData();\n        itemData.positionX = x;\n        itemData.positionY = y;\n        itemData.directionX = $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.none;\n        itemData.directionY = $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.none;\n        itemData.overlapCheckRequestTime = this._tickTime;\n        this._itemData.set(item, itemData);\n        this.items.push(item);\n        if (!this._isTicking) this._startTicking();\n    }\n    removeItem(item) {\n        if (this._isDestroyed) return;\n        const index = this.items.indexOf(item);\n        if (index === -1) return;\n        if (this._requests[$292e4d9baf691c8b$export$5bbd74ab6c855dff.x].get(item)) {\n            this._cancelItemScroll(item, $292e4d9baf691c8b$export$5bbd74ab6c855dff.x);\n            this._requests[$292e4d9baf691c8b$export$5bbd74ab6c855dff.x].delete(item);\n        }\n        if (this._requests[$292e4d9baf691c8b$export$5bbd74ab6c855dff.y].get(item)) {\n            this._cancelItemScroll(item, $292e4d9baf691c8b$export$5bbd74ab6c855dff.y);\n            this._requests[$292e4d9baf691c8b$export$5bbd74ab6c855dff.y].delete(item);\n        }\n        this._itemData.delete(item);\n        this.items.splice(index, 1);\n        if (this._isTicking && !this.items.length) this._stopTicking();\n    }\n    isDestroyed() {\n        return this._isDestroyed;\n    }\n    isItemScrollingX(item) {\n        return !!this._requests[$292e4d9baf691c8b$export$5bbd74ab6c855dff.x].get(item)?.isActive;\n    }\n    isItemScrollingY(item) {\n        return !!this._requests[$292e4d9baf691c8b$export$5bbd74ab6c855dff.y].get(item)?.isActive;\n    }\n    isItemScrolling(item) {\n        return this.isItemScrollingX(item) || this.isItemScrollingY(item);\n    }\n    updateSettings(options = {}) {\n        const { overlapCheckInterval: overlapCheckInterval = this.settings.overlapCheckInterval } = options;\n        this.settings.overlapCheckInterval = overlapCheckInterval;\n    }\n    destroy() {\n        if (this._isDestroyed) return;\n        const items = this.items.slice(0);\n        let i = 0;\n        for(; i < items.length; i++)this.removeItem(items[i]);\n        this._actions.length = 0;\n        this._requestPool.reset();\n        this._actionPool.reset();\n        this._emitter.off();\n        this._isDestroyed = true;\n    }\n}\n\n\n\nconst $b7221aa668f0d343$export$d976747ecb966cea = new (0, $292e4d9baf691c8b$export$3fb39aee5567f02e)();\n\n\nconst $6f9254451c60a12c$var$AUTOSCROLL_POSITION = {\n    x: 0,\n    y: 0\n};\nconst $6f9254451c60a12c$var$AUTOSCROLL_CLIENT_RECT = {\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0\n};\nfunction $6f9254451c60a12c$var$getDefaultSettings() {\n    return {\n        targets: [],\n        inertAreaSize: 0.2,\n        speed: (0, $292e4d9baf691c8b$export$55a384729d91296b)(),\n        smoothStop: false,\n        getPosition: (draggable)=>{\n            const { drag: drag } = draggable;\n            const primaryItem = drag?.items[0];\n            // Try to use the first item for the autoscroll data.\n            if (primaryItem) {\n                $6f9254451c60a12c$var$AUTOSCROLL_POSITION.x = primaryItem.position.x;\n                $6f9254451c60a12c$var$AUTOSCROLL_POSITION.y = primaryItem.position.y;\n            } else {\n                const e = drag && (drag.event || drag.startEvent);\n                $6f9254451c60a12c$var$AUTOSCROLL_POSITION.x = e ? e.x : 0;\n                $6f9254451c60a12c$var$AUTOSCROLL_POSITION.y = e ? e.y : 0;\n            }\n            return $6f9254451c60a12c$var$AUTOSCROLL_POSITION;\n        },\n        getClientRect: (draggable)=>{\n            const { drag: drag } = draggable;\n            const primaryItem = drag?.items[0];\n            // Try to use the first item for the autoscroll data.\n            if (primaryItem && primaryItem.element) {\n                const { left: left, top: top, width: width, height: height } = primaryItem.clientRect;\n                $6f9254451c60a12c$var$AUTOSCROLL_CLIENT_RECT.left = left;\n                $6f9254451c60a12c$var$AUTOSCROLL_CLIENT_RECT.top = top;\n                $6f9254451c60a12c$var$AUTOSCROLL_CLIENT_RECT.width = width;\n                $6f9254451c60a12c$var$AUTOSCROLL_CLIENT_RECT.height = height;\n            } else {\n                const e = drag && (drag.event || drag.startEvent);\n                $6f9254451c60a12c$var$AUTOSCROLL_CLIENT_RECT.left = e ? e.x - 25 : 0;\n                $6f9254451c60a12c$var$AUTOSCROLL_CLIENT_RECT.top = e ? e.y - 25 : 0;\n                $6f9254451c60a12c$var$AUTOSCROLL_CLIENT_RECT.width = e ? 50 : 0;\n                $6f9254451c60a12c$var$AUTOSCROLL_CLIENT_RECT.height = e ? 50 : 0;\n            }\n            return $6f9254451c60a12c$var$AUTOSCROLL_CLIENT_RECT;\n        },\n        onStart: null,\n        onStop: null\n    };\n}\nclass $6f9254451c60a12c$var$DraggableAutoScrollProxy {\n    constructor(draggableAutoScroll, draggable){\n        this._draggableAutoScroll = draggableAutoScroll;\n        this._draggable = draggable;\n        this._position = {\n            x: 0,\n            y: 0\n        };\n        this._clientRect = {\n            left: 0,\n            top: 0,\n            width: 0,\n            height: 0\n        };\n    }\n    _getSettings() {\n        return this._draggableAutoScroll.settings;\n    }\n    get targets() {\n        let { targets: targets } = this._getSettings();\n        if (typeof targets === \"function\") targets = targets(this._draggable);\n        return targets;\n    }\n    get position() {\n        let { getPosition: getPosition } = this._getSettings();\n        if (typeof getPosition === \"function\") {\n            const position = getPosition(this._draggable);\n            this._position.x = position.x;\n            this._position.y = position.y;\n        } else {\n            this._position.x = 0;\n            this._position.y = 0;\n        }\n        return this._position;\n    }\n    get clientRect() {\n        let { getClientRect: getClientRect } = this._getSettings();\n        if (typeof getClientRect === \"function\") {\n            const { left: left, top: top, width: width, height: height } = getClientRect(this._draggable);\n            this._clientRect.left = left;\n            this._clientRect.top = top;\n            this._clientRect.width = width;\n            this._clientRect.height = height;\n        } else {\n            this._clientRect.left = 0;\n            this._clientRect.top = 0;\n            this._clientRect.width = 0;\n            this._clientRect.height = 0;\n        }\n        return this._clientRect;\n    }\n    get inertAreaSize() {\n        return this._getSettings().inertAreaSize;\n    }\n    get smoothStop() {\n        return this._getSettings().smoothStop;\n    }\n    get speed() {\n        return this._getSettings().speed;\n    }\n    get onStart() {\n        return this._getSettings().onStart;\n    }\n    get onStop() {\n        return this._getSettings().onStop;\n    }\n    onPrepareScrollEffect() {\n        const updateId = this._draggable[\"_updateId\"];\n        (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).off((0, $c1fd6b62e08b3d47$export$9138efc7ba4fca22), updateId);\n        (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).off((0, $c1fd6b62e08b3d47$export$5fd1e257088db342), updateId);\n        this._draggable[\"_preparePositionUpdate\"]();\n    }\n    onApplyScrollEffect() {\n        this._draggable[\"_applyPositionUpdate\"]();\n    }\n}\nclass $6f9254451c60a12c$export$5059276ad4233de3 {\n    constructor(draggable, options = {}){\n        this.name = \"autoscroll\";\n        this.version = \"0.0.2\";\n        this.settings = this._parseSettings(options);\n        this._autoScrollProxy = null;\n        draggable.on(\"start\", ()=>{\n            if (!this._autoScrollProxy) {\n                this._autoScrollProxy = new $6f9254451c60a12c$var$DraggableAutoScrollProxy(this, draggable);\n                (0, $b7221aa668f0d343$export$d976747ecb966cea).addItem(this._autoScrollProxy);\n            }\n        });\n        draggable.on(\"end\", ()=>{\n            if (this._autoScrollProxy) {\n                (0, $b7221aa668f0d343$export$d976747ecb966cea).removeItem(this._autoScrollProxy);\n                this._autoScrollProxy = null;\n            }\n        });\n    }\n    _parseSettings(options, defaults = $6f9254451c60a12c$var$getDefaultSettings()) {\n        const { targets: targets = defaults.targets, inertAreaSize: inertAreaSize = defaults.inertAreaSize, speed: speed = defaults.speed, smoothStop: smoothStop = defaults.smoothStop, getPosition: getPosition = defaults.getPosition, getClientRect: getClientRect = defaults.getClientRect, onStart: onStart = defaults.onStart, onStop: onStop = defaults.onStop } = options || {};\n        return {\n            targets: targets,\n            inertAreaSize: inertAreaSize,\n            speed: speed,\n            smoothStop: smoothStop,\n            getPosition: getPosition,\n            getClientRect: getClientRect,\n            onStart: onStart,\n            onStop: onStop\n        };\n    }\n    updateSettings(options = {}) {\n        this.settings = this._parseSettings(options, this.settings);\n    }\n}\nfunction $6f9254451c60a12c$export$c0f5c18ade842ccd(options) {\n    return (draggable)=>{\n        const p = new $6f9254451c60a12c$export$5059276ad4233de3(draggable, options);\n        const d = draggable;\n        d.plugins[p.name] = p;\n        return d;\n    };\n}\n\n\n\n\n\n\n\nconst $a4c0af497ada6b6c$var$SCROLLABLE_OVERFLOWS = new Set([\n    \"auto\",\n    \"scroll\",\n    \"overlay\"\n]);\nfunction $a4c0af497ada6b6c$export$2bb74740c4e19def(element) {\n    const style = (0, $0c69ffc8ab90052a$export$3d2f074408bd1b82)(element);\n    return !!($a4c0af497ada6b6c$var$SCROLLABLE_OVERFLOWS.has(style.overflowY) || $a4c0af497ada6b6c$var$SCROLLABLE_OVERFLOWS.has(style.overflowX));\n}\n\n\n/**\n * Check if the current value is a document.\n */ function $9cf65cecf46550ef$export$62858bae88b53fd0(value) {\n    return value instanceof Document;\n}\n\n\nfunction $319ed547835de975$export$e4864aa91b5ed091(element, result = []) {\n    let parent = element?.parentNode;\n    while(parent && !(0, $9cf65cecf46550ef$export$62858bae88b53fd0)(parent)){\n        if (parent instanceof Element) {\n            if ((0, $a4c0af497ada6b6c$export$2bb74740c4e19def)(parent)) result.push(parent);\n            parent = parent.parentNode;\n        } else if (parent instanceof ShadowRoot) parent = parent.host;\n        else parent = parent.parentNode;\n    }\n    // Always push window to the results (as last scrollable element).\n    result.push(window);\n    return result;\n}\n\n\n\nfunction $27dd69ed29855bb5$var$getScrollables(element) {\n    const scrollables = [];\n    if ((0, $a4c0af497ada6b6c$export$2bb74740c4e19def)(element)) scrollables.push(element);\n    (0, $319ed547835de975$export$e4864aa91b5ed091)(element, scrollables);\n    return scrollables;\n}\nfunction $27dd69ed29855bb5$export$88d83dc4a35d804f(options = {}) {\n    let dragAllowed = undefined;\n    let startTimeStamp = 0;\n    let targetElement = null;\n    let timer = undefined;\n    const { timeout: timeout = 250, fallback: fallback = ()=>true } = options;\n    const onContextMenu = (e)=>e.preventDefault();\n    const onTouchMove = (e)=>{\n        if (!startTimeStamp) return;\n        if (dragAllowed) {\n            e.cancelable && e.preventDefault();\n            return;\n        }\n        if (dragAllowed === undefined) {\n            if (e.cancelable && e.timeStamp - startTimeStamp > timeout) {\n                dragAllowed = true;\n                e.preventDefault();\n            } else dragAllowed = false;\n        }\n    };\n    const pointerSensorStartPredicate = (data)=>{\n        if (!(data.sensor instanceof (0, $4998740c882fb340$export$b26af955418d6638))) return fallback(data);\n        const { draggable: draggable, sensor: sensor, event: event } = data;\n        const e = event;\n        if (e.pointerType === \"touch\") {\n            // On first event (touchstart/pointerdown) we need to store the drag start\n            // data and bind listeners for touchmove and contextmenu.\n            if (e.type === \"start\" && (e.srcEvent.type === \"pointerdown\" || e.srcEvent.type === \"touchstart\")) {\n                // Prevent potentially scrollable nodes from scrolling to make sure\n                // native scrolling does not interfere with dragging.\n                targetElement = e.target;\n                const scrollables = targetElement ? $27dd69ed29855bb5$var$getScrollables(targetElement) : [];\n                scrollables.forEach((scrollable)=>{\n                    scrollable.addEventListener(\"touchmove\", onTouchMove, {\n                        passive: false,\n                        capture: true\n                    });\n                });\n                const dragEndListener = ()=>{\n                    if (!startTimeStamp) return;\n                    // Unbind listeners.\n                    draggable.off(\"end\", dragEndListener);\n                    draggable.sensors.forEach((sensor)=>{\n                        if (sensor instanceof (0, $4998740c882fb340$export$b26af955418d6638)) sensor.off(\"end\", dragEndListener);\n                    });\n                    targetElement?.removeEventListener(\"contextmenu\", onContextMenu);\n                    scrollables.forEach((scrollable)=>{\n                        scrollable.removeEventListener(\"touchmove\", onTouchMove, {\n                            capture: true\n                        });\n                    });\n                    // Reset state.\n                    startTimeStamp = 0;\n                    dragAllowed = undefined;\n                    targetElement = null;\n                    timer = void window.clearTimeout(timer);\n                };\n                // Set start state.\n                dragAllowed = undefined;\n                startTimeStamp = e.srcEvent.timeStamp;\n                // Prevent context menu popping up.\n                targetElement?.addEventListener(\"contextmenu\", onContextMenu);\n                // Reset data on drag end.\n                draggable.on(\"end\", dragEndListener);\n                draggable.sensors.forEach((sensor)=>{\n                    if (sensor instanceof (0, $4998740c882fb340$export$b26af955418d6638)) sensor.off(\"end\", dragEndListener);\n                });\n                // If we have timeout defined, let's set a timer that force starts\n                // the drag process after the timeout.\n                // TODO: This will start drag sometimes when it's not actually possible\n                // to prevent the native scrolling on touch devices. We'd need a way\n                // to check if the first touchstart/touchmove is cancelable. Needs\n                // testing on real devices. The funky thing is that we seem to need to\n                // get one touchmove event to check if we can prevent native scrolling\n                // but that is kind of too late already.. let's see if we can detect\n                // that earlier somehow.\n                if (timeout > 0) timer = window.setTimeout(()=>{\n                    draggable.resolveStartPredicate(sensor);\n                    dragAllowed = true;\n                    timer = undefined;\n                }, timeout);\n            }\n            return dragAllowed;\n        }\n        // On mouse/pen let's allow starting drag immediately if mouse's left button\n        // is pressed down.\n        if (e.type === \"start\" && !e.srcEvent.button) return true;\n        else return false;\n    };\n    return pointerSensorStartPredicate;\n}\n\n\nfunction $1e65bdb9051e6b19$var$round(value, multipleOf) {\n    return Math.round(value / multipleOf) * multipleOf;\n}\nfunction $1e65bdb9051e6b19$var$getAxisChange(gridSize, snapPosition, sensorPosition) {\n    let change = sensorPosition - snapPosition;\n    let changeAbs = Math.abs(change);\n    if (changeAbs >= gridSize) {\n        const overflow = changeAbs % gridSize;\n        return $1e65bdb9051e6b19$var$round(change > 0 ? change - overflow : change + overflow, gridSize);\n    }\n    return 0;\n}\nfunction $1e65bdb9051e6b19$export$7f11ea1f0ba255b5(gridWidth, gridHeight) {\n    return function snapModifier({ startEvent: startEvent, event: event, item: item }) {\n        let { __snapX__: __snapX__ = startEvent.x, __snapY__: __snapY__ = startEvent.y } = item.data;\n        const changeX = $1e65bdb9051e6b19$var$getAxisChange(gridWidth, __snapX__, event.x);\n        const changeY = $1e65bdb9051e6b19$var$getAxisChange(gridHeight, __snapY__, event.y);\n        if (changeX) item.data.__snapX__ = __snapX__ + changeX;\n        if (changeY) item.data.__snapY__ = __snapY__ + changeY;\n        return {\n            x: changeX,\n            y: changeY\n        };\n    };\n}\n\n\n\n\nconst $0d81635c11b16eab$var$element = document.querySelector(\".draggable\");\nconst $0d81635c11b16eab$var$pointerSensor = new (0, $4998740c882fb340$export$b26af955418d6638)($0d81635c11b16eab$var$element);\nconst $0d81635c11b16eab$var$keyboardSensor = new (0, $5f12a12b1bebeb44$export$436f6efcc297171)();\nconst $0d81635c11b16eab$var$draggable = new (0, $e9cd0e353e15b4ae$export$f2a139e5d18b9882)([\n    $0d81635c11b16eab$var$pointerSensor,\n    $0d81635c11b16eab$var$keyboardSensor\n], {\n    getElements: ()=>[\n            $0d81635c11b16eab$var$element\n        ],\n    startPredicate: (0, $27dd69ed29855bb5$export$88d83dc4a35d804f)(),\n    getFrozenProps: ()=>[\n            \"transform\"\n        ]\n});\n$0d81635c11b16eab$var$draggable.on(\"start\", ()=>{\n    $0d81635c11b16eab$var$element.classList.add(\"dragging\");\n});\n$0d81635c11b16eab$var$draggable.on(\"end\", ()=>{\n    $0d81635c11b16eab$var$element.classList.remove(\"dragging\");\n});\n\n\n//# sourceMappingURL=index.a81e9c8b.js.map\n","import {\n  Draggable,\n  PointerSensor,\n  KeyboardMotionSensor,\n  createPointerSensorStartPredicate,\n} from '../../src';\n\nconst element = document.querySelector('.draggable') as HTMLElement;\nconst pointerSensor = new PointerSensor(element);\nconst keyboardSensor = new KeyboardMotionSensor();\nconst draggable = new Draggable([pointerSensor, keyboardSensor], {\n  getElements: () => [element],\n  startPredicate: createPointerSensorStartPredicate(),\n  getFrozenProps: () => ['transform'],\n});\n\ndraggable.on('start', () => {\n  element.classList.add('dragging');\n});\n\ndraggable.on('end', () => {\n  element.classList.remove('dragging');\n});\n","export * from './sensors/sensor.js';\n\nexport * from './sensors/base-sensor.js';\n\nexport * from './sensors/base-motion-sensor.js';\n\nexport * from './sensors/pointer-sensor.js';\n\nexport * from './sensors/keyboard-sensor.js';\n\nexport * from './sensors/keyboard-motion-sensor.js';\n\nexport * from './draggable/draggable.js';\n\nexport * from './draggable/plugins/auto-scroll-plugin.js';\n\nexport * from './auto-scroll/auto-scroll.js';\n\nexport * from './singletons/auto-scroll.js';\n\nexport * from './singletons/ticker.js';\n\nexport * from './utils/create-pointer-sensor-start-predicate.js';\n\nexport * from './utils/create-snap-modifier.js';\n","export const SensorEventType = {\n  start: 'start',\n  move: 'move',\n  cancel: 'cancel',\n  end: 'end',\n  destroy: 'destroy',\n} as const;\n\nexport interface SensorStartEvent {\n  type: typeof SensorEventType.start;\n  x: number;\n  y: number;\n}\n\nexport interface SensorMoveEvent {\n  type: typeof SensorEventType.move;\n  x: number;\n  y: number;\n}\n\nexport interface SensorCancelEvent {\n  type: typeof SensorEventType.cancel;\n  x: number;\n  y: number;\n}\n\nexport interface SensorEndEvent {\n  type: typeof SensorEventType.end;\n  x: number;\n  y: number;\n}\n\nexport interface SensorDestroyEvent {\n  type: typeof SensorEventType.destroy;\n}\n\nexport interface SensorEvents {\n  start: SensorStartEvent;\n  move: SensorMoveEvent;\n  cancel: SensorCancelEvent;\n  end: SensorEndEvent;\n  destroy: SensorDestroyEvent;\n}\n\nexport interface Sensor<E extends SensorEvents = SensorEvents> {\n  events: E;\n  on<K extends keyof E>(eventName: K, listener: (eventData: E[K]) => void): void;\n  off<K extends keyof E>(eventName: K, listener: (eventData: E[K]) => void): void;\n  cancel(): void;\n  destroy(): void;\n}\n","import { Emitter, Events, EventListenerId } from 'eventti';\n\nimport { Sensor, SensorEvents, SensorEventType } from './sensor.js';\n\nimport { Writeable } from '../types.js';\n\nexport interface BaseSensorDragData {\n  readonly x: number;\n  readonly y: number;\n}\n\nexport class BaseSensor<E extends SensorEvents = SensorEvents> implements Sensor<E> {\n  declare events: E;\n  readonly drag: BaseSensorDragData | null;\n  readonly isDestroyed: boolean;\n  protected _emitter: Emitter<Events>;\n\n  constructor() {\n    this.drag = null;\n    this.isDestroyed = false;\n    this._emitter = new Emitter();\n  }\n\n  protected _createDragData(data: E['start']): BaseSensorDragData {\n    return {\n      x: data.x,\n      y: data.y,\n    };\n  }\n\n  protected _updateDragData(data: E['move'] | E['end'] | E['cancel']) {\n    if (!this.drag) return;\n    (this.drag.x as Writeable<number>) = data.x;\n    (this.drag.y as Writeable<number>) = data.y;\n  }\n\n  protected _resetDragData() {\n    (this as Writeable<this>).drag = null;\n  }\n\n  protected _start(data: E['start']) {\n    if (this.isDestroyed || this.drag) return;\n    (this as Writeable<this>).drag = this._createDragData(data);\n    this._emitter.emit(SensorEventType.start, data);\n  }\n\n  protected _move(data: E['move']) {\n    if (!this.drag) return;\n    this._updateDragData(data);\n    this._emitter.emit(SensorEventType.move, data);\n  }\n\n  protected _end(data: E['end']) {\n    if (!this.drag) return;\n    this._updateDragData(data);\n    this._emitter.emit(SensorEventType.end, data);\n    this._resetDragData();\n  }\n\n  protected _cancel(data: E['cancel']) {\n    if (!this.drag) return;\n    this._updateDragData(data);\n    this._emitter.emit(SensorEventType.cancel, data);\n    this._resetDragData();\n  }\n\n  on<K extends keyof E>(\n    eventName: K,\n    listener: (e: E[K]) => void,\n    listenerId?: EventListenerId,\n  ): EventListenerId {\n    return this._emitter.on(eventName, listener, listenerId);\n  }\n\n  off<K extends keyof E>(eventName: K, listener: ((e: E[K]) => void) | EventListenerId): void {\n    this._emitter.off(eventName, listener);\n  }\n\n  cancel() {\n    if (!this.drag) return;\n    this._emitter.emit(SensorEventType.cancel, {\n      type: SensorEventType.cancel,\n      x: this.drag.x,\n      y: this.drag.y,\n    });\n    this._resetDragData();\n  }\n\n  destroy() {\n    if (this.isDestroyed) return;\n    (this as Writeable<this>).isDestroyed = true;\n    this.cancel();\n    this._emitter.emit(SensorEventType.destroy, {\n      type: SensorEventType.destroy,\n    });\n    this._emitter.off();\n  }\n}\n","function getOrCreateEventData(e,t){let i=e.get(t);return i||(i=new EventData,e.set(t,i)),i}class EventData{constructor(){this.idMap=new Map,this.fnMap=new Map,this.onceList=new Set,this.emitList=null}add(e,t,i,s,n){if(!n&&this.fnMap.has(e))throw new Error(\"Emitter: tried to add an existing event listener to an event!\");if(this.idMap.has(i))switch(s){case\"throw\":throw new Error(\"Emitter: tried to add an existing event listener id to an event!\");case\"ignore\":return i;default:this.delId(i,\"update\"===s)}let r=this.fnMap.get(e);return r||(r=new Set,this.fnMap.set(e,r)),r.add(i),this.idMap.set(i,e),t&&this.onceList.add(i),this.emitList&&this.emitList.push(e),i}delId(e,t=!1){const i=this.idMap.get(e);if(!i)return;const s=this.fnMap.get(i);t||this.idMap.delete(e),this.onceList.delete(e),s.delete(e),s.size||this.fnMap.delete(i),this.emitList=null}delFn(e){const t=this.fnMap.get(e);t&&(t.forEach((e=>{this.onceList.delete(e),this.idMap.delete(e)})),this.fnMap.delete(e),this.emitList=null)}}class Emitter{constructor(e={}){const{idDedupeMode:t=\"replace\",allowDuplicateListeners:i=!0}=e;this.idDedupeMode=t,this.allowDuplicateListeners=i,this._events=new Map}_getListeners(e){const t=this._events.get(e);if(!t)return null;const{idMap:i,onceList:s}=t;if(!i.size)return null;const n=t.emitList||[...i.values()];if(s.size)if(s.size===i.size)this._events.delete(e);else for(const e of s)t.delId(e);else t.emitList=n;return n}on(e,t,i=Symbol()){return getOrCreateEventData(this._events,e).add(t,!1,i,this.idDedupeMode,this.allowDuplicateListeners)}once(e,t,i=Symbol()){return getOrCreateEventData(this._events,e).add(t,!0,i,this.idDedupeMode,this.allowDuplicateListeners)}off(e,t){if(void 0===e)return void this._events.clear();if(void 0===t)return void this._events.delete(e);const i=this._events.get(e);i&&(\"function\"==typeof t?i.delFn(t):i.delId(t),i.idMap.size||this._events.delete(e))}emit(e,...t){const i=this._getListeners(e);if(!i)return;let s=0,n=i.length;for(;s<n;s++)i[s](...t)}listenerCount(e){var t;if(void 0===e){let e=0;return this._events.forEach(((t,i)=>{e+=this.listenerCount(i)})),e}return(null===(t=this._events.get(e))||void 0===t?void 0:t.idMap.size)||0}}export{Emitter};","import { Sensor, SensorEvents } from './sensor.js';\n\nimport { BaseSensor, BaseSensorDragData } from './base-sensor.js';\n\nimport { Writeable } from '../types.js';\n\nimport { ticker, tickerReadPhase } from '../singletons/ticker.js';\n\nexport interface BaseMotionSensorTickEvent {\n  type: 'tick';\n  time: number;\n  deltaTime: number;\n}\n\nexport interface BaseMotionSensorEvents extends SensorEvents {\n  tick: BaseMotionSensorTickEvent;\n}\n\nexport interface BaseMotionSensorDragData extends BaseSensorDragData {\n  readonly time: number;\n  readonly deltaTime: number;\n}\n\nexport class BaseMotionSensor<E extends BaseMotionSensorEvents = BaseMotionSensorEvents>\n  extends BaseSensor<E>\n  implements Sensor<E>\n{\n  declare events: E;\n  readonly drag: BaseMotionSensorDragData | null;\n  protected _direction: { x: number; y: number };\n  protected _speed: number;\n\n  constructor() {\n    super();\n    this.drag = null;\n    this._direction = { x: 0, y: 0 };\n    this._speed = 0;\n\n    this._tick = this._tick.bind(this);\n  }\n\n  protected _createDragData(data: E['start']): BaseMotionSensorDragData {\n    return {\n      ...super._createDragData(data),\n      time: 0,\n      deltaTime: 0,\n    };\n  }\n\n  protected _start(data: E['start']) {\n    if (this.isDestroyed || this.drag) return;\n    super._start(data);\n    ticker.on(tickerReadPhase, this._tick);\n  }\n\n  protected _end(data: E['end']) {\n    if (!this.drag) return;\n    ticker.off(tickerReadPhase, this._tick);\n    super._end(data);\n  }\n\n  protected _cancel(data: E['cancel']) {\n    if (!this.drag) return;\n    ticker.off(tickerReadPhase, this._tick);\n    super._cancel(data);\n  }\n\n  protected _tick(time: number) {\n    if (!this.drag) return;\n    if (time && this.drag.time) {\n      // Update tick time and delta time.\n      (this.drag.deltaTime as Writeable<number>) = time - this.drag.time;\n      (this.drag.time as Writeable<number>) = time;\n\n      // Emit tick event.\n      const tickEvent: BaseMotionSensorTickEvent = {\n        type: 'tick',\n        time: this.drag.time,\n        deltaTime: this.drag.deltaTime,\n      };\n      this._emitter.emit('tick', tickEvent);\n\n      // Make sure the sensor is still active.\n      if (!this.drag) return;\n\n      // Compute the movement offset (delta) by applying time factor to\n      // the speed. The speed is assumed to be provided as pixels-per-second.\n      const speedFactor = this._speed * (this.drag.deltaTime / 1000);\n      const deltaX = this._direction.x * speedFactor;\n      const deltaY = this._direction.y * speedFactor;\n\n      // Trigger move event if the clientX/Y needs change. Note that calling\n      // this._move() automatically updates clientX/Y values also so we don't\n      // need to do it here.\n      if (deltaX || deltaY) {\n        this._move({\n          type: 'move',\n          x: this.drag.x + deltaX,\n          y: this.drag.y + deltaY,\n        });\n      }\n    } else {\n      (this.drag.time as Writeable<number>) = time;\n      (this.drag.deltaTime as Writeable<number>) = 0;\n    }\n  }\n}\n","import { Ticker, FrameCallback } from 'tikki';\n\nimport { EventName } from 'eventti';\n\nexport let tickerReadPhase: EventName = Symbol();\n\nexport let tickerWritePhase: EventName = Symbol();\n\nexport let ticker = new Ticker<EventName>({ phases: [tickerReadPhase, tickerWritePhase] });\n\nexport function setTicker(\n  newTicker: Ticker<EventName, FrameCallback>,\n  readPhase: EventName,\n  writePhase: EventName,\n) {\n  tickerReadPhase = readPhase;\n  tickerWritePhase = writePhase;\n  ticker = newTicker;\n}\n","import{Emitter}from\"eventti\";function createRequestFrame(e=60){if(\"function\"==typeof requestAnimationFrame&&\"function\"==typeof cancelAnimationFrame)return e=>{const t=requestAnimationFrame(e);return()=>cancelAnimationFrame(t)};{const t=1e3/e,i=\"undefined\"==typeof performance?()=>Date.now():()=>performance.now();return e=>{const r=setTimeout((()=>e(i())),t);return()=>clearTimeout(r)}}}var AutoTickState;!function(e){e[e.PAUSED=1]=\"PAUSED\",e[e.ON_DEMAND=2]=\"ON_DEMAND\",e[e.CONTINUOUS=3]=\"CONTINUOUS\"}(AutoTickState||(AutoTickState={}));class Ticker{constructor(e={}){const{phases:t=[],autoTick:i=AutoTickState.ON_DEMAND,allowDuplicateListeners:r=!0,idDedupeMode:s=\"replace\",requestFrame:n=createRequestFrame()}=e;this.phases=t,this._autoTick=i,this._requestFrame=n,this._cancelFrame=null,this._queue=[],this._emitter=new Emitter({allowDuplicateListeners:r,idDedupeMode:s}),this.tick=this.tick.bind(this)}get requestFrame(){return this._requestFrame}set requestFrame(e){this._requestFrame=e,this._kickstart()}get autoTick(){return this._autoTick}set autoTick(e){this._autoTick=e,this._kickstart()}get allowDuplicateListeners(){return this._emitter.allowDuplicateListeners}set allowDuplicateListeners(e){this._emitter.allowDuplicateListeners=e}get idDedupeMode(){return this._emitter.idDedupeMode}set idDedupeMode(e){this._emitter.idDedupeMode=e}tick(...e){this._cancelFrame=null;const{_queue:t}=this;if(t.length)throw new Error(\"Ticker: Can't tick before the previous tick has finished!\");this._request();const{phases:i,_emitter:r}=this;let s,n,a,c,u,o;for(s=0,a=i.length;s<a;s++)o=r._getListeners(i[s]),o&&t.push(o);for(s=0,a=t.length;s<a;s++)for(u=t[s],n=0,c=u.length;n<c;n++)u[n](...e);t.length=0,this._autoTick!==AutoTickState.ON_DEMAND||r.listenerCount()||this._cancel()}on(e,t,i){const r=this._emitter.on(e,t,i);return this._request(),r}once(e,t,i){const r=this._emitter.once(e,t,i);return this._request(),r}off(e,t){return this._emitter.off(e,t)}listenerCount(e){return this._emitter.listenerCount(e)}_request(){this._requestFrame&&!this._cancelFrame&&this._autoTick>=AutoTickState.ON_DEMAND&&(this._cancelFrame=this._requestFrame(this.tick))}_cancel(){this._cancelFrame&&(this._cancelFrame(),this._cancelFrame=null)}_kickstart(){this._autoTick===AutoTickState.ON_DEMAND?this._emitter.listenerCount()&&this._request():this._autoTick===AutoTickState.CONTINUOUS?this._request():this._cancel()}}function createXrRequestFrame(e){return t=>{const i=e.requestAnimationFrame(t);return()=>e.cancelAnimationFrame(i)}}export{AutoTickState,Ticker,createRequestFrame,createXrRequestFrame};","import { Emitter, Events, EventListenerId } from 'eventti';\n\nimport { ListenerOptions, Writeable, PointerType } from '../types.js';\n\nimport {\n  Sensor,\n  SensorEventType,\n  SensorStartEvent,\n  SensorMoveEvent,\n  SensorCancelEvent,\n  SensorEndEvent,\n  SensorDestroyEvent,\n} from './sensor.js';\n\nimport { getPointerEventData } from '../utils/get-pointer-event-data.js';\n\nimport { getPointerType } from '../utils/get-pointer-type.js';\n\nimport { getPointerId } from '../utils/get-pointer-id.js';\n\nimport { parseListenerOptions } from '../utils/parse-listener-options.js';\n\nimport { parseSourceEvents } from '../utils/parse-source-events.js';\n\nconst POINTER_EVENTS = {\n  start: 'pointerdown',\n  move: 'pointermove',\n  cancel: 'pointercancel',\n  end: 'pointerup',\n} as const;\n\nconst TOUCH_EVENTS = {\n  start: 'touchstart',\n  move: 'touchmove',\n  cancel: 'touchcancel',\n  end: 'touchend',\n} as const;\n\nconst MOUSE_EVENTS = {\n  start: 'mousedown',\n  move: 'mousemove',\n  cancel: '',\n  end: 'mouseup',\n} as const;\n\nconst SOURCE_EVENTS = {\n  pointer: POINTER_EVENTS,\n  touch: TOUCH_EVENTS,\n  mouse: MOUSE_EVENTS,\n} as const;\n\ntype PointerSensorSourceEvent = PointerEvent | TouchEvent | MouseEvent;\n\nexport type PointerSensorDragData = {\n  readonly pointerId: number;\n  readonly pointerType: PointerType;\n  readonly x: number;\n  readonly y: number;\n};\n\nexport interface PointerSensorSettings {\n  listenerOptions: ListenerOptions;\n  sourceEvents: keyof typeof SOURCE_EVENTS | 'auto';\n  startPredicate: (e: PointerSensorSourceEvent) => boolean;\n}\n\nexport interface PointerSensorStartEvent extends SensorStartEvent {\n  pointerId: number;\n  pointerType: PointerType;\n  srcEvent: PointerSensorSourceEvent;\n  target: EventTarget | null;\n}\n\nexport interface PointerSensorMoveEvent extends SensorMoveEvent {\n  pointerId: number;\n  pointerType: PointerType;\n  srcEvent: PointerSensorSourceEvent;\n  target: EventTarget | null;\n}\n\nexport interface PointerSensorCancelEvent extends SensorCancelEvent {\n  pointerId: number;\n  pointerType: PointerType;\n  srcEvent: PointerSensorSourceEvent | null;\n  target: EventTarget | null;\n}\n\nexport interface PointerSensorEndEvent extends SensorEndEvent {\n  pointerId: number;\n  pointerType: PointerType;\n  srcEvent: PointerSensorSourceEvent | null;\n  target: EventTarget | null;\n}\n\nexport interface PointerSensorDestroyEvent extends SensorDestroyEvent {}\n\nexport interface PointerSensorEvents {\n  start: PointerSensorStartEvent;\n  move: PointerSensorMoveEvent;\n  cancel: PointerSensorCancelEvent;\n  end: PointerSensorEndEvent;\n  destroy: PointerSensorDestroyEvent;\n}\n\nexport class PointerSensor<E extends PointerSensorEvents = PointerSensorEvents>\n  implements Sensor<E>\n{\n  declare events: E;\n\n  /**\n   * The observed element or window.\n   */\n  readonly element: Element | Window;\n\n  /**\n   * Current drag data, null if drag is not active.\n   */\n  readonly drag: PointerSensorDragData | null;\n\n  /**\n   * Indicator if the instance is destroyed.\n   */\n  readonly isDestroyed: boolean;\n\n  /**\n   * The options object to be used for `addEventListener`.\n   */\n  protected _startPredicate: (e: PointerSensorSourceEvent) => boolean;\n\n  /**\n   * The options object to be used for `addEventListener`.\n   */\n  protected _listenerOptions: ListenerOptions;\n\n  /**\n   * Type of tracked source events.\n   */\n  protected _sourceEvents: keyof typeof SOURCE_EVENTS;\n\n  /**\n   * Indicator if window's listener's are bound.\n   */\n  protected _areWindowListenersBound: boolean;\n\n  /**\n   * Internal event emitter instance.\n   */\n  protected _emitter: Emitter<Events>;\n\n  constructor(element: Element | Window, options: Partial<PointerSensorSettings> = {}) {\n    const {\n      listenerOptions = {},\n      sourceEvents = 'auto',\n      startPredicate = (e) => ('button' in e && e.button > 0 ? false : true),\n    } = options;\n\n    this.element = element;\n    this.drag = null;\n    this.isDestroyed = false;\n\n    this._areWindowListenersBound = false;\n    this._startPredicate = startPredicate;\n    this._listenerOptions = parseListenerOptions(listenerOptions);\n    this._sourceEvents = parseSourceEvents(sourceEvents);\n    this._emitter = new Emitter();\n\n    this._onStart = this._onStart.bind(this);\n    this._onMove = this._onMove.bind(this);\n    this._onCancel = this._onCancel.bind(this);\n    this._onEnd = this._onEnd.bind(this);\n\n    // Listen to start event.\n    element.addEventListener(\n      SOURCE_EVENTS[this._sourceEvents].start,\n      this._onStart as EventListener,\n      this._listenerOptions,\n    );\n  }\n\n  /**\n   * Check if the provided event contains the tracked pointer id or in the case\n   * of touch event if the first changed touch is the tracked touch object and\n   * return the event or touch object. Otherwise return null.\n   */\n  protected _getTrackedPointerEventData(\n    e: PointerSensorSourceEvent,\n  ): PointerEvent | MouseEvent | Touch | null {\n    return this.drag ? getPointerEventData(e, this.drag.pointerId) : null;\n  }\n\n  /**\n   * Listener for start event.\n   */\n  protected _onStart(e: PointerSensorSourceEvent) {\n    if (this.isDestroyed || this.drag) return;\n\n    // Make sure start predicate is fulfilled.\n    if (!this._startPredicate(e)) return;\n\n    // Try to get pointer id.\n    const pointerId = getPointerId(e);\n    if (pointerId === null) return;\n\n    // Try to get pointer.\n    const pointerEventData = getPointerEventData(e, pointerId);\n    if (pointerEventData === null) return;\n\n    // Create drag data.\n    const dragData: PointerSensorDragData = {\n      pointerId,\n      pointerType: getPointerType(e),\n      x: pointerEventData.clientX,\n      y: pointerEventData.clientY,\n    };\n\n    // Set drag data.\n    (this as Writeable<this>).drag = dragData;\n\n    // Emit start event.\n    const eventData: PointerSensorStartEvent = {\n      ...dragData,\n      type: SensorEventType.start,\n      srcEvent: e,\n      target: pointerEventData.target,\n    };\n    this._emitter.emit(eventData.type, eventData);\n\n    // If the drag procedure was not reset within the start procedure let's\n    // activate the instance (start listening to move/cancel/end events).\n    if (this.drag) {\n      this._bindWindowListeners();\n    }\n  }\n\n  /**\n   * Listener for move event.\n   */\n  protected _onMove(e: PointerSensorSourceEvent) {\n    if (!this.drag) return;\n\n    const pointerEventData = this._getTrackedPointerEventData(e);\n    if (!pointerEventData) return;\n\n    (this.drag.x as Writeable<number>) = pointerEventData.clientX;\n    (this.drag.y as Writeable<number>) = pointerEventData.clientY;\n\n    const eventData: PointerSensorMoveEvent = {\n      type: SensorEventType.move,\n      srcEvent: e,\n      target: pointerEventData.target,\n      ...this.drag,\n    };\n\n    this._emitter.emit(eventData.type, eventData);\n  }\n\n  /**\n   * Listener for cancel event.\n   */\n  protected _onCancel(e: PointerEvent | TouchEvent) {\n    if (!this.drag) return;\n\n    const pointerEventData = this._getTrackedPointerEventData(e);\n    if (!pointerEventData) return;\n\n    (this.drag.x as Writeable<number>) = pointerEventData.clientX;\n    (this.drag.y as Writeable<number>) = pointerEventData.clientY;\n\n    const eventData: PointerSensorCancelEvent = {\n      type: SensorEventType.cancel,\n      srcEvent: e,\n      target: pointerEventData.target,\n      ...this.drag,\n    };\n\n    this._emitter.emit(eventData.type, eventData);\n\n    this._resetDrag();\n  }\n\n  /**\n   * Listener for end event.\n   */\n  protected _onEnd(e: PointerSensorSourceEvent) {\n    if (!this.drag) return;\n\n    const pointerEventData = this._getTrackedPointerEventData(e);\n    if (!pointerEventData) return;\n\n    (this.drag.x as Writeable<number>) = pointerEventData.clientX;\n    (this.drag.y as Writeable<number>) = pointerEventData.clientY;\n\n    const eventData: PointerSensorEndEvent = {\n      type: SensorEventType.end,\n      srcEvent: e,\n      target: pointerEventData.target,\n      ...this.drag,\n    };\n\n    this._emitter.emit(eventData.type, eventData);\n\n    this._resetDrag();\n  }\n\n  /**\n   * Bind window event listeners for move/end/cancel.\n   */\n  protected _bindWindowListeners() {\n    if (this._areWindowListenersBound) return;\n    const { move, end, cancel } = SOURCE_EVENTS[this._sourceEvents];\n    window.addEventListener(move, this._onMove, this._listenerOptions);\n    window.addEventListener(end, this._onEnd, this._listenerOptions);\n    if (cancel) {\n      window.addEventListener(cancel, this._onCancel, this._listenerOptions);\n    }\n    this._areWindowListenersBound = true;\n  }\n\n  /**\n   * Unbind window event listeners for move/end/cancel.\n   */\n  protected _unbindWindowListeners() {\n    if (this._areWindowListenersBound) {\n      const { move, end, cancel } = SOURCE_EVENTS[this._sourceEvents];\n      window.removeEventListener(move, this._onMove, this._listenerOptions);\n      window.removeEventListener(end, this._onEnd, this._listenerOptions);\n      if (cancel) {\n        window.removeEventListener(cancel, this._onCancel, this._listenerOptions);\n      }\n      this._areWindowListenersBound = false;\n    }\n  }\n\n  /**\n   * Reset drag data.\n   */\n  protected _resetDrag() {\n    (this as Writeable<this>).drag = null;\n    this._unbindWindowListeners();\n  }\n\n  /**\n   * Forcefully cancel the drag process.\n   */\n  cancel() {\n    if (!this.drag) return;\n\n    const eventData: PointerSensorCancelEvent = {\n      type: SensorEventType.cancel,\n      srcEvent: null,\n      target: null,\n      ...this.drag,\n    };\n\n    this._emitter.emit(eventData.type, eventData);\n\n    this._resetDrag();\n  }\n\n  /**\n   * Update the instance's settings.\n   */\n  updateSettings(options: Partial<PointerSensorSettings>) {\n    if (this.isDestroyed) return;\n\n    const { listenerOptions, sourceEvents, startPredicate } = options;\n    const nextSourceEvents = parseSourceEvents(sourceEvents);\n    const nextListenerOptions = parseListenerOptions(listenerOptions);\n\n    // Update start predicate if needed.\n    if (startPredicate && this._startPredicate !== startPredicate) {\n      this._startPredicate = startPredicate;\n    }\n\n    // Update listener options and/or source events if needed.\n    if (\n      (listenerOptions &&\n        (this._listenerOptions.capture !== nextListenerOptions.capture ||\n          this._listenerOptions.passive === nextListenerOptions.passive)) ||\n      (sourceEvents && this._sourceEvents !== nextSourceEvents)\n    ) {\n      // Unbind start listener.\n      this.element.removeEventListener(\n        SOURCE_EVENTS[this._sourceEvents].start,\n        this._onStart as EventListener,\n        this._listenerOptions,\n      );\n\n      // Unbind window listeners.\n      this._unbindWindowListeners();\n\n      // Cancel current drag process.\n      this.cancel();\n\n      // Update options to instace.\n      if (sourceEvents) {\n        this._sourceEvents = nextSourceEvents;\n      }\n      if (listenerOptions && nextListenerOptions) {\n        this._listenerOptions = nextListenerOptions;\n      }\n\n      // Rebind start listener with new options.\n      this.element.addEventListener(\n        SOURCE_EVENTS[this._sourceEvents].start,\n        this._onStart as EventListener,\n        this._listenerOptions,\n      );\n    }\n  }\n\n  /**\n   * Bind a drag event listener.\n   */\n  on<K extends keyof E>(\n    eventName: K,\n    listener: (e: E[K]) => void,\n    listenerId?: EventListenerId,\n  ): EventListenerId {\n    return this._emitter.on(eventName, listener, listenerId);\n  }\n\n  /**\n   * Unbind a drag event listener.\n   */\n  off<K extends keyof E>(eventName: K, listener: ((e: E[K]) => void) | EventListenerId): void {\n    this._emitter.off(eventName, listener);\n  }\n\n  /**\n   * Destroy the instance and unbind all drag event listeners.\n   */\n  destroy() {\n    if (this.isDestroyed) return;\n\n    // Mark as destroyed.\n    (this as Writeable<this>).isDestroyed = true;\n\n    // Cancel any ongoing drag process.\n    this.cancel();\n\n    // Emit destroy event.\n    this._emitter.emit(SensorEventType.destroy, {\n      type: SensorEventType.destroy,\n    });\n\n    // Destroy emitter.\n    this._emitter.off();\n\n    // Unbind start event listeners.\n    this.element.removeEventListener(\n      SOURCE_EVENTS[this._sourceEvents].start,\n      this._onStart as EventListener,\n      this._listenerOptions,\n    );\n  }\n}\n","export function getPointerEventData(\n  e: PointerEvent | TouchEvent | MouseEvent,\n  id: number,\n): PointerEvent | MouseEvent | Touch | null {\n  // If we have a pointer event return the whole event if there's a match, and\n  // null otherwise.\n  if ('pointerId' in e) {\n    return e.pointerId === id ? e : null;\n  }\n\n  // For touch events let's check if there's a changed touch object that matches\n  // the pointerId in which case return the touch object.\n  if ('changedTouches' in e) {\n    let i = 0;\n    for (; i < e.changedTouches.length; i++) {\n      if (e.changedTouches[i].identifier === id) {\n        return e.changedTouches[i];\n      }\n    }\n    return null;\n  }\n\n  // For mouse/other events let's assume there's only one pointer and just\n  // return the event.\n  return e;\n}\n","import { PointerType } from '../types.js';\n\nexport function getPointerType(e: PointerEvent | TouchEvent | MouseEvent): PointerType {\n  return 'pointerType' in e ? (e.pointerType as PointerType) : 'touches' in e ? 'touch' : 'mouse';\n}\n","export function getPointerId(e: PointerEvent | TouchEvent | MouseEvent) {\n  // If we have pointer id available let's use it.\n  if ('pointerId' in e) return e.pointerId;\n  // For touch events let's get the first changed touch's identifier.\n  if ('changedTouches' in e) return e.changedTouches[0] ? e.changedTouches[0].identifier : null;\n  // For mouse/other events let's provide a static id. And let's make it a\n  // negative number so it has it has not chance of clashing with touch/pointer\n  // ids.\n  return -1;\n}\n","import { HAS_PASSIVE_EVENTS } from '../constants.js';\n\nimport { ListenerOptions } from '../types.js';\n\nexport function parseListenerOptions(options: ListenerOptions = {}): ListenerOptions {\n  const { capture = true, passive = true } = options;\n  if (HAS_PASSIVE_EVENTS) {\n    return { capture, passive };\n  } else {\n    return { capture };\n  }\n}\n","export const IS_BROWSER = typeof window !== 'undefined' && typeof window.document !== 'undefined';\n\nexport const HAS_PASSIVE_EVENTS = (() => {\n  let isPassiveEventsSupported = false;\n  try {\n    const passiveOpts = Object.defineProperty({}, 'passive', {\n      get: function () {\n        isPassiveEventsSupported = true;\n      },\n    });\n    // @ts-ignore\n    window.addEventListener('testPassive', null, passiveOpts);\n    // @ts-ignore\n    window.removeEventListener('testPassive', null, passiveOpts);\n  } catch (e) {}\n  return isPassiveEventsSupported;\n})();\n\nexport const HAS_TOUCH_EVENTS = IS_BROWSER && 'ontouchstart' in window;\n\nexport const HAS_POINTER_EVENTS = IS_BROWSER && !!window.PointerEvent;\n\nexport const IS_SAFARI = !!(\n  IS_BROWSER &&\n  navigator.vendor &&\n  navigator.vendor.indexOf('Apple') > -1 &&\n  navigator.userAgent &&\n  navigator.userAgent.indexOf('CriOS') == -1 &&\n  navigator.userAgent.indexOf('FxiOS') == -1\n);\n","import { HAS_POINTER_EVENTS, HAS_TOUCH_EVENTS } from '../constants.js';\n\nexport function parseSourceEvents(\n  sourceEvents: 'pointer' | 'touch' | 'mouse' | 'auto' | undefined,\n): 'pointer' | 'touch' | 'mouse' {\n  return sourceEvents === 'auto' || sourceEvents === undefined\n    ? HAS_POINTER_EVENTS\n      ? 'pointer'\n      : HAS_TOUCH_EVENTS\n        ? 'touch'\n        : 'mouse'\n    : sourceEvents;\n}\n","import {\n  Sensor,\n  SensorStartEvent,\n  SensorMoveEvent,\n  SensorCancelEvent,\n  SensorEndEvent,\n  SensorDestroyEvent,\n} from './sensor.js';\n\nimport { BaseSensor } from './base-sensor.js';\n\nexport type KeyboardSensorPredicate = (\n  e: KeyboardEvent,\n  sensor: KeyboardSensor,\n  moveDistance: { x: number; y: number },\n) => { x: number; y: number } | null | undefined;\n\nexport interface KeyboardSensorSettings {\n  moveDistance: number | { x: number; y: number };\n  startPredicate: KeyboardSensorPredicate;\n  movePredicate: KeyboardSensorPredicate;\n  cancelPredicate: KeyboardSensorPredicate;\n  endPredicate: KeyboardSensorPredicate;\n}\n\nexport interface KeyboardSensorStartEvent extends SensorStartEvent {\n  srcEvent: KeyboardEvent;\n}\n\nexport interface KeyboardSensorMoveEvent extends SensorMoveEvent {\n  srcEvent: KeyboardEvent;\n}\n\nexport interface KeyboardSensorCancelEvent extends SensorCancelEvent {\n  srcEvent: KeyboardEvent;\n}\n\nexport interface KeyboardSensorEndEvent extends SensorEndEvent {\n  srcEvent: KeyboardEvent;\n}\n\nexport interface KeyboardSensorDestroyEvent extends SensorDestroyEvent {}\n\nexport interface KeyboardSensorEvents {\n  start: KeyboardSensorStartEvent;\n  move: KeyboardSensorMoveEvent;\n  cancel: KeyboardSensorCancelEvent;\n  end: KeyboardSensorEndEvent;\n  destroy: KeyboardSensorDestroyEvent;\n}\n\nexport class KeyboardSensor<E extends KeyboardSensorEvents = KeyboardSensorEvents>\n  extends BaseSensor<E>\n  implements Sensor<E>\n{\n  declare events: E;\n  protected _moveDistance: { x: number; y: number };\n  protected _startPredicate: KeyboardSensorPredicate;\n  protected _movePredicate: KeyboardSensorPredicate;\n  protected _cancelPredicate: KeyboardSensorPredicate;\n  protected _endPredicate: KeyboardSensorPredicate;\n\n  constructor(options: Partial<KeyboardSensorSettings> = {}) {\n    super();\n\n    const {\n      moveDistance = 25,\n      startPredicate = (e) => {\n        if (e.key === 'Enter' || e.key === ' ') {\n          if (document.activeElement && document.activeElement !== document.body) {\n            const { left, top } = document.activeElement.getBoundingClientRect();\n            return { x: left, y: top };\n          }\n        }\n        return null;\n      },\n      movePredicate = (e, sensor, moveDistance) => {\n        if (!sensor.drag) return null;\n\n        switch (e.key) {\n          case 'ArrowLeft': {\n            return {\n              x: sensor.drag.x - moveDistance.x,\n              y: sensor.drag.y,\n            };\n          }\n          case 'ArrowRight': {\n            return {\n              x: sensor.drag.x + moveDistance.x,\n              y: sensor.drag.y,\n            };\n          }\n          case 'ArrowUp': {\n            return {\n              x: sensor.drag.x,\n              y: sensor.drag.y - moveDistance.y,\n            };\n          }\n          case 'ArrowDown': {\n            return {\n              x: sensor.drag.x,\n              y: sensor.drag.y + moveDistance.y,\n            };\n          }\n          default: {\n            return null;\n          }\n        }\n      },\n      cancelPredicate = (e, sensor) => {\n        if (sensor.drag && e.key === 'Escape') {\n          return { x: sensor.drag.x, y: sensor.drag.y };\n        }\n        return null;\n      },\n      endPredicate = (e, sensor) => {\n        if (sensor.drag && (e.key === 'Enter' || e.key === ' ')) {\n          return { x: sensor.drag.x, y: sensor.drag.y };\n        }\n        return null;\n      },\n    } = options;\n\n    this._moveDistance =\n      typeof moveDistance === 'number' ? { x: moveDistance, y: moveDistance } : { ...moveDistance };\n    this._startPredicate = startPredicate;\n    this._movePredicate = movePredicate;\n    this._cancelPredicate = cancelPredicate;\n    this._endPredicate = endPredicate;\n\n    this.cancel = this.cancel.bind(this);\n    this._onKeyDown = this._onKeyDown.bind(this);\n\n    document.addEventListener('keydown', this._onKeyDown);\n    window.addEventListener('blur', this.cancel);\n    window.addEventListener('visibilitychange', this.cancel);\n  }\n\n  protected _onKeyDown(e: KeyboardEvent) {\n    // Handle start.\n    if (!this.drag) {\n      const startPosition = this._startPredicate(e, this, this._moveDistance);\n      if (startPosition) {\n        e.preventDefault();\n        this._start({\n          type: 'start',\n          x: startPosition.x,\n          y: startPosition.y,\n          srcEvent: e,\n        });\n      }\n      return;\n    }\n\n    // Handle cancel.\n    const cancelPosition = this._cancelPredicate(e, this, this._moveDistance);\n    if (cancelPosition) {\n      e.preventDefault();\n      this._cancel({\n        type: 'cancel',\n        x: cancelPosition.x,\n        y: cancelPosition.y,\n        srcEvent: e,\n      });\n      return;\n    }\n\n    // Handle end.\n    const endPosition = this._endPredicate(e, this, this._moveDistance);\n    if (endPosition) {\n      e.preventDefault();\n      this._end({\n        type: 'end',\n        x: endPosition.x,\n        y: endPosition.y,\n        srcEvent: e,\n      });\n      return;\n    }\n\n    // Handle move.\n    const movePosition = this._movePredicate(e, this, this._moveDistance);\n    if (movePosition) {\n      e.preventDefault();\n      this._move({\n        type: 'move',\n        x: movePosition.x,\n        y: movePosition.y,\n        srcEvent: e,\n      });\n      return;\n    }\n  }\n\n  updateSettings(options: Partial<KeyboardSensorSettings> = {}) {\n    if (options.moveDistance !== undefined) {\n      if (typeof options.moveDistance === 'number') {\n        this._moveDistance.x = options.moveDistance;\n        this._moveDistance.y = options.moveDistance;\n      } else {\n        this._moveDistance.x = options.moveDistance.x;\n        this._moveDistance.y = options.moveDistance.y;\n      }\n    }\n\n    if (options.startPredicate !== undefined) {\n      this._startPredicate = options.startPredicate;\n    }\n\n    if (options.movePredicate !== undefined) {\n      this._movePredicate = options.movePredicate;\n    }\n\n    if (options.cancelPredicate !== undefined) {\n      this._cancelPredicate = options.cancelPredicate;\n    }\n\n    if (options.endPredicate !== undefined) {\n      this._endPredicate = options.endPredicate;\n    }\n  }\n\n  destroy() {\n    if (this.isDestroyed) return;\n    super.destroy();\n    document.removeEventListener('keydown', this._onKeyDown);\n    window.removeEventListener('blur', this.cancel);\n    window.removeEventListener('visibilitychange', this.cancel);\n  }\n}\n","import { Sensor } from './sensor.js';\n\nimport { BaseMotionSensor, BaseMotionSensorEvents } from './base-motion-sensor.js';\n\nexport interface KeyboardMotionSensorSettings<\n  E extends KeyboardMotionSensorEvents = KeyboardMotionSensorEvents,\n> {\n  startPredicate: (\n    e: KeyboardEvent,\n    sensor: KeyboardMotionSensor<E>,\n  ) => { x: number; y: number } | null | undefined;\n  computeSpeed: (sensor: KeyboardMotionSensor<E>) => number;\n  startKeys: string[];\n  moveLeftKeys: string[];\n  moveRightKeys: string[];\n  moveUpKeys: string[];\n  moveDownKeys: string[];\n  cancelKeys: string[];\n  endKeys: string[];\n}\n\nexport interface KeyboardMotionSensorEvents extends BaseMotionSensorEvents {}\n\nconst KEY_TYPES = [\n  'start',\n  'cancel',\n  'end',\n  'moveLeft',\n  'moveRight',\n  'moveUp',\n  'moveDown',\n] as const;\n\nfunction getEarliestTimestamp(keys: Set<string>, timestamps: Map<string, number>) {\n  if (!keys.size || !timestamps.size) return Infinity;\n  let result = Infinity;\n  for (const key of keys) {\n    const timestamp = timestamps.get(key);\n    if (timestamp !== undefined && timestamp < result) {\n      result = timestamp;\n    }\n  }\n  return result;\n}\n\nexport class KeyboardMotionSensor<E extends KeyboardMotionSensorEvents = KeyboardMotionSensorEvents>\n  extends BaseMotionSensor<E>\n  implements Sensor<E>\n{\n  declare events: E;\n  protected _startPredicate: Exclude<KeyboardMotionSensorSettings<E>['startPredicate'], undefined>;\n  protected _computeSpeed: Exclude<KeyboardMotionSensorSettings<E>['computeSpeed'], undefined>;\n  protected _moveKeys: Set<string>;\n  protected _moveKeyTimestamps: Map<string, number>;\n  protected _startKeys: Set<string>;\n  protected _moveLeftKeys: Set<string>;\n  protected _moveRightKeys: Set<string>;\n  protected _moveUpKeys: Set<string>;\n  protected _moveDownKeys: Set<string>;\n  protected _cancelKeys: Set<string>;\n  protected _endKeys: Set<string>;\n\n  constructor(options: Partial<KeyboardMotionSensorSettings<E>> = {}) {\n    super();\n\n    const {\n      startPredicate = () => {\n        if (document.activeElement) {\n          const { left, top } = document.activeElement.getBoundingClientRect();\n          return { x: left, y: top };\n        }\n        return null;\n      },\n      computeSpeed = () => 500,\n      startKeys = [' ', 'Enter'],\n      moveLeftKeys = ['ArrowLeft'],\n      moveRightKeys = ['ArrowRight'],\n      moveUpKeys = ['ArrowUp'],\n      moveDownKeys = ['ArrowDown'],\n      cancelKeys = ['Escape'],\n      endKeys = [' ', 'Enter'],\n    } = options;\n\n    this._computeSpeed = computeSpeed;\n    this._startPredicate = startPredicate;\n    this._startKeys = new Set(startKeys);\n    this._cancelKeys = new Set(cancelKeys);\n    this._endKeys = new Set(endKeys);\n    this._moveLeftKeys = new Set(moveLeftKeys);\n    this._moveRightKeys = new Set(moveRightKeys);\n    this._moveUpKeys = new Set(moveUpKeys);\n    this._moveDownKeys = new Set(moveDownKeys);\n    this._moveKeys = new Set([...moveLeftKeys, ...moveRightKeys, ...moveUpKeys, ...moveDownKeys]);\n    this._moveKeyTimestamps = new Map();\n\n    this._onKeyDown = this._onKeyDown.bind(this);\n    this._onKeyUp = this._onKeyUp.bind(this);\n    this._onTick = this._onTick.bind(this);\n\n    this.on('tick', this._onTick);\n    document.addEventListener('keydown', this._onKeyDown);\n    document.addEventListener('keyup', this._onKeyUp);\n    window.addEventListener('blur', this.cancel);\n    window.addEventListener('visibilitychange', this.cancel);\n  }\n\n  protected _end(data: E['end']) {\n    if (!this.drag) return;\n    this._moveKeyTimestamps.clear();\n    this._direction.x = 0;\n    this._direction.y = 0;\n    super._end(data);\n  }\n\n  protected _cancel(data: E['cancel']) {\n    if (!this.drag) return;\n    this._moveKeyTimestamps.clear();\n    this._direction.x = 0;\n    this._direction.y = 0;\n    super._cancel(data);\n  }\n\n  protected _updateDirection() {\n    const leftTime = getEarliestTimestamp(this._moveLeftKeys, this._moveKeyTimestamps);\n    const rightTime = getEarliestTimestamp(this._moveRightKeys, this._moveKeyTimestamps);\n    const upTime = getEarliestTimestamp(this._moveUpKeys, this._moveKeyTimestamps);\n    const downTime = getEarliestTimestamp(this._moveDownKeys, this._moveKeyTimestamps);\n\n    let x = leftTime === rightTime ? 0 : leftTime < rightTime ? -1 : 1;\n    let y = upTime === downTime ? 0 : upTime < downTime ? -1 : 1;\n\n    // If the direction is NE/NW/SE/SW we need to normalize the direction\n    // vector.\n    if (!(x === 0 || y === 0)) {\n      const normFactor = 1 / (Math.sqrt(x * x + y * y) || 1);\n      x *= normFactor;\n      y *= normFactor;\n    }\n\n    this._direction.x = x;\n    this._direction.y = y;\n  }\n\n  protected _onTick() {\n    this._speed = this._computeSpeed(this);\n  }\n\n  protected _onKeyUp(e: KeyboardEvent) {\n    if (this._moveKeyTimestamps.get(e.key)) {\n      this._moveKeyTimestamps.delete(e.key);\n      this._updateDirection();\n    }\n  }\n\n  protected _onKeyDown(e: KeyboardEvent) {\n    // Handle start.\n    if (!this.drag) {\n      if (this._startKeys.has(e.key)) {\n        const startPosition = this._startPredicate(e, this);\n        if (startPosition) {\n          e.preventDefault();\n          this._start({\n            type: 'start',\n            x: startPosition.x,\n            y: startPosition.y,\n          });\n        }\n      }\n      return;\n    }\n\n    // Handle cancel.\n    if (this._cancelKeys.has(e.key)) {\n      e.preventDefault();\n      this._cancel({\n        type: 'cancel',\n        x: this.drag.x,\n        y: this.drag.y,\n      });\n      return;\n    }\n\n    // Handle end.\n    if (this._endKeys.has(e.key)) {\n      e.preventDefault();\n      this._end({\n        type: 'end',\n        x: this.drag.x,\n        y: this.drag.y,\n      });\n      return;\n    }\n\n    // Handle move.\n    if (this._moveKeys.has(e.key)) {\n      e.preventDefault();\n      if (!this._moveKeyTimestamps.get(e.key)) {\n        this._moveKeyTimestamps.set(e.key, Date.now());\n        this._updateDirection();\n      }\n      return;\n    }\n  }\n\n  updateSettings(options: Partial<KeyboardMotionSensorSettings<E>> = {}) {\n    let moveKeysMayNeedUpdate = false;\n\n    if (options.startPredicate !== undefined) {\n      this._startPredicate = options.startPredicate;\n    }\n\n    if (options.computeSpeed !== undefined) {\n      this._computeSpeed = options.computeSpeed;\n    }\n\n    KEY_TYPES.forEach((keyType, index) => {\n      const name = `${keyType}Keys` as const;\n      const value = options[name];\n      if (value !== undefined) {\n        this[`_${name}`] = new Set(value);\n        if (index >= 3) moveKeysMayNeedUpdate = true;\n      }\n    });\n\n    if (moveKeysMayNeedUpdate) {\n      // Construct the next move keys array.\n      const nextMoveKeys = [\n        ...this._moveLeftKeys,\n        ...this._moveRightKeys,\n        ...this._moveUpKeys,\n        ...this._moveDownKeys,\n      ];\n\n      // Check if the next move keys are equal to the current ones.\n      const areMoveKeysEqual = [...this._moveKeys].every(\n        (key, index) => nextMoveKeys[index] === key,\n      );\n\n      // Update move keys if needed.\n      if (!areMoveKeysEqual) {\n        this._moveKeys = new Set(nextMoveKeys);\n        this._moveKeyTimestamps.clear();\n        this._updateDirection();\n      }\n    }\n  }\n\n  destroy() {\n    if (this.isDestroyed) return;\n    super.destroy();\n    this.off('tick', this._onTick);\n    document.removeEventListener('keydown', this._onKeyDown);\n    document.removeEventListener('keyup', this._onKeyUp);\n    window.removeEventListener('blur', this.cancel);\n    window.removeEventListener('visibilitychange', this.cancel);\n  }\n}\n","import { HAS_PASSIVE_EVENTS } from '../constants.js';\n\nimport { Emitter, EventListenerId } from 'eventti';\n\nimport { Sensor, SensorEvents } from '../sensors/sensor.js';\n\nimport { DraggableDrag } from './draggable-drag.js';\n\nimport { DraggableDragItem } from './draggable-drag-item.js';\n\nimport { ticker, tickerReadPhase, tickerWritePhase } from '../singletons/ticker.js';\n\nimport { getOffsetDiff } from '../utils/get-offset-diff.js';\n\nimport { Writeable, CSSProperties } from '../types.js';\n\nconst SCROLL_LISTENER_OPTIONS = HAS_PASSIVE_EVENTS ? { capture: true, passive: true } : true;\n\nconst OFFSET_DIFF = { left: 0, top: 0 };\n\nconst POSITION_CHANGE = { x: 0, y: 0 };\n\nenum DraggableStartPredicateState {\n  PENDING = 0,\n  RESOLVED = 1,\n  REJECTED = 2,\n}\n\nfunction getDefaultSettings<S extends Sensor[], E extends S[number]['events']>(): DraggableSettings<\n  S,\n  E\n> {\n  return {\n    container: null,\n    startPredicate: () => true,\n    getElements: () => null,\n    releaseElements: () => null,\n    getFrozenProps: () => null,\n    getStartPosition: () => {\n      return { x: 0, y: 0 };\n    },\n    setPosition: ({ item, x, y }) => {\n      item.element.style.transform = `translate(${x}px, ${y}px) ${item.initialTransform}`;\n    },\n    getPositionChange: ({ event, prevEvent }) => {\n      POSITION_CHANGE.x = event.x - prevEvent.x;\n      POSITION_CHANGE.y = event.y - prevEvent.y;\n      return POSITION_CHANGE;\n    },\n  };\n}\n\nexport interface DraggableSettings<S extends Sensor[], E extends S[number]['events']> {\n  container: HTMLElement | null;\n  startPredicate: (data: {\n    draggable: Draggable<S, E>;\n    sensor: S[number];\n    event: E['start'] | E['move'];\n  }) => boolean | undefined;\n  getElements: (data: {\n    draggable: Draggable<S, E>;\n    sensor: S[number];\n    startEvent: E['start'] | E['move'];\n  }) => (HTMLElement | SVGSVGElement)[] | null;\n  releaseElements: (data: {\n    draggable: Draggable<S, E>;\n    sensor: S[number];\n    elements: (HTMLElement | SVGSVGElement)[];\n  }) => void;\n  getFrozenProps: (data: {\n    draggable: Draggable<S, E>;\n    sensor: S[number];\n    item: DraggableDragItem<S, E>;\n    style: CSSStyleDeclaration;\n  }) => CSSProperties | (keyof CSSProperties)[] | null;\n  getStartPosition: (data: {\n    draggable: Draggable<S, E>;\n    sensor: S[number];\n    item: DraggableDragItem<S, E>;\n    style: CSSStyleDeclaration;\n  }) => { x: number; y: number };\n  setPosition: (data: {\n    draggable: Draggable<S, E>;\n    sensor: S[number];\n    phase: 'start' | 'move' | 'end';\n    item: DraggableDragItem<S, E>;\n    x: number;\n    y: number;\n  }) => void;\n  getPositionChange: (data: {\n    draggable: Draggable<S, E>;\n    sensor: S[number];\n    item: DraggableDragItem<S, E>;\n    event: E['start'] | E['move'];\n    prevEvent: E['start'] | E['move'];\n    startEvent: E['start'] | E['move'];\n  }) => { x: number; y: number };\n}\n\nexport interface DraggablePlugin {\n  name: string;\n  version: string;\n}\n\nexport type DraggablePluginMap = Record<string, DraggablePlugin | undefined>;\n\nexport interface DraggableEventCallbacks<E extends SensorEvents> {\n  preparestart(event: E['start'] | E['move']): void;\n  start(event: E['start'] | E['move']): void;\n  preparemove(event: E['move']): void;\n  move(event: E['move']): void;\n  end(event: E['end'] | E['cancel'] | E['destroy'] | null): void;\n  destroy(): void;\n}\n\nexport class Draggable<\n  S extends Sensor[] = Sensor[],\n  E extends S[number]['events'] = S[number]['events'],\n  P extends DraggablePluginMap = {},\n> {\n  readonly sensors: S;\n  readonly settings: DraggableSettings<S, E>;\n  readonly plugins: P;\n  readonly drag: DraggableDrag<S, E> | null;\n  readonly isDestroyed: boolean;\n  protected _sensorData: Map<\n    S[number],\n    {\n      predicateState: DraggableStartPredicateState;\n      predicateEvent: E['start'] | E['move'] | null;\n      onMove: (e: Parameters<Draggable<S, E, P>['_onMove']>[0]) => void;\n      onEnd: (e: Parameters<Draggable<S, E, P>['_onEnd']>[0]) => void;\n    }\n  >;\n  protected _emitter: Emitter<{\n    [K in keyof DraggableEventCallbacks<E>]: DraggableEventCallbacks<E>[K];\n  }>;\n  protected _startId: symbol;\n  protected _moveId: symbol;\n  protected _updateId: symbol;\n\n  constructor(sensors: S, options: Partial<DraggableSettings<S, E>> = {}) {\n    this.sensors = sensors;\n    this.settings = this._parseSettings(options);\n    this.plugins = {} as P;\n    this.drag = null;\n    this.isDestroyed = false;\n\n    this._sensorData = new Map();\n    this._emitter = new Emitter();\n    this._startId = Symbol();\n    this._moveId = Symbol();\n    this._updateId = Symbol();\n\n    // Bind methods (that need binding).\n    this._onMove = this._onMove.bind(this);\n    this._onScroll = this._onScroll.bind(this);\n    this._onEnd = this._onEnd.bind(this);\n    this._prepareStart = this._prepareStart.bind(this);\n    this._applyStart = this._applyStart.bind(this);\n    this._prepareMove = this._prepareMove.bind(this);\n    this._applyMove = this._applyMove.bind(this);\n    this._preparePositionUpdate = this._preparePositionUpdate.bind(this);\n    this._applyPositionUpdate = this._applyPositionUpdate.bind(this);\n\n    // Bind drag sensor events.\n    this.sensors.forEach((sensor) => {\n      this._sensorData.set(sensor, {\n        predicateState: DraggableStartPredicateState.PENDING,\n        predicateEvent: null,\n        onMove: (e) => this._onMove(e, sensor),\n        onEnd: (e) => this._onEnd(e, sensor),\n      });\n      const { onMove, onEnd } = this._sensorData.get(sensor)!;\n      sensor.on('start', onMove);\n      sensor.on('move', onMove);\n      sensor.on('cancel', onEnd);\n      sensor.on('end', onEnd);\n      sensor.on('destroy', onEnd);\n    });\n  }\n\n  protected _parseSettings(\n    options?: Partial<this['settings']>,\n    defaults: this['settings'] = getDefaultSettings(),\n  ): this['settings'] {\n    const {\n      container = defaults.container,\n      startPredicate = defaults.startPredicate,\n      getElements = defaults.getElements,\n      releaseElements = defaults.releaseElements,\n      getFrozenProps = defaults.getFrozenProps,\n      getStartPosition = defaults.getStartPosition,\n      setPosition = defaults.setPosition,\n      getPositionChange = defaults.getPositionChange,\n    } = options || {};\n\n    return {\n      container,\n      startPredicate,\n      getElements,\n      releaseElements,\n      getFrozenProps,\n      getStartPosition,\n      setPosition,\n      getPositionChange,\n    };\n  }\n\n  protected _emit<K extends keyof DraggableEventCallbacks<E>>(\n    type: K,\n    ...e: Parameters<DraggableEventCallbacks<E>[K]>\n  ) {\n    this._emitter.emit(type, ...e);\n  }\n\n  protected _onMove(e: E['start'] | E['move'], sensor: S[number]) {\n    const sensorData = this._sensorData.get(sensor);\n    if (!sensorData) return;\n\n    switch (sensorData.predicateState) {\n      case DraggableStartPredicateState.PENDING: {\n        sensorData.predicateEvent = e;\n\n        // Check if drag should start.\n        const shouldStart = this.settings.startPredicate({\n          draggable: this,\n          sensor,\n          event: e,\n        });\n\n        // Resolve procedure (start move process).\n        if (shouldStart === true) {\n          this.resolveStartPredicate(sensor);\n        }\n        // Reject procedure.\n        else if (shouldStart === false) {\n          this.rejectStartPredicate(sensor);\n        }\n        break;\n      }\n      case DraggableStartPredicateState.RESOLVED: {\n        // Move the element if dragging is active.\n        if (this.drag) {\n          (this.drag as Writeable<DraggableDrag<S, E>>).event = e;\n          ticker.once(tickerReadPhase, this._prepareMove, this._moveId);\n          ticker.once(tickerWritePhase, this._applyMove, this._moveId);\n        }\n        break;\n      }\n    }\n  }\n\n  protected _onScroll() {\n    this.updatePosition();\n  }\n\n  protected _onEnd(e: E['end'] | E['cancel'] | E['destroy'], sensor: S[number]) {\n    const sensorData = this._sensorData.get(sensor);\n    if (!sensorData) return;\n\n    // If there is no active drag yet, let's reset the sensor's start predicate\n    // so that it can try starting drag again.\n    if (!this.drag) {\n      sensorData.predicateState = DraggableStartPredicateState.PENDING;\n      sensorData.predicateEvent = null;\n    }\n    // Otherwise, if drag is active AND the sensor is the one that triggered the\n    // drag process, let's reset all sensors' start preidcate states.\n    else if (sensorData.predicateState === DraggableStartPredicateState.RESOLVED) {\n      (this.drag as Writeable<DraggableDrag<S, E>>).endEvent = e;\n      this._sensorData.forEach((data) => {\n        data.predicateState = DraggableStartPredicateState.PENDING;\n        data.predicateEvent = null;\n      });\n      this.stop();\n    }\n  }\n\n  protected _prepareStart() {\n    const drag: Writeable<DraggableDrag<S, E>> | null = this.drag;\n    if (!drag) return;\n\n    // Get elements that we'll need to move with the drag.\n    // NB: It is okay if there are no elements and thus no items. The drag\n    // process will process as usual, but nothing is moving by default.\n    const elements =\n      this.settings.getElements({\n        draggable: this,\n        sensor: drag.sensor,\n        startEvent: drag.startEvent,\n      }) || [];\n\n    // Create drag items.\n    drag.items = elements.map((element) => {\n      return new DraggableDragItem(element, this);\n    });\n\n    // Emit preparestart event.\n    this._emit('preparestart', drag.startEvent);\n  }\n\n  protected _applyStart() {\n    const drag: Writeable<DraggableDrag<S, E>> | null = this.drag;\n    if (!drag) return;\n\n    const { container } = this.settings;\n    for (const item of drag.items as Writeable<DraggableDragItem<S, E>>[]) {\n      // Append element within the container element if such is provided.\n      if (container && item.element.parentElement !== container) {\n        container.appendChild(item.element);\n        item.position.x += item._containerDiff.x;\n        item.position.y += item._containerDiff.y;\n      }\n\n      // Freeze element's props if such are provided.\n      if (item.frozenProps) {\n        Object.assign(item.element.style, item.frozenProps);\n      }\n\n      // Set the element's start position.\n      this.settings.setPosition({\n        phase: 'start',\n        draggable: this,\n        sensor: drag.sensor,\n        item: item as DraggableDragItem<S, E>,\n        x: item.position.x,\n        y: item.position.y,\n      });\n    }\n\n    // Bind scroll listeners.\n    window.addEventListener('scroll', this._onScroll, SCROLL_LISTENER_OPTIONS);\n\n    // Emit start event.\n    this._emit('start', drag.startEvent);\n  }\n\n  protected _prepareMove() {\n    const drag: Writeable<DraggableDrag<S, E>> | null = this.drag;\n    if (!drag) return;\n\n    // Get next event and previous event so we can compute the movement\n    // difference between the clientX/Y values.\n    const { event, prevEvent, startEvent, sensor } = drag;\n    if (event === prevEvent) return;\n\n    for (const item of drag.items as Writeable<DraggableDragItem<S, E>>[]) {\n      // Compute how much x and y needs to be transformed.\n      const { x: changeX, y: changeY } = this.settings.getPositionChange({\n        draggable: this,\n        sensor,\n        item: item as DraggableDragItem<S, E>,\n        event,\n        prevEvent,\n        startEvent,\n      });\n\n      // Update horizontal position data.\n      if (changeX) {\n        item.position.x += changeX;\n        item.clientRect.left += changeX;\n        item._moveDiff.x += changeX;\n      }\n\n      // Update vertical position data.\n      if (changeY) {\n        item.position.y += changeY;\n        item.clientRect.top += changeY;\n        item._moveDiff.y += changeY;\n      }\n    }\n\n    // Store next event as previous event.\n    (drag as Writeable<DraggableDrag<S, E>>).prevEvent = event;\n\n    // Emit preparemove event.\n    this._emit('preparemove', event as E['move']);\n  }\n\n  protected _applyMove() {\n    const drag: Writeable<DraggableDrag<S, E>> | null = this.drag;\n    if (!drag) return;\n\n    // Reset movement diff and move the element.\n    for (const item of drag.items as Writeable<DraggableDragItem<S, E>>[]) {\n      item._moveDiff.x = 0;\n      item._moveDiff.y = 0;\n\n      this.settings.setPosition({\n        phase: 'move',\n        draggable: this,\n        sensor: drag.sensor,\n        item: item as DraggableDragItem<S, E>,\n        x: item.position.x,\n        y: item.position.y,\n      });\n    }\n\n    // Emit move event.\n    if (drag.event) {\n      this._emit('move', drag.event as E['move']);\n    }\n  }\n\n  protected _preparePositionUpdate() {\n    const { drag } = this;\n    if (!drag) return;\n\n    for (const item of drag.items as Writeable<DraggableDragItem<S, E>>[]) {\n      // Update container diff.\n      if (item.elementOffsetContainer !== item.dragOffsetContainer) {\n        const { left, top } = getOffsetDiff(\n          item.dragOffsetContainer,\n          item.elementOffsetContainer,\n          OFFSET_DIFF,\n        );\n        item._containerDiff.x = left;\n        item._containerDiff.y = top;\n      }\n\n      const { left, top, width, height } = item.element.getBoundingClientRect();\n\n      // Update horizontal position data.\n      const updateDiffX = item.clientRect.left - item._moveDiff.x - left;\n      item.position.x = item.position.x - item._updateDiff.x + updateDiffX;\n      item._updateDiff.x = updateDiffX;\n\n      // Update vertical position data.\n      const updateDiffY = item.clientRect.top - item._moveDiff.y - top;\n      item.position.y = item.position.y - item._updateDiff.y + updateDiffY;\n      item._updateDiff.y = updateDiffY;\n\n      // Update item client size. This is not necessary for the drag process,\n      // but since we're computing the bounding client rect, we might as well\n      // update the size in the process. The size is used by the auto-scroll\n      // plugin and possibly some other third-party plugins.\n      item.clientRect.width = width;\n      item.clientRect.height = height;\n    }\n  }\n\n  protected _applyPositionUpdate() {\n    const { drag } = this;\n    if (!drag) return;\n\n    for (const item of drag.items as Writeable<DraggableDragItem<S, E>>[]) {\n      item._updateDiff.x = 0;\n      item._updateDiff.y = 0;\n\n      this.settings.setPosition({\n        phase: 'move',\n        draggable: this,\n        sensor: drag.sensor,\n        item: item as DraggableDragItem<S, E>,\n        x: item.position.x,\n        y: item.position.y,\n      });\n    }\n  }\n\n  on<K extends keyof DraggableEventCallbacks<E>>(\n    eventName: K,\n    listener: DraggableEventCallbacks<E>[K],\n    listenerId?: EventListenerId,\n  ): EventListenerId {\n    return this._emitter.on(eventName, listener, listenerId);\n  }\n\n  off<K extends keyof DraggableEventCallbacks<E>>(\n    eventName: K,\n    listener: DraggableEventCallbacks<E>[K] | EventListenerId,\n  ): void {\n    this._emitter.off(eventName, listener);\n  }\n\n  resolveStartPredicate(sensor: S[number], e?: E['start'] | E['move']) {\n    const sensorData = this._sensorData.get(sensor);\n    if (!sensorData) return;\n\n    const startEvent = e || sensorData.predicateEvent;\n\n    if (sensorData.predicateState === DraggableStartPredicateState.PENDING && startEvent) {\n      // Resolve the provided sensor's start predicate.\n      sensorData.predicateState = DraggableStartPredicateState.RESOLVED;\n      sensorData.predicateEvent = null;\n\n      (this as Writeable<this>).drag = new DraggableDrag(sensor, startEvent);\n\n      // Reject other sensors' start predicates.\n      this._sensorData.forEach((data, s) => {\n        if (s === sensor) return;\n        data.predicateState = DraggableStartPredicateState.REJECTED;\n        data.predicateEvent = null;\n      });\n\n      // Queue drag start.\n      ticker.once(tickerReadPhase, this._prepareStart, this._startId);\n      ticker.once(tickerWritePhase, this._applyStart, this._startId);\n    }\n  }\n\n  rejectStartPredicate(sensor: S[number]) {\n    const sensorData = this._sensorData.get(sensor);\n    if (sensorData?.predicateState === DraggableStartPredicateState.PENDING) {\n      sensorData.predicateState = DraggableStartPredicateState.REJECTED;\n      sensorData.predicateEvent = null;\n    }\n  }\n\n  stop() {\n    const drag: Writeable<DraggableDrag<S, E>> | null = this.drag;\n    if (!drag || drag.isEnded) return;\n\n    // Mark drag process as ended.\n    drag.isEnded = true;\n\n    // Cancel all queued ticks.\n    ticker.off(tickerReadPhase, this._startId);\n    ticker.off(tickerWritePhase, this._startId);\n    ticker.off(tickerReadPhase, this._moveId);\n    ticker.off(tickerWritePhase, this._moveId);\n    ticker.off(tickerReadPhase, this._updateId);\n    ticker.off(tickerWritePhase, this._updateId);\n\n    // Unbind scroll listener.\n    window.removeEventListener('scroll', this._onScroll, SCROLL_LISTENER_OPTIONS);\n\n    // Move elements within the root container and collect all elements\n    // to an elements array.\n    const elements: (HTMLElement | SVGSVGElement)[] = [];\n    for (const item of drag.items as Writeable<DraggableDragItem<S, E>>[]) {\n      elements.push(item.element);\n      if (item.elementContainer && item.element.parentElement !== item.elementContainer) {\n        item.position.x -= item._containerDiff.x;\n        item.position.y -= item._containerDiff.y;\n        item._containerDiff.x = 0;\n        item._containerDiff.y = 0;\n        item.elementContainer.appendChild(item.element);\n      }\n\n      // Unfreeze element's props if such are provided.\n      if (item.unfrozenProps) {\n        for (const key in item.unfrozenProps) {\n          item.element.style[key] = item.unfrozenProps[key] || '';\n        }\n      }\n\n      // Set final position after drag.\n      this.settings.setPosition({\n        phase: 'end',\n        draggable: this,\n        sensor: drag.sensor,\n        item: item as DraggableDragItem<S, E>,\n        x: item.position.x,\n        y: item.position.y,\n      });\n    }\n\n    // Call \"releaseElements\" callback.\n    if (elements.length) {\n      this.settings.releaseElements({\n        draggable: this,\n        sensor: drag.sensor!,\n        elements,\n      });\n    }\n\n    // Emit end event.\n    this._emit('end', drag.endEvent);\n\n    // Reset drag data.\n    (this as Writeable<this>).drag = null;\n  }\n\n  updatePosition(instant = false) {\n    if (!this.drag) return;\n    if (instant) {\n      this._preparePositionUpdate();\n      this._applyPositionUpdate();\n    } else {\n      ticker.once(tickerReadPhase, this._preparePositionUpdate, this._updateId);\n      ticker.once(tickerWritePhase, this._applyPositionUpdate, this._updateId);\n    }\n  }\n\n  updateSettings(options: Partial<this['settings']> = {}) {\n    (this as Writeable<this>).settings = this._parseSettings(options, this.settings);\n  }\n\n  use<SS extends S, EE extends SS[number]['events'], PP extends P>(\n    plugin: (draggable: this) => Draggable<SS, EE, PP>,\n  ) {\n    return plugin(this);\n  }\n\n  destroy() {\n    if (this.isDestroyed) return;\n    (this as Writeable<this>).isDestroyed = true;\n\n    this.stop();\n\n    this._sensorData.forEach(({ onMove, onEnd }, sensor) => {\n      sensor.off('start', onMove);\n      sensor.off('move', onMove);\n      sensor.off('cancel', onEnd);\n      sensor.off('end', onEnd);\n      sensor.off('destroy', onEnd);\n    });\n\n    this._sensorData.clear();\n\n    this._emit('destroy');\n\n    this._emitter.off();\n  }\n}\n","import { Sensor } from '../sensors/sensor.js';\n\nimport { DraggableDragItem } from './draggable-drag-item.js';\n\nexport class DraggableDrag<S extends Sensor[], E extends S[number]['events']> {\n  readonly sensor: S[number];\n  readonly isEnded: boolean;\n  readonly event: E['start'] | E['move'];\n  readonly prevEvent: E['start'] | E['move'];\n  readonly startEvent: E['start'] | E['move'];\n  readonly endEvent: E['end'] | E['cancel'] | E['destroy'] | null;\n  readonly items: DraggableDragItem[];\n\n  constructor(sensor: S[number], startEvent: E['start'] | E['move']) {\n    this.sensor = sensor;\n    this.isEnded = false;\n    this.event = startEvent;\n    this.prevEvent = startEvent;\n    this.startEvent = startEvent;\n    this.endEvent = null;\n    this.items = [];\n  }\n}\n","import { getOffsetContainer } from 'mezr';\nimport { Sensor } from '../sensors/sensor.js';\nimport type { Draggable } from './draggable.js';\nimport { CSSProperties, Rect } from '../types.js';\nimport { getStyle } from 'utils/get-style.js';\nimport { getOffsetDiff } from 'utils/get-offset-diff.js';\n\nconst OFFSET_DIFF = { left: 0, top: 0 };\n\nconst IDENTITY_MATRIX = 'matrix(1, 0, 0, 1, 0, 0)';\n\nconst IDENTITY_MATRIX_3D = 'matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)';\n\nexport class DraggableDragItem<\n  S extends Sensor[] = Sensor[],\n  E extends S[number]['events'] = S[number]['events'],\n> {\n  data: { [key: string]: any };\n  readonly element: HTMLElement | SVGSVGElement;\n  readonly elementContainer: HTMLElement;\n  readonly elementOffsetContainer: HTMLElement | SVGSVGElement | Window | Document;\n  readonly dragContainer: HTMLElement;\n  readonly dragOffsetContainer: HTMLElement | SVGSVGElement | Window | Document;\n  readonly initialTransform: string;\n  readonly frozenProps: CSSProperties | null;\n  readonly unfrozenProps: CSSProperties | null;\n  readonly clientRect: Rect;\n  readonly position: { x: number; y: number };\n  readonly _updateDiff: { x: number; y: number };\n  readonly _moveDiff: { x: number; y: number };\n  readonly _containerDiff: { x: number; y: number };\n\n  constructor(element: HTMLElement | SVGSVGElement, draggable: Draggable<S, E>) {\n    // Make sure the element is in DOM.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected\n    if (!element.isConnected) {\n      throw new Error('Element is not connected');\n    }\n\n    // Make sure sensor is defined.\n    const sensor = draggable.drag?.sensor;\n    if (!sensor) {\n      throw new Error('Sensor is not defined');\n    }\n\n    const item = this;\n    const style = getStyle(element);\n    const clientRect = element.getBoundingClientRect();\n\n    this.data = {};\n    this.element = element;\n    this.frozenProps = null;\n    this.unfrozenProps = null;\n    this.position = { x: 0, y: 0 };\n    this._updateDiff = { x: 0, y: 0 };\n    this._moveDiff = { x: 0, y: 0 };\n    this._containerDiff = { x: 0, y: 0 };\n\n    // Use element's parent element as the element container.\n    const elementContainer = element.parentElement;\n    if (!elementContainer) {\n      throw new Error('Element does not have a parent element.');\n    }\n    this.elementContainer = elementContainer;\n\n    // Compute element's offset container.\n    const elementOffsetContainer = getOffsetContainer(element);\n    if (!elementOffsetContainer) {\n      throw new Error('Offset container could not be computed for the element!');\n    }\n    this.elementOffsetContainer = elementOffsetContainer;\n\n    // Get element's drag parent, default to element's parent element.\n    const dragContainer = draggable.settings.container || elementContainer;\n    this.dragContainer = dragContainer;\n\n    // Get drag container's offset container.\n    const dragOffsetContainer =\n      dragContainer === elementContainer\n        ? elementOffsetContainer\n        : getOffsetContainer(element, { container: dragContainer });\n    if (!dragOffsetContainer) {\n      throw new Error('Drag offset container could not be computed for the element!');\n    }\n    this.dragOffsetContainer = dragOffsetContainer;\n\n    // Store element's client rect.\n    {\n      const { left, top, width, height } = clientRect;\n      this.clientRect = { left, top, width, height };\n    }\n\n    // If element's offset container is different than drag container's\n    // offset container let's compute the offset between the offset containers.\n    if (elementOffsetContainer !== dragOffsetContainer) {\n      const { left, top } = getOffsetDiff(dragOffsetContainer, elementOffsetContainer, OFFSET_DIFF);\n      this._containerDiff.x = left;\n      this._containerDiff.y = top;\n    }\n\n    // Store element's initial transform.\n    const { transform } = style;\n    if (\n      transform &&\n      transform !== 'none' &&\n      transform !== IDENTITY_MATRIX &&\n      transform !== IDENTITY_MATRIX_3D\n    ) {\n      this.initialTransform = transform;\n    } else {\n      this.initialTransform = '';\n    }\n\n    // Get element's initial position. This position is relative to the\n    // properties the user is using to move the element. For example, if the\n    // user is using the `translate` transform to move the element then the\n    // initial position will be relative to the `translate` transform and the\n    // position here should reflect the transform value delta.\n    const { x, y } = draggable.settings.getStartPosition({\n      draggable,\n      sensor,\n      item,\n      style,\n    });\n    this.position.x = x;\n    this.position.y = y;\n\n    // Get element's frozen props.\n    const frozenProps = draggable.settings.getFrozenProps({\n      draggable,\n      sensor,\n      item,\n      style,\n    });\n    if (Array.isArray(frozenProps)) {\n      if (frozenProps.length) {\n        const props: CSSProperties = {};\n        for (const prop of frozenProps) {\n          props[prop] = style[prop];\n        }\n        this.frozenProps = props;\n      } else {\n        this.frozenProps = null;\n      }\n    } else {\n      this.frozenProps = frozenProps;\n    }\n\n    // Lastly, let's compute the unfrozen props. We store the current inline\n    // style values for all frozen props so that we can restore them after the\n    // drag process is over.\n    if (this.frozenProps) {\n      const unfrozenProps: CSSProperties = {};\n      for (const key in this.frozenProps) {\n        if (this.frozenProps.hasOwnProperty(key)) {\n          unfrozenProps[key] = element.style[key];\n        }\n      }\n      this.unfrozenProps = unfrozenProps;\n    }\n  }\n\n  updateSize(dimensions?: { width: number; height: number }) {\n    if (dimensions) {\n      this.clientRect.width = dimensions.width;\n      this.clientRect.height = dimensions.height;\n    } else {\n      const rect = this.element.getBoundingClientRect();\n      this.clientRect.width = rect.width;\n      this.clientRect.height = rect.height;\n    }\n  }\n}\n","export*from\"./getContainingBlock.js\";export*from\"./getDistance.js\";export*from\"./getHeight.js\";export*from\"./getIntersection.js\";export*from\"./getOffset.js\";export*from\"./getOffsetContainer.js\";export*from\"./getOverflow.js\";export*from\"./getRect.js\";export*from\"./getWidth.js\";","import{getStyle}from\"./utils/getStyle.js\";import{isContainingBlockForFixedElement}from\"./utils/isContainingBlockForFixedElement.js\";import{isContainingBlockForAbsoluteElement}from\"./utils/isContainingBlockForAbsoluteElement.js\";import{isBlockElement}from\"./utils/isBlockElement.js\";import{isDocumentElement}from\"./utils/isDocumentElement.js\";export function getContainingBlock(e,t={}){if(isDocumentElement(e))return e.ownerDocument.defaultView;const n=t.position||getStyle(e).position,{skipDisplayNone:i,container:o}=t;switch(n){case\"static\":case\"relative\":case\"sticky\":case\"-webkit-sticky\":{let t=o||e.parentElement;for(;t;){const e=isBlockElement(t);if(e)return t;if(null===e&&!i)return null;t=t.parentElement}return e.ownerDocument.documentElement}case\"absolute\":case\"fixed\":{const t=\"fixed\"===n;let l=o||e.parentElement;for(;l;){const e=t?isContainingBlockForFixedElement(l):isContainingBlockForAbsoluteElement(l);if(!0===e)return l;if(null===e&&!i)return null;l=l.parentElement}return e.ownerDocument.defaultView}default:return null}}","const STYLE_DECLARATION_CACHE=new WeakMap;export function getStyle(e,t){if(t)return window.getComputedStyle(e,t);let C=STYLE_DECLARATION_CACHE.get(e)?.deref();return C||(C=window.getComputedStyle(e,null),STYLE_DECLARATION_CACHE.set(e,new WeakRef(C))),C}","import{IS_SAFARI}from\"./constants.js\";import{getStyle}from\"./getStyle.js\";import{isBlockElement}from\"./isBlockElement.js\";export function isContainingBlockForFixedElement(n){const t=getStyle(n);if(!IS_SAFARI){const{filter:n}=t;if(n&&\"none\"!==n)return!0;const{backdropFilter:e}=t;if(e&&\"none\"!==e)return!0;const{willChange:i}=t;if(i&&(i.indexOf(\"filter\")>-1||i.indexOf(\"backdrop-filter\")>-1))return!0}const e=isBlockElement(n);if(!e)return e;const{transform:i}=t;if(i&&\"none\"!==i)return!0;const{perspective:r}=t;if(r&&\"none\"!==r)return!0;const{contentVisibility:o}=t;if(o&&\"auto\"===o)return!0;const{contain:f}=t;if(f&&(\"strict\"===f||\"content\"===f||f.indexOf(\"paint\")>-1||f.indexOf(\"layout\")>-1))return!0;const{willChange:c}=t;return!(!c||!(c.indexOf(\"transform\")>-1||c.indexOf(\"perspective\")>-1||c.indexOf(\"contain\")>-1))||!!(IS_SAFARI&&c&&c.indexOf(\"filter\")>-1)}","export const IS_BROWSER=\"undefined\"!=typeof window&&void 0!==window.document;export const IS_SAFARI=!!(IS_BROWSER&&navigator.vendor&&navigator.vendor.indexOf(\"Apple\")>-1&&navigator.userAgent&&-1==navigator.userAgent.indexOf(\"CriOS\")&&-1==navigator.userAgent.indexOf(\"FxiOS\"));export const BOX_EDGE={content:\"content\",padding:\"padding\",scrollbar:\"scrollbar\",border:\"border\",margin:\"margin\"};export const INCLUDE_WINDOW_SCROLLBAR={[BOX_EDGE.content]:!1,[BOX_EDGE.padding]:!1,[BOX_EDGE.scrollbar]:!0,[BOX_EDGE.border]:!0,[BOX_EDGE.margin]:!0};export const SCROLLABLE_OVERFLOWS=new Set([\"auto\",\"scroll\"]);export const IS_CHROMIUM=(()=>{try{return window.navigator.userAgentData.brands.some((({brand:n})=>\"Chromium\"===n))}catch(n){return!1}})();","import{getStyle}from\"./getStyle.js\";export function isBlockElement(e){switch(getStyle(e).display){case\"none\":return null;case\"inline\":case\"contents\":return!1;default:return!0}}","import{getStyle}from\"./getStyle.js\";import{isContainingBlockForFixedElement}from\"./isContainingBlockForFixedElement.js\";export function isContainingBlockForAbsoluteElement(t){return\"static\"!==getStyle(t).position||isContainingBlockForFixedElement(t)}","export function isDocumentElement(e){return e instanceof HTMLHtmlElement}","import{getDistanceBetweenRects}from\"./utils/getDistanceBetweenRects.js\";import{getNormalizedRect}from\"./utils/getNormalizedRect.js\";export function getDistance(e,t){const c=getNormalizedRect(e),i=getNormalizedRect(t);return getDistanceBetweenRects(c,i)}","import{isIntersecting}from\"./isIntersecting.js\";import{getDistanceBetweenPoints}from\"./getDistanceBetweenPoints.js\";export function getDistanceBetweenRects(t,e){if(isIntersecting(t,e))return null;const n=t.left+t.width,i=t.top+t.height,o=e.left+e.width,s=e.top+e.height;return n<=e.left?i<=e.top?getDistanceBetweenPoints(n,i,e.left,e.top):t.top>=s?getDistanceBetweenPoints(n,t.top,e.left,s):e.left-n:t.left>=o?i<=e.top?getDistanceBetweenPoints(t.left,i,o,e.top):t.top>=s?getDistanceBetweenPoints(t.left,t.top,o,s):t.left-o:i<=e.top?e.top-i:t.top-s}","export function isIntersecting(t,e){return!(t.left+t.width<=e.left||e.left+e.width<=t.left||t.top+t.height<=e.top||e.top+e.height<=t.top)}","export function getDistanceBetweenPoints(t,e,n,o){return Math.sqrt(Math.pow(n-t,2)+Math.pow(o-e,2))}","import{getRect}from\"../getRect.js\";import{isRectObject}from\"./isRectObject.js\";export function getNormalizedRect(t){return isRectObject(t)?t:getRect(t)}","import{getWidth}from\"./getWidth.js\";import{getHeight}from\"./getHeight.js\";import{getOffset}from\"./getOffset.js\";import{isRectObject}from\"./utils/isRectObject.js\";export function getRect(t,e){let i=0,g=0;isRectObject(t)?(i=t.width,g=t.height):Array.isArray(t)?(i=getWidth(...t),g=getHeight(...t)):(i=getWidth(t),g=getHeight(t));const r=getOffset(t,e);return{width:i,height:g,...r,right:r.left+i,bottom:r.top+g}}","import{INCLUDE_WINDOW_SCROLLBAR,BOX_EDGE}from\"./utils/constants.js\";import{isWindow}from\"./utils/isWindow.js\";import{isDocument}from\"./utils/isDocument.js\";import{getWindowWidth}from\"./utils/getWindowWidth.js\";import{getDocumentWidth}from\"./utils/getDocumentWidth.js\";import{getElementWidth}from\"./utils/getElementWidth.js\";export function getWidth(t,i=BOX_EDGE.border){return isWindow(t)?getWindowWidth(t,INCLUDE_WINDOW_SCROLLBAR[i]):isDocument(t)?getDocumentWidth(t):getElementWidth(t,i)}","export function isWindow(n){return n instanceof Window}","export function isDocument(n){return n instanceof Document}","import{getPreciseScrollbarSize}from\"./getPreciseScrollbarSize.js\";export function getWindowWidth(e,r=!1){if(r)return e.innerWidth;const{innerWidth:t,document:i}=e,{documentElement:n}=i,{clientWidth:c}=n;return t-getPreciseScrollbarSize(n,\"y\",t-c)}","import{IS_CHROMIUM}from\"./constants.js\";import{getStyle}from\"./getStyle.js\";const SUBPIXEL_OFFSET=new Map;let testStyleElement=null,testParentElement=null,testChildElement=null;function getSubpixelScrollbarSize(t,e){const n=t.split(\".\");let l=SUBPIXEL_OFFSET.get(n[1]);if(void 0===l){testStyleElement||(testStyleElement=document.createElement(\"style\")),testStyleElement.innerHTML=`\\n      #mezr-scrollbar-test::-webkit-scrollbar {\\n        width: ${t} !important;\\n      }\\n    `,testParentElement&&testChildElement||(testParentElement=document.createElement(\"div\"),testChildElement=document.createElement(\"div\"),testParentElement.appendChild(testChildElement),testParentElement.id=\"mezr-scrollbar-test\",testParentElement.style.cssText=\"\\n        all: unset !important;\\n        position: fixed !important;\\n        top: -200px !important;\\n        left: 0px !important;\\n        width: 100px !important;\\n        height: 100px !important;\\n        overflow: scroll !important;\\n        pointer-events: none !important;\\n        visibility: hidden !important;\\n      \",testChildElement.style.cssText=\"\\n        all: unset !important;\\n        position: absolute !important;\\n        inset: 0 !important;\\n      \"),document.body.appendChild(testStyleElement),document.body.appendChild(testParentElement);l=testParentElement.getBoundingClientRect().width-testChildElement.getBoundingClientRect().width-e,SUBPIXEL_OFFSET.set(n[1],l),document.body.removeChild(testParentElement),document.body.removeChild(testStyleElement)}return e+l}export function getPreciseScrollbarSize(t,e,n){if(n<=0)return 0;if(IS_CHROMIUM){const n=getStyle(t,\"::-webkit-scrollbar\"),l=\"x\"===e?n.height:n.width,i=parseFloat(l);if(!Number.isNaN(i)&&!Number.isInteger(i))return getSubpixelScrollbarSize(l,i)}return n}","export function getDocumentWidth({documentElement:t}){return Math.max(t.scrollWidth,t.clientWidth,t.getBoundingClientRect().width)}","import{BOX_EDGE,SCROLLABLE_OVERFLOWS}from\"./constants.js\";import{getStyle}from\"./getStyle.js\";import{getPreciseScrollbarSize}from\"./getPreciseScrollbarSize.js\";import{isDocumentElement}from\"./isDocumentElement.js\";export function getElementWidth(t,e=BOX_EDGE.border){let{width:r}=t.getBoundingClientRect();if(e===BOX_EDGE.border)return r;const o=getStyle(t);return e===BOX_EDGE.margin?(r+=Math.max(0,parseFloat(o.marginLeft)||0),r+=Math.max(0,parseFloat(o.marginRight)||0),r):(r-=parseFloat(o.borderLeftWidth)||0,r-=parseFloat(o.borderRightWidth)||0,e===BOX_EDGE.scrollbar?r:(!isDocumentElement(t)&&SCROLLABLE_OVERFLOWS.has(o.overflowY)&&(r-=getPreciseScrollbarSize(t,\"y\",Math.round(r)-t.clientWidth)),e===BOX_EDGE.padding||(r-=parseFloat(o.paddingLeft)||0,r-=parseFloat(o.paddingRight)||0),r))}","import{INCLUDE_WINDOW_SCROLLBAR,BOX_EDGE}from\"./utils/constants.js\";import{isWindow}from\"./utils/isWindow.js\";import{isDocument}from\"./utils/isDocument.js\";import{getWindowHeight}from\"./utils/getWindowHeight.js\";import{getDocumentHeight}from\"./utils/getDocumentHeight.js\";import{getElementHeight}from\"./utils/getElementHeight.js\";export function getHeight(t,e=BOX_EDGE.border){return isWindow(t)?getWindowHeight(t,INCLUDE_WINDOW_SCROLLBAR[e]):isDocument(t)?getDocumentHeight(t):getElementHeight(t,e)}","import{getPreciseScrollbarSize}from\"./getPreciseScrollbarSize.js\";export function getWindowHeight(e,r=!1){if(r)return e.innerHeight;const{innerHeight:t,document:i}=e,{documentElement:n}=i,{clientHeight:c}=n;return t-getPreciseScrollbarSize(n,\"x\",t-c)}","export function getDocumentHeight({documentElement:t}){return Math.max(t.scrollHeight,t.clientHeight,t.getBoundingClientRect().height)}","import{BOX_EDGE,SCROLLABLE_OVERFLOWS}from\"./constants.js\";import{getStyle}from\"./getStyle.js\";import{getPreciseScrollbarSize}from\"./getPreciseScrollbarSize.js\";import{isDocumentElement}from\"./isDocumentElement.js\";export function getElementHeight(t,e=BOX_EDGE.border){let{height:r}=t.getBoundingClientRect();if(e===BOX_EDGE.border)return r;const o=getStyle(t);return e===BOX_EDGE.margin?(r+=Math.max(0,parseFloat(o.marginTop)||0),r+=Math.max(0,parseFloat(o.marginBottom)||0),r):(r-=parseFloat(o.borderTopWidth)||0,r-=parseFloat(o.borderBottomWidth)||0,e===BOX_EDGE.scrollbar?r:(!isDocumentElement(t)&&SCROLLABLE_OVERFLOWS.has(o.overflowX)&&(r-=getPreciseScrollbarSize(t,\"x\",Math.round(r)-t.clientHeight)),e===BOX_EDGE.padding||(r-=parseFloat(o.paddingTop)||0,r-=parseFloat(o.paddingBottom)||0),r))}","import{isRectObject}from\"./utils/isRectObject.js\";import{isDocument}from\"./utils/isDocument.js\";import{getOffsetFromDocument}from\"./utils/getOffsetFromDocument.js\";export function getOffset(t,e){const o=isRectObject(t)?{left:t.left,top:t.top}:Array.isArray(t)?getOffsetFromDocument(...t):getOffsetFromDocument(t);if(e&&!isDocument(e)){const t=isRectObject(e)?e:Array.isArray(e)?getOffsetFromDocument(e[0],e[1]):getOffsetFromDocument(e);o.left-=t.left,o.top-=t.top}return o}","export function isRectObject(t){return t?.constructor===Object}","import{BOX_EDGE}from\"./constants.js\";import{getStyle}from\"./getStyle.js\";import{isDocument}from\"./isDocument.js\";import{isWindow}from\"./isWindow.js\";export function getOffsetFromDocument(t,o=BOX_EDGE.border){const e={left:0,top:0};if(isDocument(t))return e;if(isWindow(t))return e.left+=t.scrollX||0,e.top+=t.scrollY||0,e;const r=t.ownerDocument.defaultView;r&&(e.left+=r.scrollX||0,e.top+=r.scrollY||0);const n=t.getBoundingClientRect();if(e.left+=n.left,e.top+=n.top,o===BOX_EDGE.border)return e;const l=getStyle(t);return o===BOX_EDGE.margin?(e.left-=Math.max(0,parseFloat(l.marginLeft)||0),e.top-=Math.max(0,parseFloat(l.marginTop)||0),e):(e.left+=parseFloat(l.borderLeftWidth)||0,e.top+=parseFloat(l.borderTopWidth)||0,o===BOX_EDGE.scrollbar||o===BOX_EDGE.padding||(e.left+=parseFloat(l.paddingLeft)||0,e.top+=parseFloat(l.paddingTop)||0),e)}","import{getNormalizedRect}from\"./utils/getNormalizedRect.js\";export function getIntersection(t,...e){const o={...getNormalizedRect(t),right:0,bottom:0};for(const t of e){const e=getNormalizedRect(t),i=Math.max(o.left,e.left),h=Math.min(o.left+o.width,e.left+e.width);if(h<=i)return null;const r=Math.max(o.top,e.top),l=Math.min(o.top+o.height,e.height+e.top);if(l<=r)return null;o.left=i,o.top=r,o.width=h-i,o.height=l-r}return o.right=o.left+o.width,o.bottom=o.top+o.height,o}","import{getStyle}from\"./utils/getStyle.js\";import{getContainingBlock}from\"./getContainingBlock.js\";import{isWindow}from\"./utils/isWindow.js\";export function getOffsetContainer(n,t={}){const i=getStyle(n),{display:o}=i;if(\"none\"===o||\"contents\"===o)return null;const e=t.position||getStyle(n).position,{skipDisplayNone:s,container:r}=t;switch(e){case\"relative\":return n;case\"fixed\":return getContainingBlock(n,{container:r,position:e,skipDisplayNone:s});case\"absolute\":{const t=getContainingBlock(n,{container:r,position:e,skipDisplayNone:s});return isWindow(t)?n.ownerDocument:t}default:return null}}","import{getNormalizedRect}from\"./utils/getNormalizedRect.js\";export function getOverflow(t,e){const o=getNormalizedRect(t),i=getNormalizedRect(e);return{left:i.left-o.left,right:o.left+o.width-(i.left+i.width),top:i.top-o.top,bottom:o.top+o.height-(i.top+i.height)}}","const STYLE_DECLARATION_CACHE: WeakMap<Element, WeakRef<CSSStyleDeclaration>> = new WeakMap();\n\n/**\n * Returns element's CSS Style Declaration. Caches reference to the declaration\n * object weakly for faster access.\n */\nexport function getStyle(element: Element) {\n  let styleDeclaration: CSSStyleDeclaration | undefined =\n    STYLE_DECLARATION_CACHE.get(element)?.deref();\n\n  if (!styleDeclaration) {\n    styleDeclaration = window.getComputedStyle(element, null);\n    STYLE_DECLARATION_CACHE.set(element, new WeakRef(styleDeclaration));\n  }\n\n  return styleDeclaration;\n}\n","import { getOffset } from 'mezr';\n\n/**\n * Calculate the offset difference two elements.\n */\nexport function getOffsetDiff(\n  elemA: Element | Window | Document,\n  elemB: Element | Window | Document,\n  result: { left: number; top: number } = { left: 0, top: 0 },\n) {\n  result.left = 0;\n  result.top = 0;\n\n  // If elements are same let's return early.\n  if (elemA === elemB) return result;\n\n  // Finally, let's calculate the offset diff.\n  const offsetA = getOffset([elemA, 'padding']);\n  const offsetB = getOffset([elemB, 'padding']);\n  result.left = offsetB.left - offsetA.left;\n  result.top = offsetB.top - offsetA.top;\n\n  return result;\n}\n","import { ticker, tickerReadPhase, tickerWritePhase } from '../../singletons/ticker.js';\n\nimport { Draggable, DraggablePluginMap } from '../draggable.js';\n\nimport { Sensor } from '../../sensors/sensor.js';\n\nimport {\n  AutoScrollItem,\n  AutoScrollItemSpeedCallback,\n  AutoScrollItemEventCallback,\n  AutoScrollItemTarget,\n  autoScrollSmoothSpeed,\n} from '../../auto-scroll/auto-scroll.js';\n\nimport { autoScroll } from '../../singletons/auto-scroll.js';\n\nimport { Writeable } from '../../types.js';\n\nconst AUTOSCROLL_POSITION = { x: 0, y: 0 };\n\nconst AUTOSCROLL_CLIENT_RECT = { left: 0, top: 0, width: 0, height: 0 };\n\nfunction getDefaultSettings<S extends Sensor[], E extends S[number]['events']>() {\n  return {\n    targets: [],\n    inertAreaSize: 0.2,\n    speed: autoScrollSmoothSpeed(),\n    smoothStop: false,\n    getPosition: (draggable: Draggable<S, E>) => {\n      const { drag } = draggable;\n      const primaryItem = drag?.items[0];\n\n      // Try to use the first item for the autoscroll data.\n      if (primaryItem) {\n        AUTOSCROLL_POSITION.x = primaryItem.position.x;\n        AUTOSCROLL_POSITION.y = primaryItem.position.y;\n      }\n      // Fallback to the sensor's clientX/clientY values.\n      else {\n        const e = drag && (drag.event || drag.startEvent);\n        AUTOSCROLL_POSITION.x = e ? e.x : 0;\n        AUTOSCROLL_POSITION.y = e ? e.y : 0;\n      }\n\n      return AUTOSCROLL_POSITION;\n    },\n    getClientRect: (draggable: Draggable<S, E>) => {\n      const { drag } = draggable;\n      const primaryItem = drag?.items[0];\n\n      // Try to use the first item for the autoscroll data.\n      if (primaryItem && primaryItem.element) {\n        const { left, top, width, height } = primaryItem.clientRect;\n        AUTOSCROLL_CLIENT_RECT.left = left;\n        AUTOSCROLL_CLIENT_RECT.top = top;\n        AUTOSCROLL_CLIENT_RECT.width = width;\n        AUTOSCROLL_CLIENT_RECT.height = height;\n      }\n      // Fallback to the sensor's clientX/clientY values and a static size of\n      // 50x50px.\n      else {\n        const e = drag && (drag.event || drag.startEvent);\n        AUTOSCROLL_CLIENT_RECT.left = e ? e.x - 25 : 0;\n        AUTOSCROLL_CLIENT_RECT.top = e ? e.y - 25 : 0;\n        AUTOSCROLL_CLIENT_RECT.width = e ? 50 : 0;\n        AUTOSCROLL_CLIENT_RECT.height = e ? 50 : 0;\n      }\n\n      return AUTOSCROLL_CLIENT_RECT;\n    },\n    onStart: null,\n    onStop: null,\n  };\n}\n\nclass DraggableAutoScrollProxy<S extends Sensor[], E extends S[number]['events']>\n  implements AutoScrollItem\n{\n  protected _draggableAutoScroll: DraggableAutoScroll<S, E>;\n  protected _draggable: Draggable<S, E>;\n  protected _position: AutoScrollItem['position'];\n  protected _clientRect: AutoScrollItem['clientRect'];\n\n  constructor(draggableAutoScroll: DraggableAutoScroll<S, E>, draggable: Draggable<S, E>) {\n    this._draggableAutoScroll = draggableAutoScroll;\n    this._draggable = draggable;\n    this._position = { x: 0, y: 0 };\n    this._clientRect = { left: 0, top: 0, width: 0, height: 0 };\n  }\n\n  private _getSettings() {\n    return this._draggableAutoScroll.settings;\n  }\n\n  get targets() {\n    let { targets } = this._getSettings();\n    if (typeof targets === 'function') {\n      targets = targets(this._draggable);\n    }\n    return targets;\n  }\n\n  get position() {\n    let { getPosition } = this._getSettings();\n    if (typeof getPosition === 'function') {\n      const position = getPosition(this._draggable);\n      this._position.x = position.x;\n      this._position.y = position.y;\n    } else {\n      this._position.x = 0;\n      this._position.y = 0;\n    }\n    return this._position;\n  }\n\n  get clientRect() {\n    let { getClientRect } = this._getSettings();\n    if (typeof getClientRect === 'function') {\n      const { left, top, width, height } = getClientRect(this._draggable);\n      this._clientRect.left = left;\n      this._clientRect.top = top;\n      this._clientRect.width = width;\n      this._clientRect.height = height;\n    } else {\n      this._clientRect.left = 0;\n      this._clientRect.top = 0;\n      this._clientRect.width = 0;\n      this._clientRect.height = 0;\n    }\n    return this._clientRect;\n  }\n\n  get inertAreaSize() {\n    return this._getSettings().inertAreaSize;\n  }\n\n  get smoothStop() {\n    return this._getSettings().smoothStop;\n  }\n\n  get speed() {\n    return this._getSettings().speed;\n  }\n\n  get onStart() {\n    return this._getSettings().onStart;\n  }\n\n  get onStop() {\n    return this._getSettings().onStop;\n  }\n\n  onPrepareScrollEffect() {\n    const updateId = this._draggable['_updateId'];\n    ticker.off(tickerReadPhase, updateId);\n    ticker.off(tickerWritePhase, updateId);\n    this._draggable['_preparePositionUpdate']();\n  }\n\n  onApplyScrollEffect() {\n    this._draggable['_applyPositionUpdate']();\n  }\n}\n\nexport interface DraggableAutoScrollSettings<S extends Sensor[], E extends S[number]['events']> {\n  targets: AutoScrollItemTarget[] | ((draggable: Draggable<S, E>) => AutoScrollItemTarget[]);\n  inertAreaSize: number;\n  speed: number | AutoScrollItemSpeedCallback;\n  smoothStop: boolean;\n  getPosition: ((draggable: Draggable<S, E>) => { x: number; y: number }) | null;\n  getClientRect:\n    | ((draggable: Draggable<S, E>) => {\n        left: number;\n        top: number;\n        width: number;\n        height: number;\n      })\n    | null;\n  onStart: AutoScrollItemEventCallback | null;\n  onStop: AutoScrollItemEventCallback | null;\n}\n\nexport type DraggableAutoScrollOptions<S extends Sensor[], E extends S[number]['events']> = Partial<\n  DraggableAutoScrollSettings<S, E>\n>;\n\nexport class DraggableAutoScroll<\n  S extends Sensor[] = Sensor[],\n  E extends S[number]['events'] = S[number]['events'],\n> {\n  readonly name: 'autoscroll';\n  readonly version: string;\n  readonly settings: DraggableAutoScrollSettings<S, E>;\n  protected _autoScrollProxy: DraggableAutoScrollProxy<S, E> | null;\n\n  constructor(draggable: Draggable<S, E>, options: DraggableAutoScrollOptions<S, E> = {}) {\n    this.name = 'autoscroll';\n    this.version = '0.0.2';\n    this.settings = this._parseSettings(options);\n    this._autoScrollProxy = null;\n\n    draggable.on('start', () => {\n      if (!this._autoScrollProxy) {\n        this._autoScrollProxy = new DraggableAutoScrollProxy(this, draggable);\n        autoScroll.addItem(this._autoScrollProxy);\n      }\n    });\n\n    draggable.on('end', () => {\n      if (this._autoScrollProxy) {\n        autoScroll.removeItem(this._autoScrollProxy);\n        this._autoScrollProxy = null;\n      }\n    });\n  }\n\n  protected _parseSettings(\n    options?: Partial<this['settings']>,\n    defaults: this['settings'] = getDefaultSettings(),\n  ): this['settings'] {\n    const {\n      targets = defaults.targets,\n      inertAreaSize = defaults.inertAreaSize,\n      speed = defaults.speed,\n      smoothStop = defaults.smoothStop,\n      getPosition = defaults.getPosition,\n      getClientRect = defaults.getClientRect,\n      onStart = defaults.onStart,\n      onStop = defaults.onStop,\n    } = options || {};\n\n    return {\n      targets,\n      inertAreaSize,\n      speed,\n      smoothStop,\n      getPosition,\n      getClientRect,\n      onStart,\n      onStop,\n    };\n  }\n\n  updateSettings(options: Partial<this['settings']> = {}) {\n    (this as Writeable<this>).settings = this._parseSettings(options, this.settings);\n  }\n}\n\nexport function autoScrollPlugin<\n  S extends Sensor[],\n  E extends S[number]['events'],\n  P extends DraggablePluginMap,\n>(options?: DraggableAutoScrollOptions<S, E>) {\n  return (draggable: Draggable<S, E, P>) => {\n    const p = new DraggableAutoScroll(draggable, options);\n    const d = draggable as typeof draggable & {\n      plugins: { [p.name]: typeof p };\n    };\n    d.plugins[p.name] = p;\n    return d;\n  };\n}\n","import { Emitter, EventListenerId } from 'eventti';\n\nimport { getDistance, getRect } from 'mezr';\n\nimport { Rect, RectExtended } from '../types.js';\n\nimport { Pool } from '../pool.js';\n\nimport { ticker, tickerReadPhase, tickerWritePhase } from '../singletons/ticker.js';\n\nimport { getIntersectionScore } from '../utils/get-intersection-score.js';\n\nimport { getScrollElement } from '../utils/get-scroll-element.js';\n\nimport { getScrollLeft } from '../utils/get-scroll-left.js';\n\nimport { getScrollLeftMax } from '../utils/get-scroll-left-max.js';\n\nimport { getScrollTop } from '../utils/get-scroll-top.js';\n\nimport { getScrollTopMax } from '../utils/get-scroll-top-max.js';\n\nimport { isIntersecting } from '../utils/is-intersecting.js';\n\n//\n// CONSTANTS\n//\n\nconst R1: RectExtended = {\n  width: 0,\n  height: 0,\n  left: 0,\n  right: 0,\n  top: 0,\n  bottom: 0,\n};\n\nconst R2: RectExtended = { ...R1 };\n\nconst DEFAULT_THRESHOLD = 50;\n\nconst SPEED_DATA: AutoScrollSpeedData = {\n  direction: 'none',\n  threshold: 0,\n  distance: 0,\n  value: 0,\n  maxValue: 0,\n  duration: 0,\n  speed: 0,\n  deltaTime: 0,\n  isEnding: false,\n};\n\nexport const AUTO_SCROLL_AXIS = {\n  x: 1,\n  y: 2,\n} as const;\n\nexport const AUTO_SCROLL_AXIS_DIRECTION = {\n  forward: 4,\n  reverse: 8,\n} as const;\n\nconst AUTO_SCROLL_DIRECTION_X = {\n  none: 0,\n  left: (AUTO_SCROLL_AXIS.x | AUTO_SCROLL_AXIS_DIRECTION.reverse) as 9,\n  right: (AUTO_SCROLL_AXIS.x | AUTO_SCROLL_AXIS_DIRECTION.forward) as 5,\n} as const;\n\nconst AUTO_SCROLL_DIRECTION_Y = {\n  none: 0,\n  up: (AUTO_SCROLL_AXIS.y | AUTO_SCROLL_AXIS_DIRECTION.reverse) as 10,\n  down: (AUTO_SCROLL_AXIS.y | AUTO_SCROLL_AXIS_DIRECTION.forward) as 6,\n} as const;\n\nexport const AUTO_SCROLL_DIRECTION = {\n  ...AUTO_SCROLL_DIRECTION_X,\n  ...AUTO_SCROLL_DIRECTION_Y,\n} as const;\n\nfunction getDirectionAsString(direction: number) {\n  switch (direction) {\n    case AUTO_SCROLL_DIRECTION_X.none:\n    case AUTO_SCROLL_DIRECTION_Y.none:\n      return 'none';\n    case AUTO_SCROLL_DIRECTION_X.left:\n      return 'left';\n    case AUTO_SCROLL_DIRECTION_X.right:\n      return 'right';\n    case AUTO_SCROLL_DIRECTION_Y.up:\n      return 'up';\n    case AUTO_SCROLL_DIRECTION_Y.down:\n      return 'down';\n    default:\n      throw new Error(`Unknown direction value: ${direction}`);\n  }\n}\n\nfunction getPaddedRect(rect: RectExtended, padding: AutoScrollTargetPadding, result: RectExtended) {\n  let { left = 0, right = 0, top = 0, bottom = 0 } = padding;\n\n  // Don't allow negative padding.\n  left = Math.max(0, left);\n  right = Math.max(0, right);\n  top = Math.max(0, top);\n  bottom = Math.max(0, bottom);\n\n  result.width = rect.width + left + right;\n  result.height = rect.height + top + bottom;\n  result.left = rect.left - left;\n  result.top = rect.top - top;\n  result.right = rect.right + right;\n  result.bottom = rect.bottom + bottom;\n\n  return result;\n}\n\nfunction isScrolledToMax(scrollValue: number, maxScrollValue: number) {\n  // In some scenarios the scrollValue and/or maxScrollValue can be a float\n  // with subpixel values which might cause some funky scenarios where the\n  // element tries to scroll to the end but never actually reaches it. In such\n  // cases we want to do some rounding to detect that the element has actually\n  // reached the end of the scroll.\n  return Math.ceil(scrollValue) >= Math.floor(maxScrollValue);\n}\n\n//\n// PRIVATE TYPES\n//\n\ntype AutoScrollAxis = (typeof AUTO_SCROLL_AXIS)[keyof typeof AUTO_SCROLL_AXIS];\n\ntype AutoScrollDirectionX = (typeof AUTO_SCROLL_DIRECTION_X)[keyof typeof AUTO_SCROLL_DIRECTION_X];\n\ntype AutoScrollDirectionY = (typeof AUTO_SCROLL_DIRECTION_Y)[keyof typeof AUTO_SCROLL_DIRECTION_Y];\n\ntype AutoScrollDirection = (typeof AUTO_SCROLL_DIRECTION)[keyof typeof AUTO_SCROLL_DIRECTION];\n\ninterface AutoScrollSpeedData {\n  direction: ReturnType<typeof getDirectionAsString>;\n  threshold: number;\n  distance: number;\n  value: number;\n  maxValue: number;\n  duration: number;\n  speed: number;\n  deltaTime: number;\n  isEnding: boolean;\n}\n\ntype AutoScrollTargetPadding = {\n  left?: number;\n  right?: number;\n  top?: number;\n  bottom?: number;\n};\n\n//\n// PUBLIC TYPES\n//\n\nexport interface AutoScrollItem {\n  readonly targets: AutoScrollItemTarget[];\n  readonly clientRect: Rect;\n  readonly position: { x: number; y: number };\n  readonly inertAreaSize: number;\n  readonly smoothStop: boolean;\n  readonly speed: number | AutoScrollItemSpeedCallback;\n  readonly onStart?: AutoScrollItemEventCallback | null;\n  readonly onStop?: AutoScrollItemEventCallback | null;\n  readonly onPrepareScrollEffect?: AutoScrollItemEffectCallback | null;\n  readonly onApplyScrollEffect?: AutoScrollItemEffectCallback | null;\n}\n\nexport interface AutoScrollSettings {\n  overlapCheckInterval: number;\n}\n\nexport interface AutoScrollOptions extends Partial<AutoScrollSettings> {}\n\nexport interface AutoScrollEventCallbacks {\n  beforescroll(): void;\n  afterscroll(): void;\n}\n\nexport interface AutoScrollItemTarget {\n  element: Window | Element;\n  axis?: 'x' | 'y' | 'xy';\n  priority?: number;\n  threshold?: number;\n  padding?: AutoScrollTargetPadding;\n  scrollPadding?: AutoScrollTargetPadding;\n}\n\nexport type AutoScrollItemEventCallback = (\n  scrollElement: Window | Element,\n  scrollDirection: ReturnType<typeof getDirectionAsString>,\n) => void;\n\nexport type AutoScrollItemEffectCallback = () => void;\n\nexport type AutoScrollItemSpeedCallback = (\n  scrollElement: Window | Element,\n  scrollData: AutoScrollSpeedData,\n) => number;\n\n//\n// PRIVATE UTILS\n//\n\nfunction computeThreshold(idealThreshold: number, targetSize: number) {\n  return Math.min(targetSize / 2, idealThreshold);\n}\n\nfunction computeEdgeOffset(\n  threshold: number,\n  inertAreaSize: number,\n  itemSize: number,\n  targetSize: number,\n) {\n  return Math.max(0, itemSize + threshold * 2 + targetSize * inertAreaSize - targetSize) / 2;\n}\n\nclass AutoScrollItemData {\n  positionX: number;\n  positionY: number;\n  directionX: AutoScrollDirectionX;\n  directionY: AutoScrollDirectionY;\n  overlapCheckRequestTime: number;\n\n  constructor() {\n    this.positionX = 0;\n    this.positionY = 0;\n    this.directionX = AUTO_SCROLL_DIRECTION.none;\n    this.directionY = AUTO_SCROLL_DIRECTION.none;\n    this.overlapCheckRequestTime = 0;\n  }\n}\n\nclass AutoScrollAction {\n  element: Element | Window | null;\n  requestX: AutoScrollRequest | null;\n  requestY: AutoScrollRequest | null;\n  scrollLeft: number;\n  scrollTop: number;\n\n  constructor() {\n    this.element = null;\n    this.requestX = null;\n    this.requestY = null;\n    this.scrollLeft = 0;\n    this.scrollTop = 0;\n  }\n\n  reset() {\n    if (this.requestX) this.requestX.action = null;\n    if (this.requestY) this.requestY.action = null;\n    this.element = null;\n    this.requestX = null;\n    this.requestY = null;\n    this.scrollLeft = 0;\n    this.scrollTop = 0;\n  }\n\n  addRequest(request: AutoScrollRequest) {\n    if (AUTO_SCROLL_AXIS.x & request.direction) {\n      this.requestX && this.removeRequest(this.requestX);\n      this.requestX = request;\n    } else {\n      this.requestY && this.removeRequest(this.requestY);\n      this.requestY = request;\n    }\n    request.action = this;\n  }\n\n  removeRequest(request: AutoScrollRequest) {\n    if (this.requestX === request) {\n      this.requestX = null;\n      request.action = null;\n    } else if (this.requestY === request) {\n      this.requestY = null;\n      request.action = null;\n    }\n  }\n\n  computeScrollValues() {\n    if (!this.element) return;\n    this.scrollLeft = this.requestX ? this.requestX.value : getScrollLeft(this.element);\n    this.scrollTop = this.requestY ? this.requestY.value : getScrollTop(this.element);\n  }\n\n  scroll() {\n    if (!this.element) return;\n\n    if (this.element.scrollTo) {\n      this.element.scrollTo(this.scrollLeft, this.scrollTop);\n    } else {\n      (this.element as Element).scrollLeft = this.scrollLeft;\n      (this.element as Element).scrollTop = this.scrollTop;\n    }\n  }\n}\n\nclass AutoScrollRequest {\n  item: AutoScrollItem | null;\n  element: Element | Window | null;\n  isActive: boolean;\n  isEnding: boolean;\n  direction: AutoScrollDirection;\n  value: number;\n  maxValue: number;\n  threshold: number;\n  distance: number;\n  deltaTime: number;\n  speed: number;\n  duration: number;\n  action: AutoScrollAction | null;\n\n  constructor() {\n    this.item = null;\n    this.element = null;\n    this.isActive = false;\n    this.isEnding = false;\n    this.direction = 0;\n    this.value = NaN;\n    this.maxValue = 0;\n    this.threshold = 0;\n    this.distance = 0;\n    this.deltaTime = 0;\n    this.speed = 0;\n    this.duration = 0;\n    this.action = null;\n  }\n\n  reset() {\n    if (this.isActive) this.onStop();\n    this.item = null;\n    this.element = null;\n    this.isActive = false;\n    this.isEnding = false;\n    this.direction = 0;\n    this.value = NaN;\n    this.maxValue = 0;\n    this.threshold = 0;\n    this.distance = 0;\n    this.deltaTime = 0;\n    this.speed = 0;\n    this.duration = 0;\n    this.action = null;\n  }\n\n  hasReachedEnd() {\n    return AUTO_SCROLL_AXIS_DIRECTION.forward & this.direction\n      ? isScrolledToMax(this.value, this.maxValue)\n      : this.value <= 0;\n  }\n\n  computeCurrentScrollValue() {\n    if (!this.element) return 0;\n\n    if (this.value !== this.value) {\n      return AUTO_SCROLL_AXIS.x & this.direction\n        ? getScrollLeft(this.element)\n        : getScrollTop(this.element);\n    }\n\n    return Math.max(0, Math.min(this.value, this.maxValue));\n  }\n\n  computeNextScrollValue() {\n    const delta = this.speed * (this.deltaTime / 1000);\n    const nextValue =\n      AUTO_SCROLL_AXIS_DIRECTION.forward & this.direction ? this.value + delta : this.value - delta;\n    return Math.max(0, Math.min(nextValue, this.maxValue));\n  }\n\n  computeSpeed() {\n    if (!this.item || !this.element) return 0;\n    const { speed } = this.item;\n    if (typeof speed === 'function') {\n      SPEED_DATA.direction = getDirectionAsString(this.direction);\n      SPEED_DATA.threshold = this.threshold;\n      SPEED_DATA.distance = this.distance;\n      SPEED_DATA.value = this.value;\n      SPEED_DATA.maxValue = this.maxValue;\n      SPEED_DATA.duration = this.duration;\n      SPEED_DATA.speed = this.speed;\n      SPEED_DATA.deltaTime = this.deltaTime;\n      SPEED_DATA.isEnding = this.isEnding;\n      return speed(this.element, SPEED_DATA);\n    } else {\n      return speed;\n    }\n  }\n\n  tick(deltaTime: number) {\n    if (!this.isActive) {\n      this.isActive = true;\n      this.onStart();\n    }\n    this.deltaTime = deltaTime;\n    this.value = this.computeCurrentScrollValue();\n    this.speed = this.computeSpeed();\n    this.value = this.computeNextScrollValue();\n    this.duration += deltaTime;\n    return this.value;\n  }\n\n  onStart() {\n    if (!this.item || !this.element) return;\n    const { onStart } = this.item;\n    if (typeof onStart === 'function') {\n      onStart(this.element, getDirectionAsString(this.direction));\n    }\n  }\n\n  onStop() {\n    if (!this.item || !this.element) return;\n    const { onStop } = this.item;\n    if (typeof onStop === 'function') {\n      onStop(this.element, getDirectionAsString(this.direction));\n    }\n  }\n}\n\n//\n// PUBLIC UTILS\n//\n\nexport function autoScrollSmoothSpeed(\n  // Pixels per second.\n  maxSpeed = 500,\n  // Time in seconds, how long it will take to accelerate from 0 to maxSpeed.\n  accelerationFactor = 0.5,\n  // Time in seconds, how long it will take to decelerate maxSpeed to 0.\n  decelerationFactor = 0.25,\n): AutoScrollItemSpeedCallback {\n  const acceleration = maxSpeed * (accelerationFactor > 0 ? 1 / accelerationFactor : Infinity);\n  const deceleration = maxSpeed * (decelerationFactor > 0 ? 1 / decelerationFactor : Infinity);\n  return function (_element, data) {\n    let targetSpeed = 0;\n    if (!data.isEnding) {\n      if (data.threshold > 0) {\n        const factor = data.threshold - Math.max(0, data.distance);\n        targetSpeed = (maxSpeed / data.threshold) * factor;\n      } else {\n        targetSpeed = maxSpeed;\n      }\n    }\n\n    const currentSpeed = data.speed;\n    if (currentSpeed === targetSpeed) return targetSpeed;\n\n    let nextSpeed = targetSpeed;\n    if (currentSpeed < targetSpeed) {\n      nextSpeed = currentSpeed + acceleration * (data.deltaTime / 1000);\n      return Math.min(targetSpeed, nextSpeed);\n    } else {\n      nextSpeed = currentSpeed - deceleration * (data.deltaTime / 1000);\n      return Math.max(targetSpeed, nextSpeed);\n    }\n  };\n}\n\n//\n// AUTOSCROLL MAIN CLASS\n//\n\nexport class AutoScroll {\n  readonly items: AutoScrollItem[];\n  readonly settings: AutoScrollSettings;\n  protected _isDestroyed: boolean;\n  protected _isTicking: boolean;\n  protected _tickTime: number;\n  protected _tickDeltaTime: number;\n  protected _itemData: Map<AutoScrollItem, AutoScrollItemData>;\n  protected _actions: AutoScrollAction[];\n  protected _requests: {\n    [AUTO_SCROLL_AXIS.x]: Map<AutoScrollItem, AutoScrollRequest>;\n    [AUTO_SCROLL_AXIS.y]: Map<AutoScrollItem, AutoScrollRequest>;\n  };\n  protected _requestPool: Pool<AutoScrollRequest>;\n  protected _actionPool: Pool<AutoScrollAction>;\n  protected _emitter: Emitter<{\n    beforescroll: () => void;\n    afterscroll: () => void;\n  }>;\n\n  constructor(options: AutoScrollOptions = {}) {\n    const { overlapCheckInterval = 150 } = options;\n\n    this.items = [];\n    this.settings = {\n      overlapCheckInterval,\n    };\n\n    this._actions = [];\n    this._isDestroyed = false;\n    this._isTicking = false;\n    this._tickTime = 0;\n    this._tickDeltaTime = 0;\n    this._requests = {\n      [AUTO_SCROLL_AXIS.x]: new Map(),\n      [AUTO_SCROLL_AXIS.y]: new Map(),\n    };\n    this._itemData = new Map();\n    this._requestPool = new Pool<AutoScrollRequest>(\n      () => new AutoScrollRequest(),\n      (request) => request.reset(),\n    );\n    this._actionPool = new Pool<AutoScrollAction>(\n      () => new AutoScrollAction(),\n      (action) => action.reset(),\n    );\n\n    this._emitter = new Emitter();\n\n    this._frameRead = this._frameRead.bind(this);\n    this._frameWrite = this._frameWrite.bind(this);\n  }\n\n  protected _frameRead(time: number) {\n    if (this._isDestroyed) return;\n    if (time && this._tickTime) {\n      this._tickDeltaTime = time - this._tickTime;\n      this._tickTime = time;\n      this._updateItems();\n      this._updateRequests();\n      this._updateActions();\n    } else {\n      this._tickTime = time;\n      this._tickDeltaTime = 0;\n    }\n  }\n\n  protected _frameWrite() {\n    if (this._isDestroyed) return;\n    this._applyActions();\n  }\n\n  protected _startTicking() {\n    if (this._isTicking) return;\n    this._isTicking = true;\n    ticker.on(tickerReadPhase, this._frameRead);\n    ticker.on(tickerWritePhase, this._frameWrite);\n  }\n\n  protected _stopTicking() {\n    if (!this._isTicking) return;\n    this._isTicking = false;\n    this._tickTime = 0;\n    this._tickDeltaTime = 0;\n    ticker.off(tickerReadPhase, this._frameRead);\n    ticker.off(tickerWritePhase, this._frameWrite);\n  }\n\n  protected _getItemClientRect(\n    item: AutoScrollItem,\n    result: RectExtended = { width: 0, height: 0, left: 0, right: 0, top: 0, bottom: 0 },\n  ) {\n    const { clientRect } = item;\n    result.left = clientRect.left;\n    result.top = clientRect.top;\n    result.width = clientRect.width;\n    result.height = clientRect.height;\n    result.right = clientRect.left + clientRect.width;\n    result.bottom = clientRect.top + clientRect.height;\n    return result;\n  }\n\n  protected _requestItemScroll(\n    item: AutoScrollItem,\n    axis: AutoScrollAxis,\n    element: Window | Element,\n    direction: AutoScrollDirection,\n    threshold: number,\n    distance: number,\n    maxValue: number,\n  ) {\n    const reqMap = this._requests[axis];\n    let request = reqMap.get(item);\n\n    if (request) {\n      if (request.element !== element || request.direction !== direction) {\n        request.reset();\n      }\n    } else {\n      request = this._requestPool.pick();\n      reqMap.set(item, request);\n    }\n\n    request.item = item;\n    request.element = element;\n    request.direction = direction;\n    request.threshold = threshold;\n    request.distance = distance;\n    request.maxValue = maxValue;\n  }\n\n  protected _cancelItemScroll(item: AutoScrollItem, axis: AutoScrollAxis) {\n    const reqMap = this._requests[axis];\n    const request = reqMap.get(item);\n    if (!request) return;\n\n    if (request.action) request.action.removeRequest(request);\n    this._requestPool.put(request);\n    reqMap.delete(item);\n  }\n\n  protected _checkItemOverlap(item: AutoScrollItem, checkX: boolean, checkY: boolean) {\n    const { inertAreaSize, targets } = item;\n    if (!targets.length) {\n      checkX && this._cancelItemScroll(item, AUTO_SCROLL_AXIS.x);\n      checkY && this._cancelItemScroll(item, AUTO_SCROLL_AXIS.y);\n      return;\n    }\n\n    const itemData = this._itemData.get(item);\n    const moveDirectionX = itemData?.directionX;\n    const moveDirectionY = itemData?.directionY;\n    if (!moveDirectionX && !moveDirectionY) {\n      checkX && this._cancelItemScroll(item, AUTO_SCROLL_AXIS.x);\n      checkY && this._cancelItemScroll(item, AUTO_SCROLL_AXIS.y);\n      return;\n    }\n\n    const itemRect = this._getItemClientRect(item, R1);\n\n    let xElement: Window | Element | null = null;\n    let xPriority = -Infinity;\n    let xThreshold = 0;\n    let xScore = -Infinity;\n    let xDirection: AutoScrollDirectionX = AUTO_SCROLL_DIRECTION.none;\n    let xDistance = 0;\n    let xMaxScroll = 0;\n\n    let yElement: Window | Element | null = null;\n    let yPriority = -Infinity;\n    let yThreshold = 0;\n    let yScore = -Infinity;\n    let yDirection: AutoScrollDirectionY = AUTO_SCROLL_DIRECTION.none;\n    let yDistance = 0;\n    let yMaxScroll = 0;\n\n    let i = 0;\n    for (; i < targets.length; i++) {\n      const target = targets[i];\n      const targetThreshold =\n        typeof target.threshold === 'number' ? target.threshold : DEFAULT_THRESHOLD;\n      const testAxisX = !!(checkX && moveDirectionX && target.axis !== 'y');\n      const testAxisY = !!(checkY && moveDirectionY && target.axis !== 'x');\n      const testPriority = target.priority || 0;\n\n      // Ignore this item if it's x-axis and y-axis priority is lower than\n      // the currently matching item's.\n      if ((!testAxisX || testPriority < xPriority) && (!testAxisY || testPriority < yPriority)) {\n        continue;\n      }\n\n      const testElement = getScrollElement(target.element || target);\n      const testMaxScrollX = testAxisX ? getScrollLeftMax(testElement) : -1;\n      const testMaxScrollY = testAxisY ? getScrollTopMax(testElement) : -1;\n\n      // Ignore this item if there is no possibility to scroll.\n      if (testMaxScrollX <= 0 && testMaxScrollY <= 0) continue;\n\n      const testRect = getRect([testElement, 'padding'], window);\n      let testScore = getIntersectionScore(itemRect, testRect) || -Infinity;\n\n      // If the item has no overlap with the target.\n      if (testScore === -Infinity) {\n        // If the target has virtual extra padding defined and it's padded\n        // version overlaps with item then let's compute the shortest distance\n        // between item and target and use that value (negated) as testScore.\n        if (\n          target.padding &&\n          isIntersecting(itemRect, getPaddedRect(testRect, target.padding, R2))\n        ) {\n          testScore = -(getDistance(itemRect, testRect) || 0);\n        }\n        // Otherwise let's ignore this target.\n        else {\n          continue;\n        }\n      }\n\n      // Test x-axis.\n      if (\n        testAxisX &&\n        testPriority >= xPriority &&\n        testMaxScrollX > 0 &&\n        (testPriority > xPriority || testScore > xScore)\n      ) {\n        let testDistance = 0;\n        let testDirection: AutoScrollDirectionX = AUTO_SCROLL_DIRECTION.none;\n        const testThreshold = computeThreshold(targetThreshold, testRect.width);\n        const testEdgeOffset = computeEdgeOffset(\n          testThreshold,\n          inertAreaSize,\n          itemRect.width,\n          testRect.width,\n        );\n\n        if (moveDirectionX === AUTO_SCROLL_DIRECTION.right) {\n          testDistance = testRect.right + testEdgeOffset - itemRect.right;\n          if (\n            testDistance <= testThreshold &&\n            !isScrolledToMax(getScrollLeft(testElement), testMaxScrollX)\n          ) {\n            testDirection = AUTO_SCROLL_DIRECTION.right;\n          }\n        } else if (moveDirectionX === AUTO_SCROLL_DIRECTION.left) {\n          testDistance = itemRect.left - (testRect.left - testEdgeOffset);\n          if (testDistance <= testThreshold && getScrollLeft(testElement) > 0) {\n            testDirection = AUTO_SCROLL_DIRECTION.left;\n          }\n        }\n\n        if (testDirection) {\n          xElement = testElement;\n          xPriority = testPriority;\n          xThreshold = testThreshold;\n          xScore = testScore;\n          xDirection = testDirection;\n          xDistance = testDistance;\n          xMaxScroll = testMaxScrollX;\n        }\n      }\n\n      // Test y-axis.\n      if (\n        testAxisY &&\n        testPriority >= yPriority &&\n        testMaxScrollY > 0 &&\n        (testPriority > yPriority || testScore > yScore)\n      ) {\n        let testDistance = 0;\n        let testDirection: AutoScrollDirectionY = AUTO_SCROLL_DIRECTION_Y.none;\n        const testThreshold = computeThreshold(targetThreshold, testRect.height);\n        const testEdgeOffset = computeEdgeOffset(\n          testThreshold,\n          inertAreaSize,\n          itemRect.height,\n          testRect.height,\n        );\n\n        if (moveDirectionY === AUTO_SCROLL_DIRECTION.down) {\n          testDistance = testRect.bottom + testEdgeOffset - itemRect.bottom;\n          if (\n            testDistance <= testThreshold &&\n            !isScrolledToMax(getScrollTop(testElement), testMaxScrollY)\n          ) {\n            testDirection = AUTO_SCROLL_DIRECTION.down;\n          }\n        } else if (moveDirectionY === AUTO_SCROLL_DIRECTION.up) {\n          testDistance = itemRect.top - (testRect.top - testEdgeOffset);\n          if (testDistance <= testThreshold && getScrollTop(testElement) > 0) {\n            testDirection = AUTO_SCROLL_DIRECTION.up;\n          }\n        }\n\n        if (testDirection) {\n          yElement = testElement;\n          yPriority = testPriority;\n          yThreshold = testThreshold;\n          yScore = testScore;\n          yDirection = testDirection;\n          yDistance = testDistance;\n          yMaxScroll = testMaxScrollY;\n        }\n      }\n    }\n\n    // Request or cancel x-axis scroll.\n    if (checkX) {\n      if (xElement && xDirection) {\n        this._requestItemScroll(\n          item,\n          AUTO_SCROLL_AXIS.x,\n          xElement,\n          xDirection,\n          xThreshold,\n          xDistance,\n          xMaxScroll,\n        );\n      } else {\n        this._cancelItemScroll(item, AUTO_SCROLL_AXIS.x);\n      }\n    }\n\n    // Request or cancel y-axis scroll.\n    if (checkY) {\n      if (yElement && yDirection) {\n        this._requestItemScroll(\n          item,\n          AUTO_SCROLL_AXIS.y,\n          yElement,\n          yDirection,\n          yThreshold,\n          yDistance,\n          yMaxScroll,\n        );\n      } else {\n        this._cancelItemScroll(item, AUTO_SCROLL_AXIS.y);\n      }\n    }\n  }\n\n  protected _updateScrollRequest(scrollRequest: AutoScrollRequest) {\n    const item = scrollRequest.item!;\n    const { inertAreaSize, smoothStop, targets } = item;\n    const itemRect = this._getItemClientRect(item, R1);\n    let hasReachedEnd = null;\n\n    let i = 0;\n    for (; i < targets.length; i++) {\n      const target = targets[i];\n\n      // Make sure we have a matching element.\n      const testElement = getScrollElement(target.element || target);\n      if (testElement !== scrollRequest.element) continue;\n\n      // Make sure we have a matching axis.\n      const testIsAxisX = !!(AUTO_SCROLL_AXIS.x & scrollRequest.direction);\n      if (testIsAxisX) {\n        if (target.axis === 'y') continue;\n      } else {\n        if (target.axis === 'x') continue;\n      }\n\n      // Make sure the element is still scrollable.\n      const testMaxScroll = testIsAxisX\n        ? getScrollLeftMax(testElement)\n        : getScrollTopMax(testElement);\n      if (testMaxScroll <= 0) {\n        break;\n      }\n\n      const testRect = getRect([testElement, 'padding'], window);\n      const testScore = getIntersectionScore(itemRect, testRect) || -Infinity;\n\n      // If the item has no overlap with the target nor the padded target rect\n      // let's stop scrolling.\n      if (testScore === -Infinity) {\n        const padding = target.scrollPadding || target.padding;\n        if (!(padding && isIntersecting(itemRect, getPaddedRect(testRect, padding, R2)))) {\n          break;\n        }\n      }\n\n      // Compute threshold.\n      const targetThreshold =\n        typeof target.threshold === 'number' ? target.threshold : DEFAULT_THRESHOLD;\n      const testThreshold = computeThreshold(\n        targetThreshold,\n        testIsAxisX ? testRect.width : testRect.height,\n      );\n\n      // Compute edge offset.\n      const testEdgeOffset = computeEdgeOffset(\n        testThreshold,\n        inertAreaSize,\n        testIsAxisX ? itemRect.width : itemRect.height,\n        testIsAxisX ? testRect.width : testRect.height,\n      );\n\n      // Compute distance (based on current direction).\n      let testDistance = 0;\n      if (scrollRequest.direction === AUTO_SCROLL_DIRECTION.left) {\n        testDistance = itemRect.left - (testRect.left - testEdgeOffset);\n      } else if (scrollRequest.direction === AUTO_SCROLL_DIRECTION.right) {\n        testDistance = testRect.right + testEdgeOffset - itemRect.right;\n      } else if (scrollRequest.direction === AUTO_SCROLL_DIRECTION.up) {\n        testDistance = itemRect.top - (testRect.top - testEdgeOffset);\n      } else {\n        testDistance = testRect.bottom + testEdgeOffset - itemRect.bottom;\n      }\n\n      // Stop scrolling if threshold is not exceeded.\n      if (testDistance > testThreshold) {\n        break;\n      }\n\n      // Stop scrolling if we have reached max scroll value.\n      const testScroll = testIsAxisX ? getScrollLeft(testElement) : getScrollTop(testElement);\n      hasReachedEnd =\n        AUTO_SCROLL_AXIS_DIRECTION.forward & scrollRequest.direction\n          ? isScrolledToMax(testScroll, testMaxScroll)\n          : testScroll <= 0;\n      if (hasReachedEnd) break;\n\n      // Scrolling can continue, let's update the values.\n      scrollRequest.maxValue = testMaxScroll;\n      scrollRequest.threshold = testThreshold;\n      scrollRequest.distance = testDistance;\n      scrollRequest.isEnding = false;\n      return true;\n    }\n\n    // Before we end the request, let's see if we need to stop the scrolling\n    // smoothly or immediately.\n    if (smoothStop === true && scrollRequest.speed > 0) {\n      if (hasReachedEnd === null) hasReachedEnd = scrollRequest.hasReachedEnd();\n      scrollRequest.isEnding = hasReachedEnd ? false : true;\n    } else {\n      scrollRequest.isEnding = false;\n    }\n\n    return scrollRequest.isEnding;\n  }\n\n  protected _updateItems() {\n    for (let i = 0; i < this.items.length; i++) {\n      const item = this.items[i];\n      const itemData = this._itemData.get(item)!;\n      const { x, y } = item.position;\n      const prevX = itemData.positionX;\n      const prevY = itemData.positionY;\n\n      // If there is no change in position -> skip.\n      if (x === prevX && y === prevY) {\n        continue;\n      }\n\n      // Update direction x.\n      itemData.directionX =\n        x > prevX\n          ? AUTO_SCROLL_DIRECTION.right\n          : x < prevX\n            ? AUTO_SCROLL_DIRECTION.left\n            : itemData.directionX;\n\n      // Update direction y.\n      itemData.directionY =\n        y > prevY\n          ? AUTO_SCROLL_DIRECTION.down\n          : y < prevY\n            ? AUTO_SCROLL_DIRECTION.up\n            : itemData.directionY;\n\n      // Update positions.\n      itemData.positionX = x;\n      itemData.positionY = y;\n\n      // Request overlap check (if not already requested).\n      if (itemData.overlapCheckRequestTime === 0) {\n        itemData.overlapCheckRequestTime = this._tickTime;\n      }\n    }\n  }\n\n  protected _updateRequests() {\n    const items = this.items;\n    const requestsX = this._requests[AUTO_SCROLL_AXIS.x];\n    const requestsY = this._requests[AUTO_SCROLL_AXIS.y];\n\n    let i = 0;\n    for (; i < items.length; i++) {\n      const item = items[i];\n      const itemData = this._itemData.get(item)!;\n      const checkTime = itemData.overlapCheckRequestTime;\n      let needsCheck =\n        checkTime > 0 && this._tickTime - checkTime > this.settings.overlapCheckInterval;\n\n      let checkX = true;\n      const reqX = requestsX.get(item);\n      if (reqX && reqX.isActive) {\n        checkX = !this._updateScrollRequest(reqX);\n        if (checkX) {\n          needsCheck = true;\n          this._cancelItemScroll(item, AUTO_SCROLL_AXIS.x);\n        }\n      }\n\n      let checkY = true;\n      const reqY = requestsY.get(item);\n      if (reqY && reqY.isActive) {\n        checkY = !this._updateScrollRequest(reqY);\n        if (checkY) {\n          needsCheck = true;\n          this._cancelItemScroll(item, AUTO_SCROLL_AXIS.y);\n        }\n      }\n\n      if (needsCheck) {\n        itemData.overlapCheckRequestTime = 0;\n        this._checkItemOverlap(item, checkX, checkY);\n      }\n    }\n  }\n\n  protected _requestAction(request: AutoScrollRequest, axis: AutoScrollAxis) {\n    const isAxisX = axis === AUTO_SCROLL_AXIS.x;\n    let action: AutoScrollAction | null = null;\n\n    let i = 0;\n    for (; i < this._actions.length; i++) {\n      action = this._actions[i];\n\n      // If the action's request does not match the request's -> skip.\n      if (request.element !== action.element) {\n        action = null;\n        continue;\n      }\n\n      // If the request and action share the same element, but the request slot\n      // for the requested axis is already reserved let's ignore and cancel this\n      // request.\n      if (isAxisX ? action.requestX : action.requestY) {\n        this._cancelItemScroll(request.item!, axis);\n        return;\n      }\n\n      // Seems like we have found our action, let's break the loop.\n      break;\n    }\n\n    if (!action) action = this._actionPool.pick();\n    action.element = request.element;\n    action.addRequest(request);\n\n    request.tick(this._tickDeltaTime);\n    this._actions.push(action);\n  }\n\n  protected _updateActions() {\n    let i = 0;\n\n    // Generate actions.\n    for (i = 0; i < this.items.length; i++) {\n      const item = this.items[i];\n      const reqX = this._requests[AUTO_SCROLL_AXIS.x].get(item);\n      const reqY = this._requests[AUTO_SCROLL_AXIS.y].get(item);\n      if (reqX) this._requestAction(reqX, AUTO_SCROLL_AXIS.x);\n      if (reqY) this._requestAction(reqY, AUTO_SCROLL_AXIS.y);\n    }\n\n    // Compute scroll values.\n    for (i = 0; i < this._actions.length; i++) {\n      this._actions[i].computeScrollValues();\n    }\n  }\n\n  protected _applyActions() {\n    // No actions -> no scrolling.\n    if (!this._actions.length) return;\n\n    // TODO: Would be nice to emit also the elements that will be scrolled,\n    // to which direction they will be scrolled and how much they will be\n    // scrolled.\n    this._emitter.emit('beforescroll');\n\n    let i = 0;\n\n    // Scroll all the required elements.\n    for (i = 0; i < this._actions.length; i++) {\n      this._actions[i].scroll();\n      this._actionPool.put(this._actions[i]);\n    }\n\n    // Reset actions.\n    this._actions.length = 0;\n\n    // Call after scroll callbacks for all items that were scrolled.\n    let item: AutoScrollItem;\n    for (i = 0; i < this.items.length; i++) {\n      item = this.items[i];\n      if (item.onPrepareScrollEffect) {\n        item.onPrepareScrollEffect();\n      }\n    }\n    for (i = 0; i < this.items.length; i++) {\n      item = this.items[i];\n      if (item.onApplyScrollEffect) {\n        item.onApplyScrollEffect();\n      }\n    }\n\n    // TODO: Would be nice to emit also the elements that were scrolled,\n    // to which direction they were scrolled and how much they were scrolled.\n    this._emitter.emit('afterscroll');\n  }\n\n  /**\n   * Bind a listener.\n   */\n  on<T extends keyof AutoScrollEventCallbacks>(\n    eventName: T,\n    listener: AutoScrollEventCallbacks[T],\n  ): EventListenerId {\n    return this._emitter.on(eventName, listener);\n  }\n\n  /**\n   * Unbind a listener.\n   */\n  off<T extends keyof AutoScrollEventCallbacks>(\n    eventName: T,\n    listener: AutoScrollEventCallbacks[T] | EventListenerId,\n  ): void {\n    this._emitter.off(eventName, listener);\n  }\n\n  addItem(item: AutoScrollItem) {\n    if (this._isDestroyed || this._itemData.has(item)) return;\n\n    const { x, y } = item.position;\n    const itemData = new AutoScrollItemData();\n\n    itemData.positionX = x;\n    itemData.positionY = y;\n    itemData.directionX = AUTO_SCROLL_DIRECTION.none;\n    itemData.directionY = AUTO_SCROLL_DIRECTION.none;\n    itemData.overlapCheckRequestTime = this._tickTime;\n\n    this._itemData.set(item, itemData);\n    this.items.push(item);\n    if (!this._isTicking) this._startTicking();\n  }\n\n  removeItem(item: AutoScrollItem) {\n    if (this._isDestroyed) return;\n\n    const index = this.items.indexOf(item);\n    if (index === -1) return;\n\n    if (this._requests[AUTO_SCROLL_AXIS.x].get(item)) {\n      this._cancelItemScroll(item, AUTO_SCROLL_AXIS.x);\n      this._requests[AUTO_SCROLL_AXIS.x].delete(item);\n    }\n\n    if (this._requests[AUTO_SCROLL_AXIS.y].get(item)) {\n      this._cancelItemScroll(item, AUTO_SCROLL_AXIS.y);\n      this._requests[AUTO_SCROLL_AXIS.y].delete(item);\n    }\n\n    this._itemData.delete(item);\n    this.items.splice(index, 1);\n\n    if (this._isTicking && !this.items.length) {\n      this._stopTicking();\n    }\n  }\n\n  isDestroyed() {\n    return this._isDestroyed;\n  }\n\n  isItemScrollingX(item: AutoScrollItem) {\n    return !!this._requests[AUTO_SCROLL_AXIS.x].get(item)?.isActive;\n  }\n\n  isItemScrollingY(item: AutoScrollItem) {\n    return !!this._requests[AUTO_SCROLL_AXIS.y].get(item)?.isActive;\n  }\n\n  isItemScrolling(item: AutoScrollItem) {\n    return this.isItemScrollingX(item) || this.isItemScrollingY(item);\n  }\n\n  updateSettings(options: AutoScrollOptions = {}) {\n    const { overlapCheckInterval = this.settings.overlapCheckInterval } = options;\n    this.settings.overlapCheckInterval = overlapCheckInterval;\n  }\n\n  destroy() {\n    if (this._isDestroyed) return;\n\n    const items = this.items.slice(0);\n    let i = 0;\n    for (; i < items.length; i++) {\n      this.removeItem(items[i]);\n    }\n\n    this._actions.length = 0;\n    this._requestPool.reset();\n    this._actionPool.reset();\n    this._emitter.off();\n\n    this._isDestroyed = true;\n  }\n}\n","export class Pool<T> {\n  protected _data: T[];\n  protected _createObject: () => T;\n  protected _onPut: ((object: T) => void) | undefined;\n\n  constructor(createObject: () => T, onPut?: (object: T) => void) {\n    this._data = [];\n    this._createObject = createObject;\n    this._onPut = onPut;\n  }\n\n  pick() {\n    return this._data.length ? (this._data.pop() as T) : this._createObject();\n  }\n\n  put(object: T) {\n    if (this._data.indexOf(object) === -1) {\n      this._onPut && this._onPut(object);\n      this._data.push(object);\n    }\n  }\n\n  reset() {\n    this._data.length = 0;\n  }\n}\n","import { getIntersectionArea } from './get-intersection-area.js';\n\nimport { RectExtended } from '../types.js';\n\n/**\n * Calculate how many percent the intersection area of two rectangles is from\n * the maximum potential intersection area between the rectangles.\n */\nexport function getIntersectionScore(a: RectExtended, b: RectExtended) {\n  const area = getIntersectionArea(a, b);\n  if (!area) return 0;\n  const maxArea = Math.min(a.width, b.width) * Math.min(a.height, b.height);\n  return (area / maxArea) * 100;\n}\n","import { getIntersection } from 'mezr';\n\nimport { RectExtended } from '../types.js';\n\n/**\n * Calculate intersection area between two rectangle.\n */\nexport function getIntersectionArea(a: RectExtended, b: RectExtended) {\n  const intersection = getIntersection(a, b);\n  return intersection ? intersection.width * intersection.height : 0;\n}\n","import { isWindow } from './is-window.js';\n\nexport function getScrollElement(element: Element | Window) {\n  if (isWindow(element) || element === document.documentElement || element === document.body) {\n    return window;\n  } else {\n    return element;\n  }\n}\n","/**\n * Check if the current value is a window.\n */\nexport function isWindow(value: any): value is Window {\n  return value instanceof Window;\n}\n","import { isWindow } from './is-window.js';\n\nexport function getScrollLeft(element: Element | Window) {\n  return isWindow(element) ? element.pageXOffset : element.scrollLeft;\n}\n","import { isWindow } from './is-window.js';\n\nexport function getScrollLeftMax(element: Element | Window) {\n  if (isWindow(element)) element = document.documentElement;\n  return element.scrollWidth - element.clientWidth;\n}\n","import { isWindow } from './is-window.js';\n\nexport function getScrollTop(element: Element | Window) {\n  return isWindow(element) ? element.pageYOffset : element.scrollTop;\n}\n","import { isWindow } from './is-window.js';\n\nexport function getScrollTopMax(element: Element | Window) {\n  if (isWindow(element)) element = document.documentElement;\n  return element.scrollHeight - element.clientHeight;\n}\n","import { RectExtended } from '../types.js';\n\n/**\n * Check if two rectangles intersect.\n */\nexport function isIntersecting(a: RectExtended, b: RectExtended) {\n  return !(a.right <= b.left || b.right <= a.left || a.bottom <= b.top || b.bottom <= a.top);\n}\n","import { AutoScroll } from '../auto-scroll/auto-scroll.js';\n\nexport const autoScroll = new AutoScroll();\n","import { Sensor } from '../sensors/sensor.js';\n\nimport { Draggable } from '../draggable/draggable.js';\n\nimport { PointerSensor, PointerSensorEvents } from '../sensors/pointer-sensor.js';\n\nimport { getScrollableAncestors } from './get-scrollable-ancestors.js';\n\nimport { isScrollable } from './is-scrollable.js';\n\nfunction getScrollables(element: Element) {\n  const scrollables: (Element | Window)[] = [];\n\n  if (isScrollable(element)) {\n    scrollables.push(element);\n  }\n\n  getScrollableAncestors(element, scrollables);\n\n  return scrollables;\n}\n\nexport function createPointerSensorStartPredicate<\n  S extends (Sensor | PointerSensor)[] = (Sensor | PointerSensor)[],\n  D extends Draggable<S> = Draggable<S>,\n>(\n  options: {\n    timeout?: number;\n    fallback?: D['settings']['startPredicate'];\n  } = {},\n) {\n  let dragAllowed: boolean | undefined = undefined;\n\n  let startTimeStamp: number = 0;\n\n  let targetElement: Element | null = null;\n\n  let timer: number | undefined = undefined;\n\n  const { timeout = 250, fallback = () => true } = options;\n\n  const onContextMenu = (e: Event) => e.preventDefault();\n\n  const onTouchMove = (e: TouchEvent) => {\n    if (!startTimeStamp) return;\n\n    if (dragAllowed) {\n      e.cancelable && e.preventDefault();\n      return;\n    }\n\n    if (dragAllowed === undefined) {\n      if (e.cancelable && e.timeStamp - startTimeStamp > timeout) {\n        dragAllowed = true;\n        e.preventDefault();\n      } else {\n        dragAllowed = false;\n      }\n    }\n  };\n\n  const pointerSensorStartPredicate: D['settings']['startPredicate'] = (data) => {\n    if (!(data.sensor instanceof PointerSensor)) {\n      return fallback(data);\n    }\n\n    const { draggable, sensor, event } = data;\n    const e = event as PointerSensorEvents['start'] | PointerSensorEvents['move'];\n\n    if (e.pointerType === 'touch') {\n      // On first event (touchstart/pointerdown) we need to store the drag start\n      // data and bind listeners for touchmove and contextmenu.\n      if (\n        e.type === 'start' &&\n        (e.srcEvent.type === 'pointerdown' || e.srcEvent.type === 'touchstart')\n      ) {\n        // Prevent potentially scrollable nodes from scrolling to make sure\n        // native scrolling does not interfere with dragging.\n        targetElement = e.target as Element | null;\n        const scrollables = targetElement ? getScrollables(targetElement) : [];\n        scrollables.forEach((scrollable) => {\n          scrollable.addEventListener('touchmove', onTouchMove as EventListener, {\n            passive: false,\n            capture: true,\n          });\n        });\n\n        const dragEndListener = () => {\n          if (!startTimeStamp) return;\n\n          // Unbind listeners.\n          draggable.off('end', dragEndListener);\n          draggable.sensors.forEach((sensor) => {\n            if (sensor instanceof PointerSensor) {\n              sensor.off('end', dragEndListener);\n            }\n          });\n          targetElement?.removeEventListener('contextmenu', onContextMenu);\n          scrollables.forEach((scrollable) => {\n            scrollable.removeEventListener('touchmove', onTouchMove as EventListener, {\n              capture: true,\n            });\n          });\n\n          // Reset state.\n          startTimeStamp = 0;\n          dragAllowed = undefined;\n          targetElement = null;\n          timer = void window.clearTimeout(timer);\n        };\n\n        // Set start state.\n        dragAllowed = undefined;\n        startTimeStamp = e.srcEvent.timeStamp;\n\n        // Prevent context menu popping up.\n        targetElement?.addEventListener('contextmenu', onContextMenu);\n\n        // Reset data on drag end.\n        draggable.on('end', dragEndListener);\n        draggable.sensors.forEach((sensor) => {\n          if (sensor instanceof PointerSensor) {\n            sensor.off('end', dragEndListener);\n          }\n        });\n\n        // If we have timeout defined, let's set a timer that force starts\n        // the drag process after the timeout.\n        // TODO: This will start drag sometimes when it's not actually possible\n        // to prevent the native scrolling on touch devices. We'd need a way\n        // to check if the first touchstart/touchmove is cancelable. Needs\n        // testing on real devices. The funky thing is that we seem to need to\n        // get one touchmove event to check if we can prevent native scrolling\n        // but that is kind of too late already.. let's see if we can detect\n        // that earlier somehow.\n        if (timeout > 0) {\n          timer = window.setTimeout(() => {\n            draggable.resolveStartPredicate(sensor);\n            dragAllowed = true;\n            timer = undefined;\n          }, timeout);\n        }\n      }\n\n      return dragAllowed;\n    }\n\n    // On mouse/pen let's allow starting drag immediately if mouse's left button\n    // is pressed down.\n    if (e.type === 'start' && !(e.srcEvent as MouseEvent | PointerEvent).button) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  return pointerSensorStartPredicate;\n}\n","import { isScrollable } from './is-scrollable.js';\nimport { isDocument } from './is-document.js';\n\n/**\n * Compute the element's scrollable ancestor elements.\n */\nexport function getScrollableAncestors(\n  element: Element | Document | null,\n  result: (Element | Window)[] = [],\n) {\n  let parent = element?.parentNode;\n\n  while (parent && !isDocument(parent)) {\n    if (parent instanceof Element) {\n      if (isScrollable(parent)) result.push(parent);\n      parent = parent.parentNode;\n    } else if (parent instanceof ShadowRoot) {\n      parent = parent.host;\n    } else {\n      parent = parent.parentNode;\n    }\n  }\n\n  // Always push window to the results (as last scrollable element).\n  result.push(window);\n\n  return result;\n}\n","import { getStyle } from './get-style.js';\n\nconst SCROLLABLE_OVERFLOWS = new Set(['auto', 'scroll', 'overlay']);\n\n/**\n * Check if element is scrollable.\n */\nexport function isScrollable(element: Element) {\n  const style = getStyle(element);\n  return !!(SCROLLABLE_OVERFLOWS.has(style.overflowY) || SCROLLABLE_OVERFLOWS.has(style.overflowX));\n}\n","/**\n * Check if the current value is a document.\n */\nexport function isDocument(value: any): value is Document {\n  return value instanceof Document;\n}\n","import { SensorStartEvent, SensorMoveEvent } from '../sensors/sensor.js';\n\nimport { DraggableDragItem } from 'draggable/draggable-drag-item.js';\n\nfunction round(value: number, multipleOf: number) {\n  return Math.round(value / multipleOf) * multipleOf;\n}\n\nfunction getAxisChange(gridSize: number, snapPosition: number, sensorPosition: number) {\n  let change = sensorPosition - snapPosition;\n  let changeAbs = Math.abs(change);\n  if (changeAbs >= gridSize) {\n    const overflow = changeAbs % gridSize;\n    return round(change > 0 ? change - overflow : change + overflow, gridSize);\n  }\n  return 0;\n}\n\nexport function createSnapModifier(gridWidth: number, gridHeight: number) {\n  return function snapModifier({\n    startEvent,\n    event,\n    item,\n  }: {\n    startEvent: SensorStartEvent | SensorMoveEvent;\n    event: SensorMoveEvent;\n    item: DraggableDragItem;\n  }) {\n    let { __snapX__ = startEvent.x, __snapY__ = startEvent.y } = item.data;\n\n    const changeX = getAxisChange(gridWidth, __snapX__, event.x);\n    const changeY = getAxisChange(gridHeight, __snapY__, event.y);\n\n    if (changeX) {\n      item.data.__snapX__ = __snapX__ + changeX;\n    }\n    if (changeY) {\n      item.data.__snapY__ = __snapY__ + changeY;\n    }\n\n    return {\n      x: changeX,\n      y: changeY,\n    };\n  };\n}\n"],"names":["$df4a713e26511813$export$ef9b1dc363f184d9","$e9cd0e353e15b4ae$var$DraggableStartPredicateState","e","DraggableStartPredicateState","$e792636b9b5c481d$export$61fde4a8bbe7f5d5","start","move","cancel","end","destroy","$882b296db6123935$var$getOrCreateEventData","t","i","get","$882b296db6123935$var$EventData","set","constructor","idMap","Map","fnMap","onceList","Set","emitList","add","s","n","has","Error","delId","r","push","delete","size","delFn","forEach","$882b296db6123935$export$4293555f241ae35a","idDedupeMode","allowDuplicateListeners","_events","_getListeners","values","on","Symbol","once","off","clear","emit","length","listenerCount","$597a58f01afe9fb7$export$2176a6ff266bf511","drag","isDestroyed","_emitter","_createDragData","data","x","y","_updateDragData","_resetDragData","_start","_move","_end","_cancel","eventName","listener","listenerId","type","PAUSED","ON_DEMAND","CONTINUOUS","$c1fd6b62e08b3d47$export$9138efc7ba4fca22","$c1fd6b62e08b3d47$export$5fd1e257088db342","$c1fd6b62e08b3d47$export$e94d57566be028aa","phases","autoTick","requestFrame","$df4a713e26511813$export$789135d3cf084551","requestAnimationFrame","cancelAnimationFrame","performance","Date","now","setTimeout","clearTimeout","_autoTick","_requestFrame","_cancelFrame","_queue","tick","bind","_kickstart","a","c","u","o","_request","$75c93c044629d154$export$2f0ad9ba2f0800d","_direction","_speed","_tick","time","deltaTime","tickEvent","speedFactor","deltaX","deltaY","$63344f554ee4dd3f$export$6e8069a9617a39e2","id","pointerId","changedTouches","identifier","$9ecda7333d28e490$export$e44ffb50cc242ec5","window","document","$9ecda7333d28e490$export$ffcf6b6ce241bd05","isPassiveEventsSupported","passiveOpts","Object","defineProperty","addEventListener","removeEventListener","$9ecda7333d28e490$export$4af9b1d833a619de","$9ecda7333d28e490$export$7728c852ca75bb6d","PointerEvent","$578e243b57046d15$export$4d6c83612522bb80","options","capture","passive","$8909cb6563132761$export$6475a94861c59472","sourceEvents","undefined","navigator","vendor","indexOf","userAgent","$4998740c882fb340$var$SOURCE_EVENTS","pointer","touch","mouse","$4998740c882fb340$export$b26af955418d6638","element","listenerOptions","startPredicate","button","_areWindowListenersBound","_startPredicate","_listenerOptions","_sourceEvents","_onStart","_onMove","_onCancel","_onEnd","_getTrackedPointerEventData","pointerEventData","dragData","pointerType","clientX","clientY","eventData","srcEvent","target","_bindWindowListeners","_resetDrag","_unbindWindowListeners","updateSettings","nextSourceEvents","nextListenerOptions","$5f12a12b1bebeb44$var$KEY_TYPES","$5f12a12b1bebeb44$var$getEarliestTimestamp","keys","timestamps","Infinity","result","key","timestamp","$128271867868f1db$export$12e4b40eac1bcb71","sensor","startEvent","isEnded","event","prevEvent","endEvent","items","$45554ebda029bd05$var$STYLE_DECLARATION_CACHE","WeakMap","$45554ebda029bd05$export$3d2f074408bd1b82","getComputedStyle","C","deref","WeakRef","$70e6b31ea6202e28$export$af54264dae9065e6","$70e6b31ea6202e28$export$e44ffb50cc242ec5","$70e6b31ea6202e28$export$11fd24d838ebde87","content","padding","scrollbar","border","margin","$70e6b31ea6202e28$export$76e909bcfd8ba196","$70e6b31ea6202e28$export$d2ad2856e215d28e","$70e6b31ea6202e28$export$cd414719242f618c","userAgentData","brands","some","brand","$ac4a87157cb8fded$export$fab73c3646bf1f5e","display","$19cb8cdbc5921691$export$e5ce114ae0e5f4e8","filter","backdropFilter","willChange","transform","perspective","contentVisibility","contain","f","$8d1ba90c23ec3360$export$d8a62a489b442872","HTMLHtmlElement","$1f38751365ebdabf$export$940d8225183e1404","ownerDocument","defaultView","position","skipDisplayNone","container","parentElement","documentElement","l","$6473c4721ef9a7f0$export$53137579a3174918","Math","sqrt","pow","$0dd5d633d9254ede$export$5a096129d439f843","Window","$88986006632f0ab8$export$62858bae88b53fd0","Document","$9a36d0396b9b09d4$var$SUBPIXEL_OFFSET","$9a36d0396b9b09d4$var$testStyleElement","$9a36d0396b9b09d4$var$testParentElement","$9a36d0396b9b09d4$var$testChildElement","$9a36d0396b9b09d4$export$5ad86f4734d24a64","height","width","parseFloat","Number","isNaN","isInteger","$9a36d0396b9b09d4$var$getSubpixelScrollbarSize","split","createElement","innerHTML","appendChild","style","cssText","body","getBoundingClientRect","removeChild","$2e59c48b8f000a71$export$3c49c185de0c2bfc","innerWidth","clientWidth","max","scrollWidth","marginLeft","marginRight","borderLeftWidth","borderRightWidth","overflowY","round","paddingLeft","paddingRight","$646cecfa59ec4923$export$c08559766941f856","innerHeight","clientHeight","scrollHeight","marginTop","marginBottom","borderTopWidth","borderBottomWidth","overflowX","paddingTop","paddingBottom","$4de8edd731addea8$export$ff047630cae37d8e","$faeeed2de97ac6f7$export$9f1480883798e819","left","top","scrollX","scrollY","$d927f435c3d7e8ab$export$622cea445a1c5b7d","Array","isArray","$4fec7741c67a29fc$export$4b834cebd9e5cebe","g","right","bottom","$3fe9db1ad94d3e7c$export$e4e616e82e79ab9d","$4effe6f7501c7f59$export$243d7fadef466e38","$0c69ffc8ab90052a$var$STYLE_DECLARATION_CACHE","$0c69ffc8ab90052a$export$3d2f074408bd1b82","styleDeclaration","$5b850440d58ca286$export$5e94c6e790b2d913","elemA","elemB","offsetA","offsetB","$6985a94cfe75e842$var$OFFSET_DIFF","$6985a94cfe75e842$export$b87fb2dc7f11ca52","draggable","isConnected","clientRect","frozenProps","unfrozenProps","_updateDiff","_moveDiff","_containerDiff","elementContainer","elementOffsetContainer","dragContainer","settings","dragOffsetContainer","initialTransform","getStartPosition","item","getFrozenProps","props","prop","hasOwnProperty","updateSize","dimensions","rect","$e9cd0e353e15b4ae$var$SCROLL_LISTENER_OPTIONS","$e9cd0e353e15b4ae$var$OFFSET_DIFF","$e9cd0e353e15b4ae$var$POSITION_CHANGE","$e9cd0e353e15b4ae$var$getDefaultSettings","getElements","releaseElements","setPosition","getPositionChange","$f045deb6d07519b3$export$14963ee5c8637e11","createObject","onPut","_data","_createObject","_onPut","pick","pop","put","object","reset","$6551604847fd2088$export$25b3e1e24e1ba229","b","area","intersection","h","min","$f293b2d920f66b53$export$5a096129d439f843","value","$1d5c880696869e94$export$31d37ff78a483ce2","$8e79f2bef02bf7a3$export$1389d168952b34b5","pageXOffset","scrollLeft","$6a48622145310dd6$export$c16047c7a398106d","$b796ea00009cfb0f$export$c4a223a8ba9e4ea5","pageYOffset","scrollTop","$6ba3127b64f1801b$export$39d53b245a98193e","$dce4f2a3d0d356ef$export$8d3dd0be5eb9f11f","$292e4d9baf691c8b$var$R1","$292e4d9baf691c8b$var$R2","$292e4d9baf691c8b$var$SPEED_DATA","direction","threshold","distance","maxValue","duration","speed","isEnding","$292e4d9baf691c8b$export$5bbd74ab6c855dff","$292e4d9baf691c8b$export$3eeb7a7b68c92567","forward","reverse","$292e4d9baf691c8b$var$AUTO_SCROLL_DIRECTION_X","none","$292e4d9baf691c8b$var$AUTO_SCROLL_DIRECTION_Y","up","down","$292e4d9baf691c8b$export$c9fbd1f9176bc8ed","$292e4d9baf691c8b$var$getDirectionAsString","$292e4d9baf691c8b$var$getPaddedRect","$292e4d9baf691c8b$var$isScrolledToMax","scrollValue","maxScrollValue","ceil","floor","$292e4d9baf691c8b$var$computeThreshold","idealThreshold","targetSize","$292e4d9baf691c8b$var$computeEdgeOffset","inertAreaSize","itemSize","$292e4d9baf691c8b$var$AutoScrollItemData","positionX","positionY","directionX","directionY","overlapCheckRequestTime","$292e4d9baf691c8b$var$AutoScrollAction","requestX","requestY","action","addRequest","request","removeRequest","computeScrollValues","scroll","scrollTo","$292e4d9baf691c8b$var$AutoScrollRequest","isActive","NaN","onStop","hasReachedEnd","computeCurrentScrollValue","computeNextScrollValue","delta","computeSpeed","onStart","overlapCheckInterval","_actions","_isDestroyed","_isTicking","_tickTime","_tickDeltaTime","_requests","_itemData","_requestPool","_actionPool","_frameRead","_frameWrite","_updateItems","_updateRequests","_updateActions","_applyActions","_startTicking","_stopTicking","_getItemClientRect","_requestItemScroll","axis","reqMap","_cancelItemScroll","_checkItemOverlap","checkX","checkY","targets","itemData","moveDirectionX","moveDirectionY","itemRect","xElement","xPriority","xThreshold","xScore","xDirection","xDistance","xMaxScroll","yElement","yPriority","yThreshold","yScore","yDirection","yDistance","yMaxScroll","targetThreshold","testAxisX","testAxisY","testPriority","priority","testElement","testMaxScrollX","testMaxScrollY","testRect","testScore","testDistance","testDirection","testThreshold","testEdgeOffset","_updateScrollRequest","scrollRequest","smoothStop","testIsAxisX","testMaxScroll","scrollPadding","testScroll","prevX","prevY","requestsX","requestsY","checkTime","needsCheck","reqX","reqY","_requestAction","isAxisX","onPrepareScrollEffect","onApplyScrollEffect","addItem","removeItem","index","splice","isItemScrollingX","isItemScrollingY","isItemScrolling","slice","$a4c0af497ada6b6c$var$SCROLLABLE_OVERFLOWS","$a4c0af497ada6b6c$export$2bb74740c4e19def","$0d81635c11b16eab$var$element","querySelector","$0d81635c11b16eab$var$pointerSensor","$0d81635c11b16eab$var$keyboardSensor","activeElement","startKeys","moveLeftKeys","moveRightKeys","moveUpKeys","moveDownKeys","cancelKeys","endKeys","_computeSpeed","_startKeys","_cancelKeys","_endKeys","_moveLeftKeys","_moveRightKeys","_moveUpKeys","_moveDownKeys","_moveKeys","_moveKeyTimestamps","_onKeyDown","_onKeyUp","_onTick","_updateDirection","leftTime","rightTime","upTime","downTime","normFactor","startPosition","preventDefault","moveKeysMayNeedUpdate","keyType","name","nextMoveKeys","every","$0d81635c11b16eab$var$draggable","sensors","_parseSettings","plugins","_sensorData","_startId","_moveId","_updateId","_onScroll","_prepareStart","_applyStart","_prepareMove","_applyMove","_preparePositionUpdate","_applyPositionUpdate","predicateState","predicateEvent","onMove","onEnd","defaults","_emit","sensorData","shouldStart","resolveStartPredicate","rejectStartPredicate","updatePosition","stop","elements","map","assign","phase","changeX","changeY","updateDiffX","updateDiffY","instant","use","plugin","dragAllowed","timer","startTimeStamp","targetElement","timeout","fallback","onContextMenu","onTouchMove","cancelable","timeStamp","scrollables","$27dd69ed29855bb5$var$getScrollables","parent","parentNode","Element","ShadowRoot","host","scrollable","dragEndListener","classList","remove"],"version":3,"file":"index.a81e9c8b.js.map"}