{"mappings":"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","sources":["<anon>","examples/003-draggable-transformed/index.ts","src/index.ts","src/sensors/sensor.ts","src/sensors/base-sensor.ts","node_modules/eventti/dist/index.js","src/sensors/base-motion-sensor.ts","src/singletons/ticker.ts","node_modules/tikki/dist/index.js","src/sensors/pointer-sensor.ts","src/utils/get-pointer-event-data.ts","src/utils/get-pointer-type.ts","src/utils/get-pointer-id.ts","src/utils/parse-listener-options.ts","src/constants.ts","src/utils/parse-source-events.ts","src/sensors/keyboard-sensor.ts","src/sensors/keyboard-motion-sensor.ts","src/draggable/draggable.ts","src/draggable/draggable-drag.ts","src/utils/object-cache.ts","src/draggable/draggable-drag-item.ts","node_modules/mezr/dist/esm/index.js","node_modules/mezr/dist/esm/getContainingBlock.js","node_modules/mezr/dist/esm/utils/getStyle.js","node_modules/mezr/dist/esm/utils/isContainingBlockForFixedElement.js","node_modules/mezr/dist/esm/utils/constants.js","node_modules/mezr/dist/esm/utils/isBlockElement.js","node_modules/mezr/dist/esm/utils/isContainingBlockForAbsoluteElement.js","node_modules/mezr/dist/esm/utils/isDocumentElement.js","node_modules/mezr/dist/esm/getDistance.js","node_modules/mezr/dist/esm/utils/getDistanceBetweenRects.js","node_modules/mezr/dist/esm/utils/isIntersecting.js","node_modules/mezr/dist/esm/utils/getDistanceBetweenPoints.js","node_modules/mezr/dist/esm/utils/getNormalizedRect.js","node_modules/mezr/dist/esm/getRect.js","node_modules/mezr/dist/esm/getWidth.js","node_modules/mezr/dist/esm/utils/isWindow.js","node_modules/mezr/dist/esm/utils/isDocument.js","node_modules/mezr/dist/esm/utils/getWindowWidth.js","node_modules/mezr/dist/esm/utils/getPreciseScrollbarSize.js","node_modules/mezr/dist/esm/utils/getDocumentWidth.js","node_modules/mezr/dist/esm/utils/getElementWidth.js","node_modules/mezr/dist/esm/getHeight.js","node_modules/mezr/dist/esm/utils/getWindowHeight.js","node_modules/mezr/dist/esm/utils/getDocumentHeight.js","node_modules/mezr/dist/esm/utils/getElementHeight.js","node_modules/mezr/dist/esm/getOffset.js","node_modules/mezr/dist/esm/utils/isRectObject.js","node_modules/mezr/dist/esm/utils/getOffsetFromDocument.js","node_modules/mezr/dist/esm/getIntersection.js","node_modules/mezr/dist/esm/getOffsetContainer.js","node_modules/mezr/dist/esm/getOverflow.js","src/utils/get-style.ts","src/utils/get-client-offset.ts","src/utils/get-offset-diff.ts","src/utils/is-point.ts","src/utils/get-world-transform-matrix.ts","src/utils/parse-transform-origin.ts","src/utils/reset-matrix.ts","src/utils/create-wrapper-element.ts","src/utils/set-styles.ts","src/utils/is-matrix-warped.ts","src/utils/append-element.ts","src/utils/round-number.ts","src/utils/are-matrices-equal.ts","src/draggable/plugins/auto-scroll-plugin.ts","src/auto-scroll/auto-scroll.ts","src/pool.ts","src/utils/get-distance.ts","src/utils/create-full-rect.ts","src/utils/get-intersection-score.ts","src/utils/get-intersection-area.ts","src/utils/get-intersection.ts","src/utils/get-rect.ts","src/utils/get-scroll-element.ts","src/utils/is-window.ts","src/utils/get-scroll-left.ts","src/utils/get-scroll-left-max.ts","src/utils/get-scroll-top.ts","src/utils/get-scroll-top-max.ts","src/utils/is-intersecting.ts","src/singletons/auto-scroll.ts","src/utils/create-pointer-sensor-start-predicate.ts","src/utils/get-scrollable-ancestors.ts","src/utils/is-scrollable.ts","src/utils/is-document.ts","src/utils/create-snap-modifier.ts"],"sourcesContent":["const $e792636b9b5c481d$export$61fde4a8bbe7f5d5 = {\n    start: \"start\",\n    move: \"move\",\n    cancel: \"cancel\",\n    end: \"end\",\n    destroy: \"destroy\"\n};\n\n\nvar $3d96966d628715ed$export$242b5ede4c93f7ba = {\n    ADD: \"add\",\n    UPDATE: \"update\",\n    IGNORE: \"ignore\",\n    THROW: \"throw\"\n}, $3d96966d628715ed$export$4293555f241ae35a = class {\n    constructor(n = {}){\n        let { dedupe: t = $3d96966d628715ed$export$242b5ede4c93f7ba.ADD, getId: e = ()=>Symbol() } = n;\n        this.dedupe = t, this.getId = e, this._events = new Map;\n    }\n    _getListeners(n) {\n        let t = this._events.get(n);\n        if (t) {\n            let { idMap: e } = t;\n            if (e.size) return t.emitList = t.emitList || [\n                ...e.values()\n            ];\n        }\n        return null;\n    }\n    on(n, t, e) {\n        let { _events: s } = this, i = s.get(n);\n        i || (i = {\n            idMap: new Map,\n            emitList: null\n        }, s.set(n, i));\n        let { idMap: d, emitList: o } = i;\n        if (e = e === void 0 ? this.getId(t) : e, d.has(e)) switch(this.dedupe){\n            case $3d96966d628715ed$export$242b5ede4c93f7ba.THROW:\n                throw new Error(\"Eventti: duplicate listener id!\");\n            case $3d96966d628715ed$export$242b5ede4c93f7ba.IGNORE:\n                return e;\n            case $3d96966d628715ed$export$242b5ede4c93f7ba.UPDATE:\n                i.emitList = null;\n                break;\n            default:\n                d.delete(e), i.emitList = null;\n        }\n        return d.set(e, t), o?.push(t), e;\n    }\n    once(n, t, e) {\n        let s = !1;\n        return e = e === void 0 ? this.getId(t) : e, this.on(n, (...i)=>{\n            s || (s = !0, this.off(n, e), t(...i));\n        }, e);\n    }\n    off(n, t) {\n        if (n === void 0) {\n            this._events.clear();\n            return;\n        }\n        if (t === void 0) {\n            this._events.delete(n);\n            return;\n        }\n        let e = this._events.get(n);\n        e && e.idMap.delete(t) && (e.emitList = null, e.idMap.size || this._events.delete(n));\n    }\n    emit(n, ...t) {\n        let e = this._getListeners(n);\n        if (!e) return;\n        let { length: s } = e;\n        if (t.length) {\n            if (s === 1) e[0](...t);\n            else {\n                let i = 0;\n                for(; i < s; i++)e[i](...t);\n            }\n        } else if (s === 1) e[0]();\n        else {\n            let i = 0;\n            for(; i < s; i++)e[i]();\n        }\n    }\n    listenerCount(n) {\n        if (n === void 0) {\n            let t = 0;\n            return this._events.forEach((e, s)=>{\n                t += this.listenerCount(s);\n            }), t;\n        }\n        return this._events.get(n)?.idMap.size || 0;\n    }\n};\n\n\n\nclass $597a58f01afe9fb7$export$2176a6ff266bf511 {\n    constructor(){\n        this.drag = null;\n        this.isDestroyed = false;\n        this._emitter = new (0, $3d96966d628715ed$export$4293555f241ae35a)();\n    }\n    _createDragData(data) {\n        return {\n            x: data.x,\n            y: data.y\n        };\n    }\n    _updateDragData(data) {\n        if (!this.drag) return;\n        this.drag.x = data.x;\n        this.drag.y = data.y;\n    }\n    _resetDragData() {\n        this.drag = null;\n    }\n    _start(data) {\n        if (this.isDestroyed || this.drag) return;\n        this.drag = this._createDragData(data);\n        this._emitter.emit((0, $e792636b9b5c481d$export$61fde4a8bbe7f5d5).start, data);\n    }\n    _move(data) {\n        if (!this.drag) return;\n        this._updateDragData(data);\n        this._emitter.emit((0, $e792636b9b5c481d$export$61fde4a8bbe7f5d5).move, data);\n    }\n    _end(data) {\n        if (!this.drag) return;\n        this._updateDragData(data);\n        this._emitter.emit((0, $e792636b9b5c481d$export$61fde4a8bbe7f5d5).end, data);\n        this._resetDragData();\n    }\n    _cancel(data) {\n        if (!this.drag) return;\n        this._updateDragData(data);\n        this._emitter.emit((0, $e792636b9b5c481d$export$61fde4a8bbe7f5d5).cancel, data);\n        this._resetDragData();\n    }\n    on(type, listener, listenerId) {\n        return this._emitter.on(type, listener, listenerId);\n    }\n    off(type, listenerId) {\n        this._emitter.off(type, listenerId);\n    }\n    cancel() {\n        if (!this.drag) return;\n        this._cancel({\n            type: (0, $e792636b9b5c481d$export$61fde4a8bbe7f5d5).cancel,\n            x: this.drag.x,\n            y: this.drag.y\n        });\n    }\n    destroy() {\n        if (this.isDestroyed) return;\n        this.isDestroyed = true;\n        this.cancel();\n        this._emitter.emit((0, $e792636b9b5c481d$export$61fde4a8bbe7f5d5).destroy, {\n            type: (0, $e792636b9b5c481d$export$61fde4a8bbe7f5d5).destroy\n        });\n        this._emitter.off();\n    }\n}\n\n\n\n\nvar $4f159119173b96ee$export$815e2a1977260d23 = (0, $3d96966d628715ed$export$242b5ede4c93f7ba), $4f159119173b96ee$export$39c54bcc89dcee11 = class {\n    constructor(e = {}){\n        let { phases: t = [], dedupe: r, getId: s } = e;\n        this._phases = t, this._emitter = new (0, $3d96966d628715ed$export$4293555f241ae35a)({\n            getId: s,\n            dedupe: r\n        }), this._queue = [], this.tick = this.tick.bind(this), this._getListeners = this._emitter._getListeners.bind(this._emitter);\n    }\n    get phases() {\n        return this._phases;\n    }\n    set phases(e) {\n        this._phases = e;\n    }\n    get dedupe() {\n        return this._emitter.dedupe;\n    }\n    set dedupe(e) {\n        this._emitter.dedupe = e;\n    }\n    get getId() {\n        return this._emitter.getId;\n    }\n    set getId(e) {\n        this._emitter.getId = e;\n    }\n    tick(...e) {\n        this._assertEmptyQueue(), this._fillQueue(), this._processQueue(...e);\n    }\n    on(e, t, r) {\n        return this._emitter.on(e, t, r);\n    }\n    once(e, t, r) {\n        return this._emitter.once(e, t, r);\n    }\n    off(e, t) {\n        return this._emitter.off(e, t);\n    }\n    count(e) {\n        return this._emitter.listenerCount(e);\n    }\n    _assertEmptyQueue() {\n        if (this._queue.length) throw new Error(\"Ticker: Can't tick before the previous tick has finished!\");\n    }\n    _fillQueue() {\n        let e = this._queue, t = this._phases, r = this._getListeners, s = 0, a = t.length, n;\n        for(; s < a; s++)n = r(t[s]), n && e.push(n);\n        return e;\n    }\n    _processQueue(...e) {\n        let t = this._queue, r = t.length;\n        if (!r) return;\n        let s = 0, a = 0, n, c;\n        for(; s < r; s++)for(n = t[s], a = 0, c = n.length; a < c; a++)n[a](...e);\n        t.length = 0;\n    }\n};\nfunction $4f159119173b96ee$export$789135d3cf084551(i = 60) {\n    if (typeof requestAnimationFrame == \"function\" && typeof cancelAnimationFrame == \"function\") return (e)=>{\n        let t = requestAnimationFrame(e);\n        return ()=>cancelAnimationFrame(t);\n    };\n    {\n        let e = 1e3 / i, t = typeof performance > \"u\" ? ()=>Date.now() : ()=>performance.now();\n        return (r)=>{\n            let s = setTimeout(()=>r(t()), e);\n            return ()=>clearTimeout(s);\n        };\n    }\n}\nvar $4f159119173b96ee$export$bf5a5397711dbf71 = class extends $4f159119173b96ee$export$39c54bcc89dcee11 {\n    constructor(e = {}){\n        let { paused: t = !1, onDemand: r = !1, requestFrame: s = $4f159119173b96ee$export$789135d3cf084551(), ...a } = e;\n        super(a), this._paused = t, this._onDemand = r, this._requestFrame = s, this._cancelFrame = null, this._empty = !0, !t && !r && this._request();\n    }\n    get phases() {\n        return this._phases;\n    }\n    set phases(e) {\n        this._phases = e, e.length ? (this._empty = !1, this._request()) : this._empty = !0;\n    }\n    get paused() {\n        return this._paused;\n    }\n    set paused(e) {\n        this._paused = e, e ? this._cancel() : this._request();\n    }\n    get onDemand() {\n        return this._onDemand;\n    }\n    set onDemand(e) {\n        this._onDemand = e, e || this._request();\n    }\n    get requestFrame() {\n        return this._requestFrame;\n    }\n    set requestFrame(e) {\n        this._requestFrame !== e && (this._requestFrame = e, this._cancelFrame && (this._cancel(), this._request()));\n    }\n    tick(...e) {\n        if (this._assertEmptyQueue(), this._cancelFrame = null, this._onDemand || this._request(), !this._empty) {\n            if (!this._fillQueue().length) {\n                this._empty = !0;\n                return;\n            }\n            this._onDemand && this._request(), this._processQueue(...e);\n        }\n    }\n    on(e, t, r) {\n        let s = super.on(e, t, r);\n        return this._empty = !1, this._request(), s;\n    }\n    once(e, t, r) {\n        let s = super.once(e, t, r);\n        return this._empty = !1, this._request(), s;\n    }\n    _request() {\n        this._paused || this._cancelFrame || (this._cancelFrame = this._requestFrame(this.tick));\n    }\n    _cancel() {\n        this._cancelFrame && (this._cancelFrame(), this._cancelFrame = null);\n    }\n};\nfunction $4f159119173b96ee$export$4d497fac909c98f0(i) {\n    return (e)=>{\n        let t = i.requestAnimationFrame(e);\n        return ()=>i.cancelAnimationFrame(t);\n    };\n}\n\n\nconst $c1fd6b62e08b3d47$export$ef9171fc2626 = {\n    read: Symbol(),\n    write: Symbol()\n};\nlet $c1fd6b62e08b3d47$export$e94d57566be028aa = new (0, $4f159119173b96ee$export$bf5a5397711dbf71)({\n    phases: [\n        $c1fd6b62e08b3d47$export$ef9171fc2626.read,\n        $c1fd6b62e08b3d47$export$ef9171fc2626.write\n    ]\n});\nfunction $c1fd6b62e08b3d47$export$9bc58717d06262f5(newTicker, phases) {\n    $c1fd6b62e08b3d47$export$e94d57566be028aa = newTicker;\n    Object.assign($c1fd6b62e08b3d47$export$ef9171fc2626, phases);\n}\n\n\nclass $75c93c044629d154$export$2f0ad9ba2f0800d extends (0, $597a58f01afe9fb7$export$2176a6ff266bf511) {\n    constructor(){\n        super();\n        this.drag = null;\n        this._direction = {\n            x: 0,\n            y: 0\n        };\n        this._speed = 0;\n        this._tick = this._tick.bind(this);\n    }\n    _createDragData(data) {\n        return {\n            ...super._createDragData(data),\n            time: 0,\n            deltaTime: 0\n        };\n    }\n    _start(data) {\n        if (this.isDestroyed || this.drag) return;\n        super._start(data);\n        (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).on((0, $c1fd6b62e08b3d47$export$ef9171fc2626).read, this._tick, this._tick);\n    }\n    _end(data) {\n        if (!this.drag) return;\n        (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).off((0, $c1fd6b62e08b3d47$export$ef9171fc2626).read, this._tick);\n        super._end(data);\n    }\n    _cancel(data) {\n        if (!this.drag) return;\n        (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).off((0, $c1fd6b62e08b3d47$export$ef9171fc2626).read, this._tick);\n        super._cancel(data);\n    }\n    _tick(time) {\n        if (!this.drag) return;\n        if (time && this.drag.time) {\n            // Update tick time and delta time.\n            this.drag.deltaTime = time - this.drag.time;\n            this.drag.time = time;\n            // Emit tick event.\n            const tickEvent = {\n                type: \"tick\",\n                time: this.drag.time,\n                deltaTime: this.drag.deltaTime\n            };\n            this._emitter.emit(\"tick\", tickEvent);\n            // Make sure the sensor is still active.\n            if (!this.drag) return;\n            // Compute the movement offset (delta) by applying time factor to\n            // the speed. The speed is assumed to be provided as pixels-per-second.\n            const speedFactor = this._speed * (this.drag.deltaTime / 1000);\n            const deltaX = this._direction.x * speedFactor;\n            const deltaY = this._direction.y * speedFactor;\n            // Trigger move event if the clientX/Y needs change. Note that calling\n            // this._move() automatically updates clientX/Y values also so we don't\n            // need to do it here.\n            if (deltaX || deltaY) this._move({\n                type: \"move\",\n                x: this.drag.x + deltaX,\n                y: this.drag.y + deltaY\n            });\n        } else {\n            this.drag.time = time;\n            this.drag.deltaTime = 0;\n        }\n    }\n}\n\n\n\n\nfunction $63344f554ee4dd3f$export$6e8069a9617a39e2(e, id) {\n    // If we have a pointer event return the whole event if there's a match, and\n    // null otherwise.\n    if (\"pointerId\" in e) return e.pointerId === id ? e : null;\n    // For touch events let's check if there's a changed touch object that matches\n    // the pointerId in which case return the touch object.\n    if (\"changedTouches\" in e) {\n        let i = 0;\n        for(; i < e.changedTouches.length; i++){\n            if (e.changedTouches[i].identifier === id) return e.changedTouches[i];\n        }\n        return null;\n    }\n    // For mouse/other events let's assume there's only one pointer and just\n    // return the event.\n    return e;\n}\n\n\nfunction $19b680555f9c20ee$export$887a228355cf7d95(e) {\n    return \"pointerType\" in e ? e.pointerType : \"touches\" in e ? \"touch\" : \"mouse\";\n}\n\n\nfunction $ae2af31ed1bf7a8e$export$a845ff6c553b3014(e) {\n    // If we have pointer id available let's use it.\n    if (\"pointerId\" in e) return e.pointerId;\n    // For touch events let's get the first changed touch's identifier.\n    if (\"changedTouches\" in e) return e.changedTouches[0] ? e.changedTouches[0].identifier : null;\n    // For mouse/other events let's provide a static id. And let's make it a\n    // negative number so it has it has not chance of clashing with touch/pointer\n    // ids.\n    return -1;\n}\n\n\nconst $9ecda7333d28e490$export$e44ffb50cc242ec5 = typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\nconst $9ecda7333d28e490$export$ffcf6b6ce241bd05 = (()=>{\n    let isPassiveEventsSupported = false;\n    try {\n        const passiveOpts = Object.defineProperty({}, \"passive\", {\n            get: function() {\n                isPassiveEventsSupported = true;\n            }\n        });\n        // @ts-ignore\n        window.addEventListener(\"testPassive\", null, passiveOpts);\n        // @ts-ignore\n        window.removeEventListener(\"testPassive\", null, passiveOpts);\n    } catch (e) {}\n    return isPassiveEventsSupported;\n})();\nconst $9ecda7333d28e490$export$4af9b1d833a619de = $9ecda7333d28e490$export$e44ffb50cc242ec5 && \"ontouchstart\" in window;\nconst $9ecda7333d28e490$export$7728c852ca75bb6d = $9ecda7333d28e490$export$e44ffb50cc242ec5 && !!window.PointerEvent;\nconst $9ecda7333d28e490$export$af54264dae9065e6 = !!($9ecda7333d28e490$export$e44ffb50cc242ec5 && navigator.vendor && navigator.vendor.indexOf(\"Apple\") > -1 && navigator.userAgent && navigator.userAgent.indexOf(\"CriOS\") == -1 && navigator.userAgent.indexOf(\"FxiOS\") == -1);\n\n\nfunction $578e243b57046d15$export$4d6c83612522bb80(options = {}) {\n    const { capture: capture = true, passive: passive = true } = options;\n    if (0, $9ecda7333d28e490$export$ffcf6b6ce241bd05) return {\n        capture: capture,\n        passive: passive\n    };\n    else return {\n        capture: capture\n    };\n}\n\n\n\nfunction $8909cb6563132761$export$6475a94861c59472(sourceEvents) {\n    return sourceEvents === \"auto\" || sourceEvents === undefined ? (0, $9ecda7333d28e490$export$7728c852ca75bb6d) ? \"pointer\" : (0, $9ecda7333d28e490$export$4af9b1d833a619de) ? \"touch\" : \"mouse\" : sourceEvents;\n}\n\n\nconst $4998740c882fb340$var$POINTER_EVENTS = {\n    start: \"pointerdown\",\n    move: \"pointermove\",\n    cancel: \"pointercancel\",\n    end: \"pointerup\"\n};\nconst $4998740c882fb340$var$TOUCH_EVENTS = {\n    start: \"touchstart\",\n    move: \"touchmove\",\n    cancel: \"touchcancel\",\n    end: \"touchend\"\n};\nconst $4998740c882fb340$var$MOUSE_EVENTS = {\n    start: \"mousedown\",\n    move: \"mousemove\",\n    cancel: \"\",\n    end: \"mouseup\"\n};\nconst $4998740c882fb340$var$SOURCE_EVENTS = {\n    pointer: $4998740c882fb340$var$POINTER_EVENTS,\n    touch: $4998740c882fb340$var$TOUCH_EVENTS,\n    mouse: $4998740c882fb340$var$MOUSE_EVENTS\n};\nclass $4998740c882fb340$export$b26af955418d6638 {\n    constructor(element, options = {}){\n        const { listenerOptions: listenerOptions = {}, sourceEvents: sourceEvents = \"auto\", startPredicate: startPredicate = (e)=>\"button\" in e && e.button > 0 ? false : true } = options;\n        this.element = element;\n        this.drag = null;\n        this.isDestroyed = false;\n        this._areWindowListenersBound = false;\n        this._startPredicate = startPredicate;\n        this._listenerOptions = (0, $578e243b57046d15$export$4d6c83612522bb80)(listenerOptions);\n        this._sourceEvents = (0, $8909cb6563132761$export$6475a94861c59472)(sourceEvents);\n        this._emitter = new (0, $3d96966d628715ed$export$4293555f241ae35a)();\n        this._onStart = this._onStart.bind(this);\n        this._onMove = this._onMove.bind(this);\n        this._onCancel = this._onCancel.bind(this);\n        this._onEnd = this._onEnd.bind(this);\n        // Listen to start event.\n        element.addEventListener($4998740c882fb340$var$SOURCE_EVENTS[this._sourceEvents].start, this._onStart, this._listenerOptions);\n    }\n    /**\n   * Check if the provided event contains the tracked pointer id or in the case\n   * of touch event if the first changed touch is the tracked touch object and\n   * return the event or touch object. Otherwise return null.\n   */ _getTrackedPointerEventData(e) {\n        return this.drag ? (0, $63344f554ee4dd3f$export$6e8069a9617a39e2)(e, this.drag.pointerId) : null;\n    }\n    /**\n   * Listener for start event.\n   */ _onStart(e) {\n        if (this.isDestroyed || this.drag) return;\n        // Make sure start predicate is fulfilled.\n        if (!this._startPredicate(e)) return;\n        // Try to get pointer id.\n        const pointerId = (0, $ae2af31ed1bf7a8e$export$a845ff6c553b3014)(e);\n        if (pointerId === null) return;\n        // Try to get pointer.\n        const pointerEventData = (0, $63344f554ee4dd3f$export$6e8069a9617a39e2)(e, pointerId);\n        if (pointerEventData === null) return;\n        // Create drag data.\n        const dragData = {\n            pointerId: pointerId,\n            pointerType: (0, $19b680555f9c20ee$export$887a228355cf7d95)(e),\n            x: pointerEventData.clientX,\n            y: pointerEventData.clientY\n        };\n        // Set drag data.\n        this.drag = dragData;\n        // Emit start event.\n        const eventData = {\n            ...dragData,\n            type: (0, $e792636b9b5c481d$export$61fde4a8bbe7f5d5).start,\n            srcEvent: e,\n            target: pointerEventData.target\n        };\n        this._emitter.emit(eventData.type, eventData);\n        // If the drag procedure was not reset within the start procedure let's\n        // activate the instance (start listening to move/cancel/end events).\n        if (this.drag) this._bindWindowListeners();\n    }\n    /**\n   * Listener for move event.\n   */ _onMove(e) {\n        if (!this.drag) return;\n        const pointerEventData = this._getTrackedPointerEventData(e);\n        if (!pointerEventData) return;\n        this.drag.x = pointerEventData.clientX;\n        this.drag.y = pointerEventData.clientY;\n        const eventData = {\n            type: (0, $e792636b9b5c481d$export$61fde4a8bbe7f5d5).move,\n            srcEvent: e,\n            target: pointerEventData.target,\n            ...this.drag\n        };\n        this._emitter.emit(eventData.type, eventData);\n    }\n    /**\n   * Listener for cancel event.\n   */ _onCancel(e) {\n        if (!this.drag) return;\n        const pointerEventData = this._getTrackedPointerEventData(e);\n        if (!pointerEventData) return;\n        this.drag.x = pointerEventData.clientX;\n        this.drag.y = pointerEventData.clientY;\n        const eventData = {\n            type: (0, $e792636b9b5c481d$export$61fde4a8bbe7f5d5).cancel,\n            srcEvent: e,\n            target: pointerEventData.target,\n            ...this.drag\n        };\n        this._emitter.emit(eventData.type, eventData);\n        this._resetDrag();\n    }\n    /**\n   * Listener for end event.\n   */ _onEnd(e) {\n        if (!this.drag) return;\n        const pointerEventData = this._getTrackedPointerEventData(e);\n        if (!pointerEventData) return;\n        this.drag.x = pointerEventData.clientX;\n        this.drag.y = pointerEventData.clientY;\n        const eventData = {\n            type: (0, $e792636b9b5c481d$export$61fde4a8bbe7f5d5).end,\n            srcEvent: e,\n            target: pointerEventData.target,\n            ...this.drag\n        };\n        this._emitter.emit(eventData.type, eventData);\n        this._resetDrag();\n    }\n    /**\n   * Bind window event listeners for move/end/cancel.\n   */ _bindWindowListeners() {\n        if (this._areWindowListenersBound) return;\n        const { move: move, end: end, cancel: cancel } = $4998740c882fb340$var$SOURCE_EVENTS[this._sourceEvents];\n        window.addEventListener(move, this._onMove, this._listenerOptions);\n        window.addEventListener(end, this._onEnd, this._listenerOptions);\n        if (cancel) window.addEventListener(cancel, this._onCancel, this._listenerOptions);\n        this._areWindowListenersBound = true;\n    }\n    /**\n   * Unbind window event listeners for move/end/cancel.\n   */ _unbindWindowListeners() {\n        if (this._areWindowListenersBound) {\n            const { move: move, end: end, cancel: cancel } = $4998740c882fb340$var$SOURCE_EVENTS[this._sourceEvents];\n            window.removeEventListener(move, this._onMove, this._listenerOptions);\n            window.removeEventListener(end, this._onEnd, this._listenerOptions);\n            if (cancel) window.removeEventListener(cancel, this._onCancel, this._listenerOptions);\n            this._areWindowListenersBound = false;\n        }\n    }\n    /**\n   * Reset drag data.\n   */ _resetDrag() {\n        this.drag = null;\n        this._unbindWindowListeners();\n    }\n    /**\n   * Forcefully cancel the drag process.\n   */ cancel() {\n        if (!this.drag) return;\n        const eventData = {\n            type: (0, $e792636b9b5c481d$export$61fde4a8bbe7f5d5).cancel,\n            srcEvent: null,\n            target: null,\n            ...this.drag\n        };\n        this._emitter.emit(eventData.type, eventData);\n        this._resetDrag();\n    }\n    /**\n   * Update the instance's settings.\n   */ updateSettings(options) {\n        if (this.isDestroyed) return;\n        const { listenerOptions: listenerOptions, sourceEvents: sourceEvents, startPredicate: startPredicate } = options;\n        const nextSourceEvents = (0, $8909cb6563132761$export$6475a94861c59472)(sourceEvents);\n        const nextListenerOptions = (0, $578e243b57046d15$export$4d6c83612522bb80)(listenerOptions);\n        // Update start predicate if needed.\n        if (startPredicate && this._startPredicate !== startPredicate) this._startPredicate = startPredicate;\n        // Update listener options and/or source events if needed.\n        if (listenerOptions && (this._listenerOptions.capture !== nextListenerOptions.capture || this._listenerOptions.passive === nextListenerOptions.passive) || sourceEvents && this._sourceEvents !== nextSourceEvents) {\n            // Unbind start listener.\n            this.element.removeEventListener($4998740c882fb340$var$SOURCE_EVENTS[this._sourceEvents].start, this._onStart, this._listenerOptions);\n            // Unbind window listeners.\n            this._unbindWindowListeners();\n            // Cancel current drag process.\n            this.cancel();\n            // Update options to instace.\n            if (sourceEvents) this._sourceEvents = nextSourceEvents;\n            if (listenerOptions && nextListenerOptions) this._listenerOptions = nextListenerOptions;\n            // Rebind start listener with new options.\n            this.element.addEventListener($4998740c882fb340$var$SOURCE_EVENTS[this._sourceEvents].start, this._onStart, this._listenerOptions);\n        }\n    }\n    /**\n   * Bind a drag event listener.\n   */ on(type, listener, listenerId) {\n        return this._emitter.on(type, listener, listenerId);\n    }\n    /**\n   * Unbind a drag event listener.\n   */ off(type, listenerId) {\n        this._emitter.off(type, listenerId);\n    }\n    /**\n   * Destroy the instance and unbind all drag event listeners.\n   */ destroy() {\n        if (this.isDestroyed) return;\n        // Mark as destroyed.\n        this.isDestroyed = true;\n        // Cancel any ongoing drag process.\n        this.cancel();\n        // Emit destroy event.\n        this._emitter.emit((0, $e792636b9b5c481d$export$61fde4a8bbe7f5d5).destroy, {\n            type: (0, $e792636b9b5c481d$export$61fde4a8bbe7f5d5).destroy\n        });\n        // Destroy emitter.\n        this._emitter.off();\n        // Unbind start event listeners.\n        this.element.removeEventListener($4998740c882fb340$var$SOURCE_EVENTS[this._sourceEvents].start, this._onStart, this._listenerOptions);\n    }\n}\n\n\n\nconst $eecb4a66666e90e7$export$247491620fa01a28 = {\n    moveDistance: 25,\n    cancelOnBlur: true,\n    cancelOnVisibilityChange: true,\n    startPredicate: (e, sensor)=>{\n        if (sensor.element && (e.key === \"Enter\" || e.key === \" \")) {\n            if (document.activeElement === sensor.element) {\n                const { x: x, y: y } = sensor.element.getBoundingClientRect();\n                return {\n                    x: x,\n                    y: y\n                };\n            }\n        }\n        return null;\n    },\n    movePredicate: (e, sensor)=>{\n        if (!sensor.drag) return null;\n        switch(e.key){\n            case \"ArrowLeft\":\n                return {\n                    x: sensor.drag.x - sensor.moveDistance.x,\n                    y: sensor.drag.y\n                };\n            case \"ArrowRight\":\n                return {\n                    x: sensor.drag.x + sensor.moveDistance.x,\n                    y: sensor.drag.y\n                };\n            case \"ArrowUp\":\n                return {\n                    x: sensor.drag.x,\n                    y: sensor.drag.y - sensor.moveDistance.y\n                };\n            case \"ArrowDown\":\n                return {\n                    x: sensor.drag.x,\n                    y: sensor.drag.y + sensor.moveDistance.y\n                };\n            default:\n                return null;\n        }\n    },\n    cancelPredicate: (e, sensor)=>{\n        if (sensor.drag && e.key === \"Escape\") {\n            const { x: x, y: y } = sensor.drag;\n            return {\n                x: x,\n                y: y\n            };\n        }\n        return null;\n    },\n    endPredicate: (e, sensor)=>{\n        if (sensor.drag && (e.key === \"Enter\" || e.key === \" \")) {\n            const { x: x, y: y } = sensor.drag;\n            return {\n                x: x,\n                y: y\n            };\n        }\n        return null;\n    }\n};\nclass $eecb4a66666e90e7$export$44d67f2a438aeba9 extends (0, $597a58f01afe9fb7$export$2176a6ff266bf511) {\n    constructor(element, options = {}){\n        super();\n        const { moveDistance: moveDistance = $eecb4a66666e90e7$export$247491620fa01a28.moveDistance, cancelOnBlur: cancelOnBlur = $eecb4a66666e90e7$export$247491620fa01a28.cancelOnBlur, cancelOnVisibilityChange: cancelOnVisibilityChange = $eecb4a66666e90e7$export$247491620fa01a28.cancelOnVisibilityChange, startPredicate: startPredicate = $eecb4a66666e90e7$export$247491620fa01a28.startPredicate, movePredicate: movePredicate = $eecb4a66666e90e7$export$247491620fa01a28.movePredicate, cancelPredicate: cancelPredicate = $eecb4a66666e90e7$export$247491620fa01a28.cancelPredicate, endPredicate: endPredicate = $eecb4a66666e90e7$export$247491620fa01a28.endPredicate } = options;\n        this.element = element;\n        this.moveDistance = typeof moveDistance === \"number\" ? {\n            x: moveDistance,\n            y: moveDistance\n        } : {\n            ...moveDistance\n        };\n        this._cancelOnBlur = cancelOnBlur;\n        this._cancelOnVisibilityChange = cancelOnVisibilityChange;\n        this._startPredicate = startPredicate;\n        this._movePredicate = movePredicate;\n        this._cancelPredicate = cancelPredicate;\n        this._endPredicate = endPredicate;\n        this._onKeyDown = this._onKeyDown.bind(this);\n        this._internalCancel = this._internalCancel.bind(this);\n        this._blurCancelHandler = this._blurCancelHandler.bind(this);\n        document.addEventListener(\"keydown\", this._onKeyDown);\n        if (cancelOnBlur) element?.addEventListener(\"blur\", this._blurCancelHandler);\n        if (cancelOnVisibilityChange) document.addEventListener(\"visibilitychange\", this._internalCancel);\n    }\n    _internalCancel() {\n        this.cancel();\n    }\n    _blurCancelHandler() {\n        // If the Draggable has a container defined the dragged element will be\n        // appended to the container, which will cause the element to lose focus\n        // temporarily in some browsers (e.g. Chrome). Draggable will automatically\n        // restore the focus immediately after the element is appended, but the blur\n        // event will be triggered anyway. This is why we need to defer the cancel\n        // call to the next microtask, where we can check if the element is still\n        // focused.\n        queueMicrotask(()=>{\n            if (document.activeElement !== this.element) this.cancel();\n        });\n    }\n    _onKeyDown(e) {\n        // Handle start.\n        if (!this.drag) {\n            const startPosition = this._startPredicate(e, this);\n            if (startPosition) {\n                e.preventDefault();\n                this._start({\n                    type: \"start\",\n                    x: startPosition.x,\n                    y: startPosition.y,\n                    srcEvent: e\n                });\n            }\n            return;\n        }\n        // Handle cancel.\n        const cancelPosition = this._cancelPredicate(e, this);\n        if (cancelPosition) {\n            e.preventDefault();\n            this._cancel({\n                type: \"cancel\",\n                x: cancelPosition.x,\n                y: cancelPosition.y,\n                srcEvent: e\n            });\n            return;\n        }\n        // Handle end.\n        const endPosition = this._endPredicate(e, this);\n        if (endPosition) {\n            e.preventDefault();\n            this._end({\n                type: \"end\",\n                x: endPosition.x,\n                y: endPosition.y,\n                srcEvent: e\n            });\n            return;\n        }\n        // Handle move.\n        const movePosition = this._movePredicate(e, this);\n        if (movePosition) {\n            e.preventDefault();\n            this._move({\n                type: \"move\",\n                x: movePosition.x,\n                y: movePosition.y,\n                srcEvent: e\n            });\n            return;\n        }\n    }\n    updateSettings(options = {}) {\n        const { moveDistance: moveDistance, cancelOnBlur: cancelOnBlur, cancelOnVisibilityChange: cancelOnVisibilityChange, startPredicate: startPredicate, movePredicate: movePredicate, cancelPredicate: cancelPredicate, endPredicate: endPredicate } = options;\n        if (moveDistance !== undefined) {\n            if (typeof moveDistance === \"number\") this.moveDistance.x = this.moveDistance.y = moveDistance;\n            else {\n                this.moveDistance.x = moveDistance.x;\n                this.moveDistance.y = moveDistance.y;\n            }\n        }\n        if (cancelOnBlur !== undefined && this._cancelOnBlur !== cancelOnBlur) {\n            this._cancelOnBlur = cancelOnBlur;\n            if (cancelOnBlur) this.element?.addEventListener(\"blur\", this._blurCancelHandler);\n            else this.element?.removeEventListener(\"blur\", this._blurCancelHandler);\n        }\n        if (cancelOnVisibilityChange !== undefined && this._cancelOnVisibilityChange !== cancelOnVisibilityChange) {\n            this._cancelOnVisibilityChange = cancelOnVisibilityChange;\n            if (cancelOnVisibilityChange) document.addEventListener(\"visibilitychange\", this._internalCancel);\n            else document.removeEventListener(\"visibilitychange\", this._internalCancel);\n        }\n        if (startPredicate) this._startPredicate = startPredicate;\n        if (movePredicate) this._movePredicate = movePredicate;\n        if (cancelPredicate) this._cancelPredicate = cancelPredicate;\n        if (endPredicate) this._endPredicate = endPredicate;\n    }\n    destroy() {\n        if (this.isDestroyed) return;\n        super.destroy();\n        document.removeEventListener(\"keydown\", this._onKeyDown);\n        if (this._cancelOnBlur) this.element?.removeEventListener(\"blur\", this._blurCancelHandler);\n        if (this._cancelOnVisibilityChange) document.removeEventListener(\"visibilitychange\", this._internalCancel);\n    }\n}\n\n\n\nconst $5f12a12b1bebeb44$var$KEY_TYPES = [\n    \"start\",\n    \"cancel\",\n    \"end\",\n    \"moveLeft\",\n    \"moveRight\",\n    \"moveUp\",\n    \"moveDown\"\n];\nfunction $5f12a12b1bebeb44$var$getEarliestTimestamp(keys, timestamps) {\n    if (!keys.size || !timestamps.size) return Infinity;\n    let result = Infinity;\n    for (const key of keys){\n        const timestamp = timestamps.get(key);\n        if (timestamp !== undefined && timestamp < result) result = timestamp;\n    }\n    return result;\n}\nconst $5f12a12b1bebeb44$export$fbce5a9938cd33df = {\n    startKeys: [\n        \" \",\n        \"Enter\"\n    ],\n    moveLeftKeys: [\n        \"ArrowLeft\"\n    ],\n    moveRightKeys: [\n        \"ArrowRight\"\n    ],\n    moveUpKeys: [\n        \"ArrowUp\"\n    ],\n    moveDownKeys: [\n        \"ArrowDown\"\n    ],\n    cancelKeys: [\n        \"Escape\"\n    ],\n    endKeys: [\n        \" \",\n        \"Enter\"\n    ],\n    cancelOnBlur: true,\n    cancelOnVisibilityChange: true,\n    computeSpeed: ()=>500,\n    startPredicate: (_e, sensor)=>{\n        if (sensor.element && document.activeElement === sensor.element) {\n            const { left: left, top: top } = sensor.element.getBoundingClientRect();\n            return {\n                x: left,\n                y: top\n            };\n        }\n        return null;\n    }\n};\nclass $5f12a12b1bebeb44$export$436f6efcc297171 extends (0, $75c93c044629d154$export$2f0ad9ba2f0800d) {\n    constructor(element, options = {}){\n        super();\n        const { startPredicate: startPredicate = $5f12a12b1bebeb44$export$fbce5a9938cd33df.startPredicate, computeSpeed: computeSpeed = $5f12a12b1bebeb44$export$fbce5a9938cd33df.computeSpeed, cancelOnVisibilityChange: cancelOnVisibilityChange = $5f12a12b1bebeb44$export$fbce5a9938cd33df.cancelOnVisibilityChange, cancelOnBlur: cancelOnBlur = $5f12a12b1bebeb44$export$fbce5a9938cd33df.cancelOnBlur, startKeys: startKeys = $5f12a12b1bebeb44$export$fbce5a9938cd33df.startKeys, moveLeftKeys: moveLeftKeys = $5f12a12b1bebeb44$export$fbce5a9938cd33df.moveLeftKeys, moveRightKeys: moveRightKeys = $5f12a12b1bebeb44$export$fbce5a9938cd33df.moveRightKeys, moveUpKeys: moveUpKeys = $5f12a12b1bebeb44$export$fbce5a9938cd33df.moveUpKeys, moveDownKeys: moveDownKeys = $5f12a12b1bebeb44$export$fbce5a9938cd33df.moveDownKeys, cancelKeys: cancelKeys = $5f12a12b1bebeb44$export$fbce5a9938cd33df.cancelKeys, endKeys: endKeys = $5f12a12b1bebeb44$export$fbce5a9938cd33df.endKeys } = options;\n        this.element = element;\n        this._startKeys = new Set(startKeys);\n        this._cancelKeys = new Set(cancelKeys);\n        this._endKeys = new Set(endKeys);\n        this._moveLeftKeys = new Set(moveLeftKeys);\n        this._moveRightKeys = new Set(moveRightKeys);\n        this._moveUpKeys = new Set(moveUpKeys);\n        this._moveDownKeys = new Set(moveDownKeys);\n        this._moveKeys = new Set([\n            ...moveLeftKeys,\n            ...moveRightKeys,\n            ...moveUpKeys,\n            ...moveDownKeys\n        ]);\n        this._moveKeyTimestamps = new Map();\n        this._cancelOnBlur = cancelOnBlur;\n        this._cancelOnVisibilityChange = cancelOnVisibilityChange;\n        this._computeSpeed = computeSpeed;\n        this._startPredicate = startPredicate;\n        this._onKeyDown = this._onKeyDown.bind(this);\n        this._onKeyUp = this._onKeyUp.bind(this);\n        this._onTick = this._onTick.bind(this);\n        this._internalCancel = this._internalCancel.bind(this);\n        this._blurCancelHandler = this._blurCancelHandler.bind(this);\n        this.on(\"tick\", this._onTick, this._onTick);\n        document.addEventListener(\"keydown\", this._onKeyDown);\n        document.addEventListener(\"keyup\", this._onKeyUp);\n        if (cancelOnBlur) element?.addEventListener(\"blur\", this._blurCancelHandler);\n        if (cancelOnVisibilityChange) document.addEventListener(\"visibilitychange\", this._internalCancel);\n    }\n    _end(data) {\n        if (!this.drag) return;\n        this._moveKeyTimestamps.clear();\n        this._direction.x = 0;\n        this._direction.y = 0;\n        super._end(data);\n    }\n    _cancel(data) {\n        if (!this.drag) return;\n        this._moveKeyTimestamps.clear();\n        this._direction.x = 0;\n        this._direction.y = 0;\n        super._cancel(data);\n    }\n    _internalCancel() {\n        this.cancel();\n    }\n    _blurCancelHandler() {\n        // If the Draggable has a container defined the dragged element will be\n        // appended to the container, which will cause the element to lose focus\n        // temporarily in some browsers (e.g. Chrome). Draggable will automatically\n        // restore the focus immediately after the element is appended, but the blur\n        // event will be triggered anyway. This is why we need to defer the cancel\n        // call to the next microtask, where we can check if the element is still\n        // focused.\n        queueMicrotask(()=>{\n            if (document.activeElement !== this.element) this.cancel();\n        });\n    }\n    _updateDirection() {\n        const leftTime = $5f12a12b1bebeb44$var$getEarliestTimestamp(this._moveLeftKeys, this._moveKeyTimestamps);\n        const rightTime = $5f12a12b1bebeb44$var$getEarliestTimestamp(this._moveRightKeys, this._moveKeyTimestamps);\n        const upTime = $5f12a12b1bebeb44$var$getEarliestTimestamp(this._moveUpKeys, this._moveKeyTimestamps);\n        const downTime = $5f12a12b1bebeb44$var$getEarliestTimestamp(this._moveDownKeys, this._moveKeyTimestamps);\n        let x = leftTime === rightTime ? 0 : leftTime < rightTime ? -1 : 1;\n        let y = upTime === downTime ? 0 : upTime < downTime ? -1 : 1;\n        // If the direction is NE/NW/SE/SW we need to normalize the direction\n        // vector.\n        if (!(x === 0 || y === 0)) {\n            const normFactor = 1 / (Math.sqrt(x * x + y * y) || 1);\n            x *= normFactor;\n            y *= normFactor;\n        }\n        this._direction.x = x;\n        this._direction.y = y;\n    }\n    _onTick() {\n        this._speed = this._computeSpeed(this);\n    }\n    _onKeyUp(e) {\n        if (this._moveKeyTimestamps.get(e.key)) {\n            this._moveKeyTimestamps.delete(e.key);\n            this._updateDirection();\n        }\n    }\n    _onKeyDown(e) {\n        // Handle start.\n        if (!this.drag) {\n            if (this._startKeys.has(e.key)) {\n                const startPosition = this._startPredicate(e, this);\n                if (startPosition) {\n                    e.preventDefault();\n                    this._start({\n                        type: \"start\",\n                        x: startPosition.x,\n                        y: startPosition.y\n                    });\n                }\n            }\n            return;\n        }\n        // Handle cancel.\n        if (this._cancelKeys.has(e.key)) {\n            e.preventDefault();\n            this._internalCancel();\n            return;\n        }\n        // Handle end.\n        if (this._endKeys.has(e.key)) {\n            e.preventDefault();\n            this._end({\n                type: \"end\",\n                x: this.drag.x,\n                y: this.drag.y\n            });\n            return;\n        }\n        // Handle move.\n        if (this._moveKeys.has(e.key)) {\n            e.preventDefault();\n            if (!this._moveKeyTimestamps.get(e.key)) {\n                this._moveKeyTimestamps.set(e.key, Date.now());\n                this._updateDirection();\n            }\n            return;\n        }\n    }\n    updateSettings(options = {}) {\n        let moveKeysMayNeedUpdate = false;\n        const { cancelOnBlur: cancelOnBlur, cancelOnVisibilityChange: cancelOnVisibilityChange, startPredicate: startPredicate, computeSpeed: computeSpeed } = options;\n        if (cancelOnBlur !== undefined && this._cancelOnBlur !== cancelOnBlur) {\n            this._cancelOnBlur = cancelOnBlur;\n            if (cancelOnBlur) this.element?.addEventListener(\"blur\", this._blurCancelHandler);\n            else this.element?.removeEventListener(\"blur\", this._blurCancelHandler);\n        }\n        if (cancelOnVisibilityChange !== undefined && this._cancelOnVisibilityChange !== cancelOnVisibilityChange) {\n            this._cancelOnVisibilityChange = cancelOnVisibilityChange;\n            if (cancelOnVisibilityChange) document.addEventListener(\"visibilitychange\", this._internalCancel);\n            else document.removeEventListener(\"visibilitychange\", this._internalCancel);\n        }\n        if (startPredicate !== undefined) this._startPredicate = startPredicate;\n        if (computeSpeed !== undefined) this._computeSpeed = computeSpeed;\n        $5f12a12b1bebeb44$var$KEY_TYPES.forEach((keyType, index)=>{\n            const name = `${keyType}Keys`;\n            const value = options[name];\n            if (value !== undefined) {\n                this[`_${name}`] = new Set(value);\n                if (index >= 3) moveKeysMayNeedUpdate = true;\n            }\n        });\n        if (moveKeysMayNeedUpdate) {\n            // Construct the next move keys array.\n            const nextMoveKeys = [\n                ...this._moveLeftKeys,\n                ...this._moveRightKeys,\n                ...this._moveUpKeys,\n                ...this._moveDownKeys\n            ];\n            // Check if the next move keys are equal to the current ones.\n            const areMoveKeysEqual = [\n                ...this._moveKeys\n            ].every((key, index)=>nextMoveKeys[index] === key);\n            // Update move keys if needed.\n            if (!areMoveKeysEqual) {\n                this._moveKeys = new Set(nextMoveKeys);\n                this._moveKeyTimestamps.clear();\n                this._updateDirection();\n            }\n        }\n    }\n    destroy() {\n        if (this.isDestroyed) return;\n        super.destroy();\n        this.off(\"tick\", this._onTick);\n        document.removeEventListener(\"keydown\", this._onKeyDown);\n        document.removeEventListener(\"keyup\", this._onKeyUp);\n        if (this._cancelOnBlur) this.element?.removeEventListener(\"blur\", this._blurCancelHandler);\n        if (this._cancelOnVisibilityChange) document.removeEventListener(\"visibilitychange\", this._internalCancel);\n    }\n}\n\n\n\n\nclass $0895e978c48e9df2$export$ee7258b8691956a3 {\n    constructor(){\n        this.cache = new Map();\n        this.validation = new Map();\n        this.cache = new Map();\n        this.validation = new Map();\n    }\n    set(key, value) {\n        this.cache.set(key, value);\n        this.validation.set(key, undefined);\n    }\n    get(key) {\n        return this.cache.get(key);\n    }\n    has(key) {\n        return this.cache.has(key);\n    }\n    delete(key) {\n        this.cache.delete(key);\n        this.validation.delete(key);\n    }\n    isValid(key) {\n        return this.validation.has(key);\n    }\n    invalidate(key) {\n        if (key === undefined) this.validation.clear();\n        else this.validation.delete(key);\n    }\n    clear() {\n        this.cache.clear();\n        this.validation.clear();\n    }\n}\n\n\nclass $128271867868f1db$export$12e4b40eac1bcb71 {\n    constructor(sensor, startEvent){\n        this.sensor = sensor;\n        this.isEnded = false;\n        this.event = startEvent;\n        this.prevEvent = startEvent;\n        this.startEvent = startEvent;\n        this.endEvent = null;\n        this.items = [];\n        this._measureElements = new Map();\n        this._matrixCache = new (0, $0895e978c48e9df2$export$ee7258b8691956a3)();\n        this._clientOffsetCache = new (0, $0895e978c48e9df2$export$ee7258b8691956a3)();\n    }\n}\n\n\nconst $45554ebda029bd05$var$STYLE_DECLARATION_CACHE = new WeakMap;\nfunction $45554ebda029bd05$export$3d2f074408bd1b82(e, t) {\n    if (t) return window.getComputedStyle(e, t);\n    let C = $45554ebda029bd05$var$STYLE_DECLARATION_CACHE.get(e)?.deref();\n    return C || (C = window.getComputedStyle(e, null), $45554ebda029bd05$var$STYLE_DECLARATION_CACHE.set(e, new WeakRef(C))), C;\n}\n\n\nconst $70e6b31ea6202e28$export$e44ffb50cc242ec5 = \"undefined\" != typeof window && void 0 !== window.document;\nconst $70e6b31ea6202e28$export$af54264dae9065e6 = !!($70e6b31ea6202e28$export$e44ffb50cc242ec5 && navigator.vendor && navigator.vendor.indexOf(\"Apple\") > -1 && navigator.userAgent && -1 == navigator.userAgent.indexOf(\"CriOS\") && -1 == navigator.userAgent.indexOf(\"FxiOS\"));\nconst $70e6b31ea6202e28$export$11fd24d838ebde87 = {\n    content: \"content\",\n    padding: \"padding\",\n    scrollbar: \"scrollbar\",\n    border: \"border\",\n    margin: \"margin\"\n};\nconst $70e6b31ea6202e28$export$76e909bcfd8ba196 = {\n    [$70e6b31ea6202e28$export$11fd24d838ebde87.content]: !1,\n    [$70e6b31ea6202e28$export$11fd24d838ebde87.padding]: !1,\n    [$70e6b31ea6202e28$export$11fd24d838ebde87.scrollbar]: !0,\n    [$70e6b31ea6202e28$export$11fd24d838ebde87.border]: !0,\n    [$70e6b31ea6202e28$export$11fd24d838ebde87.margin]: !0\n};\nconst $70e6b31ea6202e28$export$d2ad2856e215d28e = new Set([\n    \"auto\",\n    \"scroll\"\n]);\nconst $70e6b31ea6202e28$export$cd414719242f618c = (()=>{\n    try {\n        return window.navigator.userAgentData.brands.some(({ brand: n })=>\"Chromium\" === n);\n    } catch (n) {\n        return !1;\n    }\n})();\n\n\n\n\nfunction $ac4a87157cb8fded$export$fab73c3646bf1f5e(e) {\n    switch((0, $45554ebda029bd05$export$3d2f074408bd1b82)(e).display){\n        case \"none\":\n            return null;\n        case \"inline\":\n        case \"contents\":\n            return !1;\n        default:\n            return !0;\n    }\n}\n\n\nfunction $19cb8cdbc5921691$export$e5ce114ae0e5f4e8(n) {\n    const t = (0, $45554ebda029bd05$export$3d2f074408bd1b82)(n);\n    if (!(0, $70e6b31ea6202e28$export$af54264dae9065e6)) {\n        const { filter: n } = t;\n        if (n && \"none\" !== n) return !0;\n        const { backdropFilter: e } = t;\n        if (e && \"none\" !== e) return !0;\n        const { willChange: i } = t;\n        if (i && (i.indexOf(\"filter\") > -1 || i.indexOf(\"backdrop-filter\") > -1)) return !0;\n    }\n    const e = (0, $ac4a87157cb8fded$export$fab73c3646bf1f5e)(n);\n    if (!e) return e;\n    const { transform: i } = t;\n    if (i && \"none\" !== i) return !0;\n    const { perspective: r } = t;\n    if (r && \"none\" !== r) return !0;\n    const { contentVisibility: o } = t;\n    if (o && \"auto\" === o) return !0;\n    const { contain: f } = t;\n    if (f && (\"strict\" === f || \"content\" === f || f.indexOf(\"paint\") > -1 || f.indexOf(\"layout\") > -1)) return !0;\n    const { willChange: c } = t;\n    return !(!c || !(c.indexOf(\"transform\") > -1 || c.indexOf(\"perspective\") > -1 || c.indexOf(\"contain\") > -1)) || !!((0, $70e6b31ea6202e28$export$af54264dae9065e6) && c && c.indexOf(\"filter\") > -1);\n}\n\n\n\n\nfunction $ea1829f02863f9a1$export$996cb64f2dabb66f(t) {\n    return \"static\" !== (0, $45554ebda029bd05$export$3d2f074408bd1b82)(t).position || (0, $19cb8cdbc5921691$export$e5ce114ae0e5f4e8)(t);\n}\n\n\n\nfunction $8d1ba90c23ec3360$export$d8a62a489b442872(e) {\n    return e instanceof HTMLHtmlElement;\n}\n\n\nfunction $1f38751365ebdabf$export$940d8225183e1404(e, t = {}) {\n    if ((0, $8d1ba90c23ec3360$export$d8a62a489b442872)(e)) return e.ownerDocument.defaultView;\n    const n = t.position || (0, $45554ebda029bd05$export$3d2f074408bd1b82)(e).position, { skipDisplayNone: i, container: o } = t;\n    switch(n){\n        case \"static\":\n        case \"relative\":\n        case \"sticky\":\n        case \"-webkit-sticky\":\n            {\n                let t = o || e.parentElement;\n                for(; t;){\n                    const e = (0, $ac4a87157cb8fded$export$fab73c3646bf1f5e)(t);\n                    if (e) return t;\n                    if (null === e && !i) return null;\n                    t = t.parentElement;\n                }\n                return e.ownerDocument.documentElement;\n            }\n        case \"absolute\":\n        case \"fixed\":\n            {\n                const t = \"fixed\" === n;\n                let l = o || e.parentElement;\n                for(; l;){\n                    const e = t ? (0, $19cb8cdbc5921691$export$e5ce114ae0e5f4e8)(l) : (0, $ea1829f02863f9a1$export$996cb64f2dabb66f)(l);\n                    if (!0 === e) return l;\n                    if (null === e && !i) return null;\n                    l = l.parentElement;\n                }\n                return e.ownerDocument.defaultView;\n            }\n        default:\n            return null;\n    }\n}\n\n\nfunction $15174ae68f2a890f$export$8d3dd0be5eb9f11f(t, e) {\n    return !(t.left + t.width <= e.left || e.left + e.width <= t.left || t.top + t.height <= e.top || e.top + e.height <= t.top);\n}\n\n\nfunction $6473c4721ef9a7f0$export$53137579a3174918(t, e, n, o) {\n    return Math.sqrt(Math.pow(n - t, 2) + Math.pow(o - e, 2));\n}\n\n\nfunction $1565a77b3ba33365$export$2d670be792dba464(t, e) {\n    if ((0, $15174ae68f2a890f$export$8d3dd0be5eb9f11f)(t, e)) return null;\n    const n = t.left + t.width, i = t.top + t.height, o = e.left + e.width, s = e.top + e.height;\n    return n <= e.left ? i <= e.top ? (0, $6473c4721ef9a7f0$export$53137579a3174918)(n, i, e.left, e.top) : t.top >= s ? (0, $6473c4721ef9a7f0$export$53137579a3174918)(n, t.top, e.left, s) : e.left - n : t.left >= o ? i <= e.top ? (0, $6473c4721ef9a7f0$export$53137579a3174918)(t.left, i, o, e.top) : t.top >= s ? (0, $6473c4721ef9a7f0$export$53137579a3174918)(t.left, t.top, o, s) : t.left - o : i <= e.top ? e.top - i : t.top - s;\n}\n\n\n\nfunction $0dd5d633d9254ede$export$5a096129d439f843(n) {\n    return n instanceof Window;\n}\n\n\nfunction $88986006632f0ab8$export$62858bae88b53fd0(n) {\n    return n instanceof Document;\n}\n\n\n\n\nconst $9a36d0396b9b09d4$var$SUBPIXEL_OFFSET = new Map;\nlet $9a36d0396b9b09d4$var$testStyleElement = null, $9a36d0396b9b09d4$var$testParentElement = null, $9a36d0396b9b09d4$var$testChildElement = null;\nfunction $9a36d0396b9b09d4$var$getSubpixelScrollbarSize(t, e) {\n    const n = t.split(\".\");\n    let l = $9a36d0396b9b09d4$var$SUBPIXEL_OFFSET.get(n[1]);\n    if (void 0 === l) {\n        $9a36d0396b9b09d4$var$testStyleElement || ($9a36d0396b9b09d4$var$testStyleElement = document.createElement(\"style\")), $9a36d0396b9b09d4$var$testStyleElement.innerHTML = `\\n      #mezr-scrollbar-test::-webkit-scrollbar {\\n        width: ${t} !important;\\n      }\\n    `, $9a36d0396b9b09d4$var$testParentElement && $9a36d0396b9b09d4$var$testChildElement || ($9a36d0396b9b09d4$var$testParentElement = document.createElement(\"div\"), $9a36d0396b9b09d4$var$testChildElement = document.createElement(\"div\"), $9a36d0396b9b09d4$var$testParentElement.appendChild($9a36d0396b9b09d4$var$testChildElement), $9a36d0396b9b09d4$var$testParentElement.id = \"mezr-scrollbar-test\", $9a36d0396b9b09d4$var$testParentElement.style.cssText = \"\\n        all: unset !important;\\n        position: fixed !important;\\n        top: -200px !important;\\n        left: 0px !important;\\n        width: 100px !important;\\n        height: 100px !important;\\n        overflow: scroll !important;\\n        pointer-events: none !important;\\n        visibility: hidden !important;\\n      \", $9a36d0396b9b09d4$var$testChildElement.style.cssText = \"\\n        all: unset !important;\\n        position: absolute !important;\\n        inset: 0 !important;\\n      \"), document.body.appendChild($9a36d0396b9b09d4$var$testStyleElement), document.body.appendChild($9a36d0396b9b09d4$var$testParentElement);\n        l = $9a36d0396b9b09d4$var$testParentElement.getBoundingClientRect().width - $9a36d0396b9b09d4$var$testChildElement.getBoundingClientRect().width - e, $9a36d0396b9b09d4$var$SUBPIXEL_OFFSET.set(n[1], l), document.body.removeChild($9a36d0396b9b09d4$var$testParentElement), document.body.removeChild($9a36d0396b9b09d4$var$testStyleElement);\n    }\n    return e + l;\n}\nfunction $9a36d0396b9b09d4$export$5ad86f4734d24a64(t, e, n) {\n    if (n <= 0) return 0;\n    if (0, $70e6b31ea6202e28$export$cd414719242f618c) {\n        const n = (0, $45554ebda029bd05$export$3d2f074408bd1b82)(t, \"::-webkit-scrollbar\"), l = \"x\" === e ? n.height : n.width, i = parseFloat(l);\n        if (!Number.isNaN(i) && !Number.isInteger(i)) return $9a36d0396b9b09d4$var$getSubpixelScrollbarSize(l, i);\n    }\n    return n;\n}\n\n\nfunction $9bae4574eed9d865$export$91cf85d6c980faa0(e, r = !1) {\n    if (r) return e.innerWidth;\n    const { innerWidth: t, document: i } = e, { documentElement: n } = i, { clientWidth: c } = n;\n    return t - (0, $9a36d0396b9b09d4$export$5ad86f4734d24a64)(n, \"y\", t - c);\n}\n\n\nfunction $50cb9a0c1dee19de$export$a76b7f4aaec6cdf4({ documentElement: t }) {\n    return Math.max(t.scrollWidth, t.clientWidth, t.getBoundingClientRect().width);\n}\n\n\n\n\n\n\nfunction $f1039b87670ca1f4$export$742d7f6cc44470f1(t, e = (0, $70e6b31ea6202e28$export$11fd24d838ebde87).border) {\n    let { width: r } = t.getBoundingClientRect();\n    if (e === (0, $70e6b31ea6202e28$export$11fd24d838ebde87).border) return r;\n    const o = (0, $45554ebda029bd05$export$3d2f074408bd1b82)(t);\n    return e === (0, $70e6b31ea6202e28$export$11fd24d838ebde87).margin ? (r += Math.max(0, parseFloat(o.marginLeft) || 0), r += Math.max(0, parseFloat(o.marginRight) || 0), r) : (r -= parseFloat(o.borderLeftWidth) || 0, r -= parseFloat(o.borderRightWidth) || 0, e === (0, $70e6b31ea6202e28$export$11fd24d838ebde87).scrollbar ? r : (!(0, $8d1ba90c23ec3360$export$d8a62a489b442872)(t) && (0, $70e6b31ea6202e28$export$d2ad2856e215d28e).has(o.overflowY) && (r -= (0, $9a36d0396b9b09d4$export$5ad86f4734d24a64)(t, \"y\", Math.round(r) - t.clientWidth)), e === (0, $70e6b31ea6202e28$export$11fd24d838ebde87).padding || (r -= parseFloat(o.paddingLeft) || 0, r -= parseFloat(o.paddingRight) || 0), r));\n}\n\n\nfunction $2e59c48b8f000a71$export$3c49c185de0c2bfc(t, i = (0, $70e6b31ea6202e28$export$11fd24d838ebde87).border) {\n    return (0, $0dd5d633d9254ede$export$5a096129d439f843)(t) ? (0, $9bae4574eed9d865$export$91cf85d6c980faa0)(t, (0, $70e6b31ea6202e28$export$76e909bcfd8ba196)[i]) : (0, $88986006632f0ab8$export$62858bae88b53fd0)(t) ? (0, $50cb9a0c1dee19de$export$a76b7f4aaec6cdf4)(t) : (0, $f1039b87670ca1f4$export$742d7f6cc44470f1)(t, i);\n}\n\n\n\n\n\n\nfunction $421143bc1c1515a1$export$a3648dbc3769cbf4(e, r = !1) {\n    if (r) return e.innerHeight;\n    const { innerHeight: t, document: i } = e, { documentElement: n } = i, { clientHeight: c } = n;\n    return t - (0, $9a36d0396b9b09d4$export$5ad86f4734d24a64)(n, \"x\", t - c);\n}\n\n\nfunction $8e302b6d23f55757$export$5806f5d4b3eb6a6a({ documentElement: t }) {\n    return Math.max(t.scrollHeight, t.clientHeight, t.getBoundingClientRect().height);\n}\n\n\n\n\n\n\nfunction $598de259e69a6df4$export$8e0f1520ce23a388(t, e = (0, $70e6b31ea6202e28$export$11fd24d838ebde87).border) {\n    let { height: r } = t.getBoundingClientRect();\n    if (e === (0, $70e6b31ea6202e28$export$11fd24d838ebde87).border) return r;\n    const o = (0, $45554ebda029bd05$export$3d2f074408bd1b82)(t);\n    return e === (0, $70e6b31ea6202e28$export$11fd24d838ebde87).margin ? (r += Math.max(0, parseFloat(o.marginTop) || 0), r += Math.max(0, parseFloat(o.marginBottom) || 0), r) : (r -= parseFloat(o.borderTopWidth) || 0, r -= parseFloat(o.borderBottomWidth) || 0, e === (0, $70e6b31ea6202e28$export$11fd24d838ebde87).scrollbar ? r : (!(0, $8d1ba90c23ec3360$export$d8a62a489b442872)(t) && (0, $70e6b31ea6202e28$export$d2ad2856e215d28e).has(o.overflowX) && (r -= (0, $9a36d0396b9b09d4$export$5ad86f4734d24a64)(t, \"x\", Math.round(r) - t.clientHeight)), e === (0, $70e6b31ea6202e28$export$11fd24d838ebde87).padding || (r -= parseFloat(o.paddingTop) || 0, r -= parseFloat(o.paddingBottom) || 0), r));\n}\n\n\nfunction $646cecfa59ec4923$export$c08559766941f856(t, e = (0, $70e6b31ea6202e28$export$11fd24d838ebde87).border) {\n    return (0, $0dd5d633d9254ede$export$5a096129d439f843)(t) ? (0, $421143bc1c1515a1$export$a3648dbc3769cbf4)(t, (0, $70e6b31ea6202e28$export$76e909bcfd8ba196)[e]) : (0, $88986006632f0ab8$export$62858bae88b53fd0)(t) ? (0, $8e302b6d23f55757$export$5806f5d4b3eb6a6a)(t) : (0, $598de259e69a6df4$export$8e0f1520ce23a388)(t, e);\n}\n\n\nfunction $4de8edd731addea8$export$ff047630cae37d8e(t) {\n    return t?.constructor === Object;\n}\n\n\n\n\n\n\n\nfunction $faeeed2de97ac6f7$export$9f1480883798e819(t, o = (0, $70e6b31ea6202e28$export$11fd24d838ebde87).border) {\n    const e = {\n        left: 0,\n        top: 0\n    };\n    if ((0, $88986006632f0ab8$export$62858bae88b53fd0)(t)) return e;\n    if ((0, $0dd5d633d9254ede$export$5a096129d439f843)(t)) return e.left += t.scrollX || 0, e.top += t.scrollY || 0, e;\n    const r = t.ownerDocument.defaultView;\n    r && (e.left += r.scrollX || 0, e.top += r.scrollY || 0);\n    const n = t.getBoundingClientRect();\n    if (e.left += n.left, e.top += n.top, o === (0, $70e6b31ea6202e28$export$11fd24d838ebde87).border) return e;\n    const l = (0, $45554ebda029bd05$export$3d2f074408bd1b82)(t);\n    return o === (0, $70e6b31ea6202e28$export$11fd24d838ebde87).margin ? (e.left -= Math.max(0, parseFloat(l.marginLeft) || 0), e.top -= Math.max(0, parseFloat(l.marginTop) || 0), e) : (e.left += parseFloat(l.borderLeftWidth) || 0, e.top += parseFloat(l.borderTopWidth) || 0, o === (0, $70e6b31ea6202e28$export$11fd24d838ebde87).scrollbar || o === (0, $70e6b31ea6202e28$export$11fd24d838ebde87).padding || (e.left += parseFloat(l.paddingLeft) || 0, e.top += parseFloat(l.paddingTop) || 0), e);\n}\n\n\nfunction $d927f435c3d7e8ab$export$622cea445a1c5b7d(t, e) {\n    const o = (0, $4de8edd731addea8$export$ff047630cae37d8e)(t) ? {\n        left: t.left,\n        top: t.top\n    } : Array.isArray(t) ? (0, $faeeed2de97ac6f7$export$9f1480883798e819)(...t) : (0, $faeeed2de97ac6f7$export$9f1480883798e819)(t);\n    if (e && !(0, $88986006632f0ab8$export$62858bae88b53fd0)(e)) {\n        const t = (0, $4de8edd731addea8$export$ff047630cae37d8e)(e) ? e : Array.isArray(e) ? (0, $faeeed2de97ac6f7$export$9f1480883798e819)(e[0], e[1]) : (0, $faeeed2de97ac6f7$export$9f1480883798e819)(e);\n        o.left -= t.left, o.top -= t.top;\n    }\n    return o;\n}\n\n\n\nfunction $4fec7741c67a29fc$export$4b834cebd9e5cebe(t, e) {\n    let i = 0, g = 0;\n    (0, $4de8edd731addea8$export$ff047630cae37d8e)(t) ? (i = t.width, g = t.height) : Array.isArray(t) ? (i = (0, $2e59c48b8f000a71$export$3c49c185de0c2bfc)(...t), g = (0, $646cecfa59ec4923$export$c08559766941f856)(...t)) : (i = (0, $2e59c48b8f000a71$export$3c49c185de0c2bfc)(t), g = (0, $646cecfa59ec4923$export$c08559766941f856)(t));\n    const r = (0, $d927f435c3d7e8ab$export$622cea445a1c5b7d)(t, e);\n    return {\n        width: i,\n        height: g,\n        ...r,\n        right: r.left + i,\n        bottom: r.top + g\n    };\n}\n\n\n\nfunction $3fe9db1ad94d3e7c$export$e4e616e82e79ab9d(t) {\n    return (0, $4de8edd731addea8$export$ff047630cae37d8e)(t) ? t : (0, $4fec7741c67a29fc$export$4b834cebd9e5cebe)(t);\n}\n\n\nfunction $2a599c00d4ed99d6$export$79376507b09a66f(e, t) {\n    const c = (0, $3fe9db1ad94d3e7c$export$e4e616e82e79ab9d)(e), i = (0, $3fe9db1ad94d3e7c$export$e4e616e82e79ab9d)(t);\n    return (0, $1565a77b3ba33365$export$2d670be792dba464)(c, i);\n}\n\n\n\n\nfunction $e931ad6985aacff5$export$72209efa88586d42(t, ...e) {\n    const o = {\n        ...(0, $3fe9db1ad94d3e7c$export$e4e616e82e79ab9d)(t),\n        right: 0,\n        bottom: 0\n    };\n    for (const t of e){\n        const e = (0, $3fe9db1ad94d3e7c$export$e4e616e82e79ab9d)(t), i = Math.max(o.left, e.left), h = Math.min(o.left + o.width, e.left + e.width);\n        if (h <= i) return null;\n        const r = Math.max(o.top, e.top), l = Math.min(o.top + o.height, e.height + e.top);\n        if (l <= r) return null;\n        o.left = i, o.top = r, o.width = h - i, o.height = l - r;\n    }\n    return o.right = o.left + o.width, o.bottom = o.top + o.height, o;\n}\n\n\n\n\n\n\nfunction $4effe6f7501c7f59$export$243d7fadef466e38(n, t = {}) {\n    const i = (0, $45554ebda029bd05$export$3d2f074408bd1b82)(n), { display: o } = i;\n    if (\"none\" === o || \"contents\" === o) return null;\n    const e = t.position || (0, $45554ebda029bd05$export$3d2f074408bd1b82)(n).position, { skipDisplayNone: s, container: r } = t;\n    switch(e){\n        case \"relative\":\n            return n;\n        case \"fixed\":\n            return (0, $1f38751365ebdabf$export$940d8225183e1404)(n, {\n                container: r,\n                position: e,\n                skipDisplayNone: s\n            });\n        case \"absolute\":\n            {\n                const t = (0, $1f38751365ebdabf$export$940d8225183e1404)(n, {\n                    container: r,\n                    position: e,\n                    skipDisplayNone: s\n                });\n                return (0, $0dd5d633d9254ede$export$5a096129d439f843)(t) ? n.ownerDocument : t;\n            }\n        default:\n            return null;\n    }\n}\n\n\n\nfunction $28b6730affddb905$export$f63a1e5ecde5e3c4(t, e) {\n    const o = (0, $3fe9db1ad94d3e7c$export$e4e616e82e79ab9d)(t), i = (0, $3fe9db1ad94d3e7c$export$e4e616e82e79ab9d)(e);\n    return {\n        left: i.left - o.left,\n        right: o.left + o.width - (i.left + i.width),\n        top: i.top - o.top,\n        bottom: o.top + o.height - (i.top + i.height)\n    };\n}\n\n\n\n\n\n\nconst $0c69ffc8ab90052a$var$STYLE_DECLARATION_CACHE = new WeakMap();\nfunction $0c69ffc8ab90052a$export$3d2f074408bd1b82(element) {\n    let styleDeclaration = $0c69ffc8ab90052a$var$STYLE_DECLARATION_CACHE.get(element)?.deref();\n    if (!styleDeclaration) {\n        styleDeclaration = window.getComputedStyle(element, null);\n        $0c69ffc8ab90052a$var$STYLE_DECLARATION_CACHE.set(element, new WeakRef(styleDeclaration));\n    }\n    return styleDeclaration;\n}\n\n\n\nfunction $4131ae5fcb5e2d41$export$ee9ce4f6079fba39(element, result = {\n    x: 0,\n    y: 0\n}) {\n    result.x = 0;\n    result.y = 0;\n    // If window, return 0, 0.\n    if (element instanceof Window) return result;\n    // If document, return the offset from Window.\n    if (element instanceof Document) {\n        result.x = window.scrollX * -1;\n        result.y = window.scrollY * -1;\n        return result;\n    }\n    // If element, calculate the offset from the element's padding box to the\n    // window's top-left corner.\n    const { x: x, y: y } = element.getBoundingClientRect();\n    const style = (0, $0c69ffc8ab90052a$export$3d2f074408bd1b82)(element);\n    result.x = x + (parseFloat(style.borderLeftWidth) || 0);\n    result.y = y + (parseFloat(style.borderTopWidth) || 0);\n    return result;\n}\n\n\n\nfunction $e38b00c029207e64$export$aff838a5553f2a92(value) {\n    return typeof value === \"object\" && value !== null && \"x\" in value && \"y\" in value;\n}\n\n\nconst $5b850440d58ca286$var$OFFSET_A = {\n    x: 0,\n    y: 0\n};\nconst $5b850440d58ca286$var$OFFSET_B = {\n    x: 0,\n    y: 0\n};\nfunction $5b850440d58ca286$export$5e94c6e790b2d913(elemA, elemB, result = {\n    x: 0,\n    y: 0\n}) {\n    const offsetA = (0, $e38b00c029207e64$export$aff838a5553f2a92)(elemA) ? elemA : (0, $4131ae5fcb5e2d41$export$ee9ce4f6079fba39)(elemA, $5b850440d58ca286$var$OFFSET_A);\n    const offsetB = (0, $e38b00c029207e64$export$aff838a5553f2a92)(elemB) ? elemB : (0, $4131ae5fcb5e2d41$export$ee9ce4f6079fba39)(elemB, $5b850440d58ca286$var$OFFSET_B);\n    result.x = offsetB.x - offsetA.x;\n    result.y = offsetB.y - offsetA.y;\n    return result;\n}\n\n\n\nfunction $3b22a72fa25b3514$export$808822009ec670b1(transformOrigin) {\n    const values = transformOrigin.split(\" \");\n    let originX = \"\";\n    let originY = \"\";\n    let originZ = \"\";\n    if (values.length === 1) originX = originY = values[0];\n    else if (values.length === 2) [originX, originY] = values;\n    else [originX, originY, originZ] = values;\n    return {\n        x: parseFloat(originX) || 0,\n        y: parseFloat(originY) || 0,\n        z: parseFloat(originZ) || 0\n    };\n}\n\n\nconst $dac91faf2d28787e$var$RESET_TRANSFORM = \"scale(1, 1)\";\nfunction $dac91faf2d28787e$export$5e2c7a53f84076f2(m) {\n    return m.setMatrixValue($dac91faf2d28787e$var$RESET_TRANSFORM);\n}\n\n\nconst $13dbe18eb44f2213$var$MATRIX = new DOMMatrix();\nfunction $13dbe18eb44f2213$export$10e4b24b91657790(el, result = new DOMMatrix()) {\n    let currentElement = el;\n    // Reset the result matrix to identity.\n    (0, $dac91faf2d28787e$export$5e2c7a53f84076f2)(result);\n    while(currentElement){\n        const { transform: transform, transformOrigin: transformOrigin } = (0, $0c69ffc8ab90052a$export$3d2f074408bd1b82)(currentElement);\n        if (transform && transform !== \"none\") {\n            $13dbe18eb44f2213$var$MATRIX.setMatrixValue(transform);\n            if (!$13dbe18eb44f2213$var$MATRIX.isIdentity) {\n                const { x: x, y: y, z: z } = (0, $3b22a72fa25b3514$export$808822009ec670b1)(transformOrigin);\n                if (z === 0) $13dbe18eb44f2213$var$MATRIX.setMatrixValue(`translate(${x}px, ${y}px) ${$13dbe18eb44f2213$var$MATRIX} translate(${x * -1}px, ${y * -1}px)`);\n                else $13dbe18eb44f2213$var$MATRIX.setMatrixValue(`translate3d(${x}px, ${y}px, ${z}px) ${$13dbe18eb44f2213$var$MATRIX} translate3d(${x * -1}px, ${y * -1}px, ${z * -1}px)`);\n                result.preMultiplySelf($13dbe18eb44f2213$var$MATRIX);\n            }\n        }\n        currentElement = currentElement.parentElement;\n    }\n    return result;\n}\n\n\nfunction $4e5a7538a780db09$export$ac3d318a39e8020a(el, styles, important = false) {\n    const { style: style } = el;\n    for(const key in styles)style.setProperty(key, styles[key], important ? \"important\" : \"\");\n}\n\n\nfunction $2197e65f98ca3f10$export$fa9b558c7fbc1e8a(isMeasureElement = false) {\n    const el = document.createElement(\"div\");\n    (0, $4e5a7538a780db09$export$ac3d318a39e8020a)(el, Object.assign({\n        display: \"block\",\n        position: \"absolute\",\n        padding: \"0px\",\n        margin: \"0px\",\n        border: \"none\",\n        transform: \"none\",\n        \"transform-origin\": \"0 0\",\n        transition: \"none\",\n        animation: \"none\"\n    }, isMeasureElement ? {\n        inset: \"0px\",\n        opacity: \"0\",\n        \"pointer-events\": \"none\"\n    } : {\n        width: \"0px\",\n        height: \"0px\",\n        left: \"0px\",\n        top: \"0px\"\n    }), true);\n    if (isMeasureElement) el.classList.add(\"dragdoll-measure\");\n    else el.classList.add(\"dragdoll-container\");\n    return el;\n}\n\n\n// The naming is a bit misleading here, but this function in essence checks if a\n// matrix contains any transformation other than a 2d translation.\nfunction $22d354ae089695b3$export$8317bebcfd6ca26c(m) {\n    return m.m11 !== 1 || m.m12 !== 0 || m.m13 !== 0 || m.m14 !== 0 || m.m21 !== 0 || m.m22 !== 1 || m.m23 !== 0 || m.m24 !== 0 || m.m31 !== 0 || m.m32 !== 0 || m.m33 !== 1 || m.m34 !== 0 || m.m43 !== 0 || m.m44 !== 1;\n}\n\n\n\nclass $6985a94cfe75e842$export$b87fb2dc7f11ca52 {\n    constructor(element, draggable){\n        // Make sure the element is in DOM.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected\n        if (!element.isConnected) throw new Error(\"Element is not connected\");\n        // Make sure drag is defined.\n        const { drag: drag } = draggable;\n        if (!drag) throw new Error(\"Drag is not defined\");\n        const style = (0, $0c69ffc8ab90052a$export$3d2f074408bd1b82)(element);\n        const clientRect = element.getBoundingClientRect();\n        this.data = {};\n        this.element = element;\n        this.elementTransformOrigin = (0, $3b22a72fa25b3514$export$808822009ec670b1)(style.transformOrigin);\n        this.elementTransformMatrix = new DOMMatrix().setMatrixValue(style.transform);\n        this.frozenProps = null;\n        this.unfrozenProps = null;\n        this.position = {\n            x: 0,\n            y: 0\n        };\n        this.containerOffset = {\n            x: 0,\n            y: 0\n        };\n        this.startOffset = {\n            x: 0,\n            y: 0\n        };\n        this._moveDiff = {\n            x: 0,\n            y: 0\n        };\n        this._alignDiff = {\n            x: 0,\n            y: 0\n        };\n        this._measureElements = drag[\"_measureElements\"];\n        this._matrixCache = drag[\"_matrixCache\"];\n        this._clientOffsetCache = drag[\"_clientOffsetCache\"];\n        // Use element's parent element as the element container.\n        const elementContainer = element.parentElement;\n        if (!elementContainer) throw new Error(\"Dragged element does not have a parent element.\");\n        this.elementContainer = elementContainer;\n        // Get element's drag parent, default to element's parent element.\n        const dragContainer = draggable.settings.container || elementContainer;\n        this.dragContainer = dragContainer;\n        // Make sure that the element is fixed or absolute positioned if there\n        // is a drag container.\n        if (elementContainer !== dragContainer) {\n            const { position: position } = style;\n            if (position !== \"fixed\" && position !== \"absolute\") throw new Error(`Dragged element has \"${position}\" position, but only \"fixed\" or \"absolute\" are allowed when using a custom drag container.`);\n        }\n        // Compute element's offset container.\n        const elementOffsetContainer = (0, $4effe6f7501c7f59$export$243d7fadef466e38)(element) || element;\n        this.elementOffsetContainer = elementOffsetContainer;\n        // Get drag container's offset container.\n        const dragOffsetContainer = dragContainer === elementContainer ? elementOffsetContainer : (0, $4effe6f7501c7f59$export$243d7fadef466e38)(element, {\n            container: dragContainer\n        });\n        this.dragOffsetContainer = dragOffsetContainer;\n        // Compute element's client rect.\n        {\n            const { width: width, height: height, x: x, y: y } = clientRect;\n            this.clientRect = {\n                width: width,\n                height: height,\n                x: x,\n                y: y\n            };\n        }\n        // Compute container matrices and offset.\n        this._computeContainerMatrices();\n        this.updateContainerOffset();\n        // Get element's initial position. This position is relative to the\n        // properties the user is using to move the element. For example, if the\n        // user is using the `translate` transform to move the element then the\n        // initial position will be relative to the `translate` transform and the\n        // position here should reflect the transform value delta.\n        const { x: x, y: y } = draggable.settings.getStartPosition({\n            draggable: draggable,\n            sensor: drag.sensor,\n            item: this,\n            style: style\n        });\n        this.position.x = x;\n        this.position.y = y;\n        // Get element's frozen props.\n        const frozenProps = draggable.settings.getFrozenProps({\n            draggable: draggable,\n            sensor: drag.sensor,\n            item: this,\n            style: style\n        });\n        if (Array.isArray(frozenProps)) {\n            if (frozenProps.length) {\n                const props = {};\n                for (const prop of frozenProps)props[prop] = style[prop];\n                this.frozenProps = props;\n            } else this.frozenProps = null;\n        } else this.frozenProps = frozenProps;\n        // Lastly, let's compute the unfrozen props. We store the current inline\n        // style values for all frozen props so that we can restore them after the\n        // drag process is over.\n        if (this.frozenProps) {\n            const unfrozenProps = {};\n            for(const key in this.frozenProps)if (this.frozenProps.hasOwnProperty(key)) unfrozenProps[key] = element.style[key];\n            this.unfrozenProps = unfrozenProps;\n        }\n    }\n    _computeContainerMatrices() {\n        [\n            this.elementContainer,\n            this.dragContainer\n        ].forEach((container)=>{\n            if (!this._matrixCache.isValid(container)) {\n                const matrices = this._matrixCache.get(container) || [\n                    new DOMMatrix(),\n                    new DOMMatrix()\n                ];\n                const [matrix, inverseMatrix] = matrices;\n                (0, $13dbe18eb44f2213$export$10e4b24b91657790)(container, matrix);\n                inverseMatrix.setMatrixValue(matrix.toString()).invertSelf();\n                this._matrixCache.set(container, matrices);\n            }\n        });\n    }\n    getContainerMatrix() {\n        return this._matrixCache.get(this.elementContainer);\n    }\n    getDragContainerMatrix() {\n        return this._matrixCache.get(this.dragContainer);\n    }\n    updateContainerOffset(force = false) {\n        const { elementOffsetContainer: elementOffsetContainer, elementContainer: elementContainer, dragOffsetContainer: dragOffsetContainer, dragContainer: dragContainer, containerOffset: containerOffset, _clientOffsetCache: _clientOffsetCache, _matrixCache: _matrixCache } = this;\n        // If force is true, invalidate the client offset cache.\n        if (force) {\n            _clientOffsetCache.invalidate(dragOffsetContainer);\n            _clientOffsetCache.invalidate(elementOffsetContainer);\n        }\n        // If element's offset container is different than drag container's\n        // offset container let's compute the offset between the offset containers.\n        if (elementOffsetContainer !== dragOffsetContainer) {\n            // Get the client offsets for the element and drag containers.\n            const [dragOffset, elementOffset] = [\n                [\n                    dragContainer,\n                    dragOffsetContainer\n                ],\n                [\n                    elementContainer,\n                    elementOffsetContainer\n                ]\n            ].map(([container, offsetContainer])=>{\n                // Get the client offset from the cache or create a new one.\n                const offset = _clientOffsetCache.get(offsetContainer) || {\n                    x: 0,\n                    y: 0\n                };\n                // If the client offset is not cached let's compute it.\n                if (!_clientOffsetCache.isValid(offsetContainer)) {\n                    // Get the world transform matrices.\n                    const matrices = _matrixCache.get(container);\n                    // If the offset container is a valid HTMLElement and the matrix is\n                    // not an identity matrix we need to do some extra work.\n                    if (offsetContainer instanceof HTMLElement && matrices && !matrices[0].isIdentity) {\n                        // If the matrix is scaled, rotated, skewed or 3d translated we\n                        // (unfortunately) need to add a temporary measure element to\n                        // compute the untransformed offset from the window's top-left\n                        // corner. If there was a way to compute the offset without\n                        // manipulating the DOM, we would definitely do that, but\n                        // unfortunately, there seems to be no way to do that accurately\n                        // with subpixel precision.\n                        if ((0, $22d354ae089695b3$export$8317bebcfd6ca26c)(matrices[0])) {\n                            const measureElement = this._measureElements.get(offsetContainer) || (0, $2197e65f98ca3f10$export$fa9b558c7fbc1e8a)(true);\n                            measureElement.style.setProperty(\"transform\", matrices[1].toString(), \"important\");\n                            if (!measureElement.isConnected) {\n                                this._measureElements.set(offsetContainer, measureElement);\n                                offsetContainer.append(measureElement);\n                            }\n                            (0, $4131ae5fcb5e2d41$export$ee9ce4f6079fba39)(measureElement, offset);\n                        } else {\n                            (0, $4131ae5fcb5e2d41$export$ee9ce4f6079fba39)(offsetContainer, offset);\n                            offset.x -= matrices[0].m41;\n                            offset.y -= matrices[0].m42;\n                        }\n                    } else (0, $4131ae5fcb5e2d41$export$ee9ce4f6079fba39)(offsetContainer, offset);\n                }\n                // Cache the client offset.\n                _clientOffsetCache.set(offsetContainer, offset);\n                return offset;\n            });\n            (0, $5b850440d58ca286$export$5e94c6e790b2d913)(dragOffset, elementOffset, containerOffset);\n        } else {\n            containerOffset.x = 0;\n            containerOffset.y = 0;\n        }\n    }\n    updateSize(dimensions) {\n        if (dimensions) {\n            this.clientRect.width = dimensions.width;\n            this.clientRect.height = dimensions.height;\n        } else {\n            const { width: width, height: height } = this.element.getBoundingClientRect();\n            this.clientRect.width = width;\n            this.clientRect.height = height;\n        }\n    }\n}\n\n\n\n// A special append method which doesn't lose focus when appending an element.\nfunction $71d766ad3004a578$export$33e13bbfe889ab45(element, container, innerContainer) {\n    const focusedElement = document.activeElement;\n    const containsFocus = element.contains(focusedElement);\n    if (innerContainer) innerContainer.append(element);\n    container.append(innerContainer || element);\n    if (containsFocus && document.activeElement !== focusedElement) focusedElement.focus({\n        preventScroll: true\n    });\n}\n\n\nfunction $73b931158359019b$export$a3992db8dd0fd9e6(value, decimals = 0) {\n    const multiplier = Math.pow(10, decimals);\n    return Math.round((value + Number.EPSILON) * multiplier) / multiplier;\n}\n\n\n\nfunction $f0aa8b1322987ed0$export$da3f9f1be978dbbc(m1, m2) {\n    if (m1.isIdentity && m2.isIdentity) return true;\n    if (m1.is2D && m2.is2D) return m1.a === m2.a && m1.b === m2.b && m1.c === m2.c && m1.d === m2.d && m1.e === m2.e && m1.f === m2.f;\n    return m1.m11 === m2.m11 && m1.m12 === m2.m12 && m1.m13 === m2.m13 && m1.m14 === m2.m14 && m1.m21 === m2.m21 && m1.m22 === m2.m22 && m1.m23 === m2.m23 && m1.m24 === m2.m24 && m1.m31 === m2.m31 && m1.m32 === m2.m32 && m1.m33 === m2.m33 && m1.m34 === m2.m34 && m1.m41 === m2.m41 && m1.m42 === m2.m42 && m1.m43 === m2.m43 && m1.m44 === m2.m44;\n}\n\n\nconst $e9cd0e353e15b4ae$var$SCROLL_LISTENER_OPTIONS = (0, $9ecda7333d28e490$export$ffcf6b6ce241bd05) ? {\n    capture: true,\n    passive: true\n} : true;\nconst $e9cd0e353e15b4ae$var$POSITION_CHANGE = {\n    x: 0,\n    y: 0\n};\nconst $e9cd0e353e15b4ae$var$DOM_MATRIX = new DOMMatrix();\nconst $e9cd0e353e15b4ae$var$TEMP_MATRIX = new DOMMatrix();\nvar $e9cd0e353e15b4ae$var$DragStartPhase;\n(function(DragStartPhase) {\n    DragStartPhase[DragStartPhase[\"NONE\"] = 0] = \"NONE\";\n    DragStartPhase[DragStartPhase[\"INIT\"] = 1] = \"INIT\";\n    DragStartPhase[DragStartPhase[\"START_PREPARE\"] = 2] = \"START_PREPARE\";\n    DragStartPhase[DragStartPhase[\"FINISH_APPLY\"] = 3] = \"FINISH_APPLY\";\n})($e9cd0e353e15b4ae$var$DragStartPhase || ($e9cd0e353e15b4ae$var$DragStartPhase = {}));\nvar $e9cd0e353e15b4ae$var$DraggableStartPredicateState;\n(function(DraggableStartPredicateState) {\n    DraggableStartPredicateState[DraggableStartPredicateState[\"PENDING\"] = 0] = \"PENDING\";\n    DraggableStartPredicateState[DraggableStartPredicateState[\"RESOLVED\"] = 1] = \"RESOLVED\";\n    DraggableStartPredicateState[DraggableStartPredicateState[\"REJECTED\"] = 2] = \"REJECTED\";\n})($e9cd0e353e15b4ae$var$DraggableStartPredicateState || ($e9cd0e353e15b4ae$var$DraggableStartPredicateState = {}));\nconst $e9cd0e353e15b4ae$export$7ce0cd3869d5dcd9 = {\n    container: null,\n    startPredicate: ()=>true,\n    getElements: ()=>null,\n    releaseElements: ()=>null,\n    getFrozenProps: ()=>null,\n    getStartPosition: ()=>{\n        return {\n            x: 0,\n            y: 0\n        };\n    },\n    setPosition: ({ item: item, x: x, y: y, phase: phase })=>{\n        const isEndPhase = phase === \"end\";\n        const [containerMatrix, inverseContainerMatrix] = item.getContainerMatrix();\n        const [_dragContainerMatrix, inverseDragContainerMatrix] = item.getDragContainerMatrix();\n        const { startOffset: startOffset, containerOffset: containerOffset, elementTransformMatrix: elementTransformMatrix, elementTransformOrigin: elementTransformOrigin } = item;\n        const { x: oX, y: oY, z: oZ } = elementTransformOrigin;\n        const needsOriginOffset = !elementTransformMatrix.isIdentity && (oX !== 0 || oY !== 0 || oZ !== 0);\n        const tX = isEndPhase ? x : containerOffset.x + (x - startOffset.x);\n        const tY = isEndPhase ? y : containerOffset.y + (y - startOffset.y);\n        // Reset the matrix to identity.\n        (0, $dac91faf2d28787e$export$5e2c7a53f84076f2)($e9cd0e353e15b4ae$var$DOM_MATRIX);\n        // First of all negate the element's transform origin.\n        if (needsOriginOffset) {\n            if (oZ === 0) $e9cd0e353e15b4ae$var$DOM_MATRIX.translateSelf(oX * -1, oY * -1);\n            else $e9cd0e353e15b4ae$var$DOM_MATRIX.translateSelf(oX * -1, oY * -1, oZ * -1);\n        }\n        // Invert the current container's matrix, so we can apply the\n        // translation in world space coordinates. If this is the end phase the\n        // element will have been appended back to the original container if\n        // there was a drag container defined. Otherwise the element will be\n        // appended to the drag container (if defined).\n        if (isEndPhase) {\n            if (!inverseContainerMatrix.isIdentity) $e9cd0e353e15b4ae$var$DOM_MATRIX.multiplySelf(inverseContainerMatrix);\n        } else if (!inverseDragContainerMatrix.isIdentity) $e9cd0e353e15b4ae$var$DOM_MATRIX.multiplySelf(inverseDragContainerMatrix);\n        // Apply the translation (in world space coordinates).\n        (0, $dac91faf2d28787e$export$5e2c7a53f84076f2)($e9cd0e353e15b4ae$var$TEMP_MATRIX).translateSelf(tX, tY);\n        $e9cd0e353e15b4ae$var$DOM_MATRIX.multiplySelf($e9cd0e353e15b4ae$var$TEMP_MATRIX);\n        // Apply the element's original container's world matrix so we can apply\n        // the element's original transform as if it was in the original\n        // container's local space coordinates.\n        if (!containerMatrix.isIdentity) $e9cd0e353e15b4ae$var$DOM_MATRIX.multiplySelf(containerMatrix);\n        // Undo the transform origin negation.\n        if (needsOriginOffset) {\n            (0, $dac91faf2d28787e$export$5e2c7a53f84076f2)($e9cd0e353e15b4ae$var$TEMP_MATRIX).translateSelf(oX, oY, oZ);\n            $e9cd0e353e15b4ae$var$DOM_MATRIX.multiplySelf($e9cd0e353e15b4ae$var$TEMP_MATRIX);\n        }\n        // Apply the element's original transform.\n        if (!elementTransformMatrix.isIdentity) $e9cd0e353e15b4ae$var$DOM_MATRIX.multiplySelf(elementTransformMatrix);\n        // Apply the matrix to the element.\n        item.element.style.transform = `${$e9cd0e353e15b4ae$var$DOM_MATRIX}`;\n    },\n    getPositionChange: ({ event: event, prevEvent: prevEvent })=>{\n        $e9cd0e353e15b4ae$var$POSITION_CHANGE.x = event.x - prevEvent.x;\n        $e9cd0e353e15b4ae$var$POSITION_CHANGE.y = event.y - prevEvent.y;\n        return $e9cd0e353e15b4ae$var$POSITION_CHANGE;\n    }\n};\nclass $e9cd0e353e15b4ae$export$f2a139e5d18b9882 {\n    constructor(sensors, options = {}){\n        this.sensors = sensors;\n        this.settings = this._parseSettings(options);\n        this.plugins = {};\n        this.drag = null;\n        this.isDestroyed = false;\n        this._sensorData = new Map();\n        this._emitter = new (0, $3d96966d628715ed$export$4293555f241ae35a)();\n        this._startPhase = 0;\n        this._startId = Symbol();\n        this._moveId = Symbol();\n        this._alignId = Symbol();\n        // Bind methods (that need binding).\n        this._onMove = this._onMove.bind(this);\n        this._onScroll = this._onScroll.bind(this);\n        this._onEnd = this._onEnd.bind(this);\n        this._prepareStart = this._prepareStart.bind(this);\n        this._applyStart = this._applyStart.bind(this);\n        this._prepareMove = this._prepareMove.bind(this);\n        this._applyMove = this._applyMove.bind(this);\n        this._prepareAlign = this._prepareAlign.bind(this);\n        this._applyAlign = this._applyAlign.bind(this);\n        // Bind drag sensor events.\n        this.sensors.forEach((sensor)=>{\n            this._sensorData.set(sensor, {\n                predicateState: 0,\n                predicateEvent: null,\n                onMove: (e)=>this._onMove(e, sensor),\n                onEnd: (e)=>this._onEnd(e, sensor)\n            });\n            const { onMove: onMove, onEnd: onEnd } = this._sensorData.get(sensor);\n            sensor.on(\"start\", onMove, onMove);\n            sensor.on(\"move\", onMove, onMove);\n            sensor.on(\"cancel\", onEnd, onEnd);\n            sensor.on(\"end\", onEnd, onEnd);\n            sensor.on(\"destroy\", onEnd, onEnd);\n        });\n    }\n    _parseSettings(options, defaults = $e9cd0e353e15b4ae$export$7ce0cd3869d5dcd9) {\n        const { container: container = defaults.container, startPredicate: startPredicate = defaults.startPredicate, getElements: getElements = defaults.getElements, releaseElements: releaseElements = defaults.releaseElements, getFrozenProps: getFrozenProps = defaults.getFrozenProps, getStartPosition: getStartPosition = defaults.getStartPosition, setPosition: setPosition = defaults.setPosition, getPositionChange: getPositionChange = defaults.getPositionChange } = options || {};\n        return {\n            container: container,\n            startPredicate: startPredicate,\n            getElements: getElements,\n            releaseElements: releaseElements,\n            getFrozenProps: getFrozenProps,\n            getStartPosition: getStartPosition,\n            setPosition: setPosition,\n            getPositionChange: getPositionChange\n        };\n    }\n    _emit(type, ...e) {\n        this._emitter.emit(type, ...e);\n    }\n    _onMove(e, sensor) {\n        const sensorData = this._sensorData.get(sensor);\n        if (!sensorData) return;\n        switch(sensorData.predicateState){\n            case 0:\n                {\n                    sensorData.predicateEvent = e;\n                    // Check if drag should start.\n                    const shouldStart = this.settings.startPredicate({\n                        draggable: this,\n                        sensor: sensor,\n                        event: e\n                    });\n                    // Resolve procedure (start move process).\n                    if (shouldStart === true) this.resolveStartPredicate(sensor);\n                    else if (shouldStart === false) this.rejectStartPredicate(sensor);\n                    break;\n                }\n            case 1:\n                // Move the element if dragging is active.\n                if (this.drag) {\n                    this.drag.event = e;\n                    (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).once((0, $c1fd6b62e08b3d47$export$ef9171fc2626).read, this._prepareMove, this._moveId);\n                    (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).once((0, $c1fd6b62e08b3d47$export$ef9171fc2626).write, this._applyMove, this._moveId);\n                }\n                break;\n        }\n    }\n    _onScroll() {\n        this.align();\n    }\n    _onEnd(e, sensor) {\n        const sensorData = this._sensorData.get(sensor);\n        if (!sensorData) return;\n        // If there is no active drag yet, let's reset the sensor's start predicate\n        // so that it can try starting drag again.\n        if (!this.drag) {\n            sensorData.predicateState = 0;\n            sensorData.predicateEvent = null;\n        } else if (sensorData.predicateState === 1) {\n            this.drag.endEvent = e;\n            this._sensorData.forEach((data)=>{\n                data.predicateState = 0;\n                data.predicateEvent = null;\n            });\n            this.stop();\n        }\n    }\n    _prepareStart() {\n        const drag = this.drag;\n        if (!drag) return;\n        // Update start phase.\n        this._startPhase = 2;\n        // Get elements that we'll need to move with the drag.\n        // NB: It is okay if there are no elements and thus no items. The drag\n        // process will process as usual, but nothing is moving by default.\n        const elements = this.settings.getElements({\n            draggable: this,\n            sensor: drag.sensor,\n            startEvent: drag.startEvent\n        }) || [];\n        // Create drag items.\n        drag.items = elements.map((element)=>{\n            return new (0, $6985a94cfe75e842$export$b87fb2dc7f11ca52)(element, this);\n        });\n        // Emit preparestart event.\n        this._emit(\"preparestart\", drag.startEvent);\n    }\n    _applyStart() {\n        const drag = this.drag;\n        if (!drag) return;\n        for (const item of drag.items){\n            // Append element within the container element if such is provided.\n            if (item.dragContainer !== item.elementContainer) (0, $71d766ad3004a578$export$33e13bbfe889ab45)(item.element, item.dragContainer);\n            // Freeze element's props if such are provided.\n            if (item.frozenProps) Object.assign(item.element.style, item.frozenProps);\n            // Set element's start position.\n            this.settings.setPosition({\n                phase: \"start\",\n                draggable: this,\n                sensor: drag.sensor,\n                item: item,\n                x: item.position.x,\n                y: item.position.y\n            });\n        }\n        // Compute the start offset (if needed).\n        for (const item of drag.items){\n            const containerMatrix = item.getContainerMatrix()[0];\n            const dragContainerMatrix = item.getDragContainerMatrix()[0];\n            // If both container matrices are equal, we can skip the computation.\n            if ((0, $f0aa8b1322987ed0$export$da3f9f1be978dbbc)(containerMatrix, dragContainerMatrix)) continue;\n            // TODO: We can probably also skip computation if both matrices contain\n            // only translations.\n            const rect = item.element.getBoundingClientRect();\n            const { startOffset: startOffset } = item;\n            // Round the align diff to nearest 3rd decimal to avoid applying it if the\n            // value is so small that it's not visible.\n            startOffset.x = (0, $73b931158359019b$export$a3992db8dd0fd9e6)(rect.x - item.clientRect.x, 3);\n            startOffset.y = (0, $73b931158359019b$export$a3992db8dd0fd9e6)(rect.y - item.clientRect.y, 3);\n        }\n        // Apply start offset (if needed).\n        for (const item of drag.items){\n            const { startOffset: startOffset } = item;\n            if (startOffset.x !== 0 || startOffset.y !== 0) this.settings.setPosition({\n                phase: \"start-align\",\n                draggable: this,\n                sensor: drag.sensor,\n                item: item,\n                x: item.position.x,\n                y: item.position.y\n            });\n        }\n        // Bind scroll listeners.\n        window.addEventListener(\"scroll\", this._onScroll, $e9cd0e353e15b4ae$var$SCROLL_LISTENER_OPTIONS);\n        // Update start phase.\n        this._startPhase = 3;\n        // Emit start event.\n        this._emit(\"start\", drag.startEvent);\n    }\n    _prepareMove() {\n        const drag = this.drag;\n        if (!drag) return;\n        // Get next event and previous event so we can compute the movement\n        // difference between the clientX/Y values.\n        const { event: event, prevEvent: prevEvent, startEvent: startEvent, sensor: sensor } = drag;\n        if (event === prevEvent) return;\n        for (const item of drag.items){\n            // Compute how much x and y needs to be transformed.\n            const { x: changeX, y: changeY } = this.settings.getPositionChange({\n                draggable: this,\n                sensor: sensor,\n                item: item,\n                event: event,\n                prevEvent: prevEvent,\n                startEvent: startEvent\n            });\n            // Update horizontal position data.\n            if (changeX) {\n                item.position.x += changeX;\n                item.clientRect.x += changeX;\n                item[\"_moveDiff\"].x += changeX;\n            }\n            // Update vertical position data.\n            if (changeY) {\n                item.position.y += changeY;\n                item.clientRect.y += changeY;\n                item[\"_moveDiff\"].y += changeY;\n            }\n        }\n        // Store next event as previous event.\n        drag.prevEvent = event;\n        // Emit preparemove event.\n        this._emit(\"preparemove\", event);\n    }\n    _applyMove() {\n        const drag = this.drag;\n        if (!drag) return;\n        // Reset movement diff and move the element.\n        for (const item of drag.items){\n            item[\"_moveDiff\"].x = 0;\n            item[\"_moveDiff\"].y = 0;\n            this.settings.setPosition({\n                phase: \"move\",\n                draggable: this,\n                sensor: drag.sensor,\n                item: item,\n                x: item.position.x,\n                y: item.position.y\n            });\n        }\n        // Emit move event.\n        if (drag.event) this._emit(\"move\", drag.event);\n    }\n    _prepareAlign() {\n        const { drag: drag } = this;\n        if (!drag) return;\n        for (const item of drag.items){\n            const { x: x, y: y } = item.element.getBoundingClientRect();\n            // Note that we INTENTIONALLY DO NOT UPDATE THE CLIENT RECT COORDINATES\n            // here. The point of this method is to update the POSITION of the\n            // draggable item based on how much the client rect has drifted so that\n            // the element is visually repostioned to the correct place.\n            // Update horizontal position data.\n            const alignDiffX = item.clientRect.x - item[\"_moveDiff\"].x - x;\n            item.position.x = item.position.x - item[\"_alignDiff\"].x + alignDiffX;\n            item[\"_alignDiff\"].x = alignDiffX;\n            // Update vertical position data.\n            const alignDiffY = item.clientRect.y - item[\"_moveDiff\"].y - y;\n            item.position.y = item.position.y - item[\"_alignDiff\"].y + alignDiffY;\n            item[\"_alignDiff\"].y = alignDiffY;\n        }\n    }\n    _applyAlign() {\n        const { drag: drag } = this;\n        if (!drag) return;\n        for (const item of drag.items){\n            item[\"_alignDiff\"].x = 0;\n            item[\"_alignDiff\"].y = 0;\n            this.settings.setPosition({\n                phase: \"align\",\n                draggable: this,\n                sensor: drag.sensor,\n                item: item,\n                x: item.position.x,\n                y: item.position.y\n            });\n        }\n    }\n    on(type, listener, listenerId) {\n        return this._emitter.on(type, listener, listenerId);\n    }\n    off(type, listenerId) {\n        this._emitter.off(type, listenerId);\n    }\n    resolveStartPredicate(sensor, e) {\n        const sensorData = this._sensorData.get(sensor);\n        if (!sensorData) return;\n        const startEvent = e || sensorData.predicateEvent;\n        if (sensorData.predicateState === 0 && startEvent) {\n            //  Update start phase.\n            this._startPhase = 1;\n            // Resolve the provided sensor's start predicate.\n            sensorData.predicateState = 1;\n            sensorData.predicateEvent = null;\n            this.drag = new (0, $128271867868f1db$export$12e4b40eac1bcb71)(sensor, startEvent);\n            // Reject other sensors' start predicates.\n            this._sensorData.forEach((data, s)=>{\n                if (s === sensor) return;\n                data.predicateState = 2;\n                data.predicateEvent = null;\n            });\n            // Queue drag start.\n            (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).once((0, $c1fd6b62e08b3d47$export$ef9171fc2626).read, this._prepareStart, this._startId);\n            (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).once((0, $c1fd6b62e08b3d47$export$ef9171fc2626).write, this._applyStart, this._startId);\n        }\n    }\n    rejectStartPredicate(sensor) {\n        const sensorData = this._sensorData.get(sensor);\n        if (sensorData?.predicateState === 0) {\n            sensorData.predicateState = 2;\n            sensorData.predicateEvent = null;\n        }\n    }\n    stop() {\n        const drag = this.drag;\n        if (!drag || drag.isEnded) return;\n        // If drag start process is still in the prepare and apply phase, let's\n        // wait for it to finish before stopping the drag process. This is a very\n        // rare edge case, but it can happen if the drag process is stopped\n        // forcefully during the start phase.\n        // NB: We reuse the `_startId` symbol to queue the stop procedure.\n        if (this._startPhase === 2) {\n            this.off(\"start\", this._startId);\n            this.on(\"start\", ()=>this.stop(), this._startId);\n            return;\n        }\n        // Reset drag start phase.\n        this._startPhase = 0;\n        // Mark drag process as ended.\n        drag.isEnded = true;\n        // Cancel all queued ticks.\n        (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).off((0, $c1fd6b62e08b3d47$export$ef9171fc2626).read, this._startId);\n        (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).off((0, $c1fd6b62e08b3d47$export$ef9171fc2626).write, this._startId);\n        (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).off((0, $c1fd6b62e08b3d47$export$ef9171fc2626).read, this._moveId);\n        (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).off((0, $c1fd6b62e08b3d47$export$ef9171fc2626).write, this._moveId);\n        (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).off((0, $c1fd6b62e08b3d47$export$ef9171fc2626).read, this._alignId);\n        (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).off((0, $c1fd6b62e08b3d47$export$ef9171fc2626).write, this._alignId);\n        // Unbind scroll listener.\n        window.removeEventListener(\"scroll\", this._onScroll, $e9cd0e353e15b4ae$var$SCROLL_LISTENER_OPTIONS);\n        // Adjust items' positions for the drop. When the drag starts the container\n        // offset is computed once, but not updated during drag (because we don't\n        // need to). But on drop we need to how much the offset diff has changed\n        // from the start and then add the diff to the item's position, and finally\n        // reset the container offset. Let's do this procedure in a separate loop to\n        // avoid layout thrashing.\n        drag[\"_clientOffsetCache\"].clear();\n        for (const item of drag.items)if (item.elementContainer !== item.dragContainer) {\n            const { x: startX, y: startY } = item.containerOffset;\n            item.updateContainerOffset();\n            const { x: endX, y: endY } = item.containerOffset;\n            item.position.x += (endX - startX) * -1;\n            item.position.y += (endY - startY) * -1;\n            item.containerOffset.x = 0;\n            item.containerOffset.y = 0;\n        }\n        // Move elements within the root container and collect all elements\n        // to an elements array.\n        const elements = [];\n        for (const item of drag.items){\n            elements.push(item.element);\n            if (item.elementContainer !== item.dragContainer) (0, $71d766ad3004a578$export$33e13bbfe889ab45)(item.element, item.elementContainer);\n            // Unfreeze element's props if such are provided.\n            if (item.unfrozenProps) for(const key in item.unfrozenProps)item.element.style[key] = item.unfrozenProps[key] || \"\";\n            // Set final position after drag.\n            this.settings.setPosition({\n                phase: \"end\",\n                draggable: this,\n                sensor: drag.sensor,\n                item: item,\n                x: item.position.x,\n                y: item.position.y\n            });\n        }\n        // Call \"releaseElements\" callback.\n        if (elements.length) this.settings.releaseElements({\n            draggable: this,\n            sensor: drag.sensor,\n            elements: elements\n        });\n        // Remove measure elements.\n        drag[\"_measureElements\"].forEach((el)=>el.remove());\n        // Emit end event.\n        this._emit(\"end\", drag.endEvent);\n        // Reset drag data.\n        this.drag = null;\n    }\n    align(instant = false) {\n        if (!this.drag) return;\n        if (instant) {\n            this._prepareAlign();\n            this._applyAlign();\n        } else {\n            (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).once((0, $c1fd6b62e08b3d47$export$ef9171fc2626).read, this._prepareAlign, this._alignId);\n            (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).once((0, $c1fd6b62e08b3d47$export$ef9171fc2626).write, this._applyAlign, this._alignId);\n        }\n    }\n    updateSettings(options = {}) {\n        this.settings = this._parseSettings(options, this.settings);\n    }\n    use(plugin) {\n        return plugin(this);\n    }\n    destroy() {\n        if (this.isDestroyed) return;\n        this.isDestroyed = true;\n        this.stop();\n        this._sensorData.forEach(({ onMove: onMove, onEnd: onEnd }, sensor)=>{\n            sensor.off(\"start\", onMove);\n            sensor.off(\"move\", onMove);\n            sensor.off(\"cancel\", onEnd);\n            sensor.off(\"end\", onEnd);\n            sensor.off(\"destroy\", onEnd);\n        });\n        this._sensorData.clear();\n        this._emit(\"destroy\");\n        this._emitter.off();\n    }\n}\n\n\nclass $f045deb6d07519b3$export$14963ee5c8637e11 {\n    constructor(createObject, onPut){\n        this._data = [];\n        this._createObject = createObject;\n        this._onPut = onPut;\n    }\n    pick() {\n        return this._data.length ? this._data.pop() : this._createObject();\n    }\n    put(object) {\n        if (this._data.indexOf(object) === -1) {\n            this._onPut && this._onPut(object);\n            this._data.push(object);\n        }\n    }\n    reset() {\n        this._data.length = 0;\n    }\n}\n\n\n\n\nfunction $1190f1d8a15545c9$export$3a8bd5429d724075(sourceRect, result = {\n    width: 0,\n    height: 0,\n    x: 0,\n    y: 0,\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0\n}) {\n    if (sourceRect) {\n        result.width = sourceRect.width;\n        result.height = sourceRect.height;\n        result.x = sourceRect.x;\n        result.y = sourceRect.y;\n        result.left = sourceRect.x;\n        result.top = sourceRect.y;\n        result.right = sourceRect.x + sourceRect.width;\n        result.bottom = sourceRect.y + sourceRect.height;\n    }\n    return result;\n}\n\n\nconst $b2dcf2463b3f9899$var$RECT_A = (0, $1190f1d8a15545c9$export$3a8bd5429d724075)();\nconst $b2dcf2463b3f9899$var$RECT_B = (0, $1190f1d8a15545c9$export$3a8bd5429d724075)();\nfunction $b2dcf2463b3f9899$export$79376507b09a66f(a, b) {\n    return (0, $2a599c00d4ed99d6$export$79376507b09a66f)((0, $1190f1d8a15545c9$export$3a8bd5429d724075)(a, $b2dcf2463b3f9899$var$RECT_A), (0, $1190f1d8a15545c9$export$3a8bd5429d724075)(b, $b2dcf2463b3f9899$var$RECT_B));\n}\n\n\nfunction $958cff288d13c403$export$72209efa88586d42(a, b, result = {\n    width: 0,\n    height: 0,\n    x: 0,\n    y: 0\n}) {\n    const x1 = Math.max(a.x, b.x);\n    const x2 = Math.min(a.x + a.width, b.x + b.width);\n    if (x2 <= x1) return null;\n    const y1 = Math.max(a.y, b.y);\n    const y2 = Math.min(a.y + a.height, b.y + b.height);\n    if (y2 <= y1) return null;\n    result.x = x1;\n    result.y = y1;\n    result.width = x2 - x1;\n    result.height = y2 - y1;\n    return result;\n}\n\n\nfunction $7d9b910efbacee79$export$f3fe0e9a60cde324(a, b) {\n    const intersection = (0, $958cff288d13c403$export$72209efa88586d42)(a, b);\n    return intersection ? intersection.width * intersection.height : 0;\n}\n\n\nfunction $6551604847fd2088$export$25b3e1e24e1ba229(a, b) {\n    const area = (0, $7d9b910efbacee79$export$f3fe0e9a60cde324)(a, b);\n    if (!area) return 0;\n    const maxArea = Math.min(a.width, b.width) * Math.min(a.height, b.height);\n    return area / maxArea * 100;\n}\n\n\n\nfunction $a91d17aaf97bddf1$export$4b834cebd9e5cebe(...args) {\n    const { width: width, height: height, left: x, top: y } = (0, $4fec7741c67a29fc$export$4b834cebd9e5cebe)(...args);\n    return {\n        width: width,\n        height: height,\n        x: x,\n        y: y\n    };\n}\n\n\n/**\n * Check if the current value is a window.\n */ function $f293b2d920f66b53$export$5a096129d439f843(value) {\n    return value instanceof Window;\n}\n\n\nfunction $1d5c880696869e94$export$31d37ff78a483ce2(element) {\n    if ((0, $f293b2d920f66b53$export$5a096129d439f843)(element) || element === document.documentElement || element === document.body) return window;\n    else return element;\n}\n\n\n\nfunction $8e79f2bef02bf7a3$export$1389d168952b34b5(element) {\n    return (0, $f293b2d920f66b53$export$5a096129d439f843)(element) ? element.scrollX : element.scrollLeft;\n}\n\n\n\nfunction $6a48622145310dd6$export$c16047c7a398106d(element) {\n    if ((0, $f293b2d920f66b53$export$5a096129d439f843)(element)) element = document.documentElement;\n    return element.scrollWidth - element.clientWidth;\n}\n\n\n\nfunction $b796ea00009cfb0f$export$c4a223a8ba9e4ea5(element) {\n    return (0, $f293b2d920f66b53$export$5a096129d439f843)(element) ? element.scrollY : element.scrollTop;\n}\n\n\n\nfunction $6ba3127b64f1801b$export$39d53b245a98193e(element) {\n    if ((0, $f293b2d920f66b53$export$5a096129d439f843)(element)) element = document.documentElement;\n    return element.scrollHeight - element.clientHeight;\n}\n\n\nfunction $dce4f2a3d0d356ef$export$8d3dd0be5eb9f11f(a, b) {\n    return !(a.x + a.width <= b.x || b.x + b.width <= a.x || a.y + a.height <= b.y || b.y + b.height <= a.y);\n}\n\n\n//\n// CONSTANTS\n//\nconst $292e4d9baf691c8b$var$TEMP_RECT = {\n    width: 0,\n    height: 0,\n    x: 0,\n    y: 0\n};\nconst $292e4d9baf691c8b$var$DEFAULT_THRESHOLD = 50;\nconst $292e4d9baf691c8b$var$SPEED_DATA = {\n    direction: \"none\",\n    threshold: 0,\n    distance: 0,\n    value: 0,\n    maxValue: 0,\n    duration: 0,\n    speed: 0,\n    deltaTime: 0,\n    isEnding: false\n};\nconst $292e4d9baf691c8b$export$5bbd74ab6c855dff = {\n    x: 1,\n    y: 2\n};\nconst $292e4d9baf691c8b$export$3eeb7a7b68c92567 = {\n    forward: 4,\n    reverse: 8\n};\nconst $292e4d9baf691c8b$var$AUTO_SCROLL_DIRECTION_X = {\n    none: 0,\n    left: $292e4d9baf691c8b$export$5bbd74ab6c855dff.x | $292e4d9baf691c8b$export$3eeb7a7b68c92567.reverse,\n    right: $292e4d9baf691c8b$export$5bbd74ab6c855dff.x | $292e4d9baf691c8b$export$3eeb7a7b68c92567.forward\n};\nconst $292e4d9baf691c8b$var$AUTO_SCROLL_DIRECTION_Y = {\n    none: 0,\n    up: $292e4d9baf691c8b$export$5bbd74ab6c855dff.y | $292e4d9baf691c8b$export$3eeb7a7b68c92567.reverse,\n    down: $292e4d9baf691c8b$export$5bbd74ab6c855dff.y | $292e4d9baf691c8b$export$3eeb7a7b68c92567.forward\n};\nconst $292e4d9baf691c8b$export$c9fbd1f9176bc8ed = {\n    ...$292e4d9baf691c8b$var$AUTO_SCROLL_DIRECTION_X,\n    ...$292e4d9baf691c8b$var$AUTO_SCROLL_DIRECTION_Y\n};\nfunction $292e4d9baf691c8b$var$getDirectionAsString(direction) {\n    switch(direction){\n        case $292e4d9baf691c8b$var$AUTO_SCROLL_DIRECTION_X.none:\n        case $292e4d9baf691c8b$var$AUTO_SCROLL_DIRECTION_Y.none:\n            return \"none\";\n        case $292e4d9baf691c8b$var$AUTO_SCROLL_DIRECTION_X.left:\n            return \"left\";\n        case $292e4d9baf691c8b$var$AUTO_SCROLL_DIRECTION_X.right:\n            return \"right\";\n        case $292e4d9baf691c8b$var$AUTO_SCROLL_DIRECTION_Y.up:\n            return \"up\";\n        case $292e4d9baf691c8b$var$AUTO_SCROLL_DIRECTION_Y.down:\n            return \"down\";\n        default:\n            throw new Error(`Unknown direction value: ${direction}`);\n    }\n}\nfunction $292e4d9baf691c8b$var$getPaddedRect(rect, padding, result) {\n    let { left: left = 0, right: right = 0, top: top = 0, bottom: bottom = 0 } = padding;\n    // Don't allow negative padding.\n    left = Math.max(0, left);\n    right = Math.max(0, right);\n    top = Math.max(0, top);\n    bottom = Math.max(0, bottom);\n    result.width = rect.width + left + right;\n    result.height = rect.height + top + bottom;\n    result.x = rect.x - left;\n    result.y = rect.y - top;\n    return result;\n}\nfunction $292e4d9baf691c8b$var$isScrolledToMax(scrollValue, maxScrollValue) {\n    // In some scenarios the scrollValue and/or maxScrollValue can be a float\n    // with subpixel values which might cause some funky scenarios where the\n    // element tries to scroll to the end but never actually reaches it. In such\n    // cases we want to do some rounding to detect that the element has actually\n    // reached the end of the scroll.\n    return Math.ceil(scrollValue) >= Math.floor(maxScrollValue);\n}\n//\n// PRIVATE UTILS\n//\nfunction $292e4d9baf691c8b$var$computeThreshold(idealThreshold, targetSize) {\n    return Math.min(targetSize / 2, idealThreshold);\n}\nfunction $292e4d9baf691c8b$var$computeEdgeOffset(threshold, inertAreaSize, itemSize, targetSize) {\n    return Math.max(0, itemSize + threshold * 2 + targetSize * inertAreaSize - targetSize) / 2;\n}\nclass $292e4d9baf691c8b$var$AutoScrollItemData {\n    constructor(){\n        this.positionX = 0;\n        this.positionY = 0;\n        this.directionX = $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.none;\n        this.directionY = $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.none;\n        this.overlapCheckRequestTime = 0;\n    }\n}\nclass $292e4d9baf691c8b$var$AutoScrollAction {\n    constructor(){\n        this.element = null;\n        this.requestX = null;\n        this.requestY = null;\n        this.scrollLeft = 0;\n        this.scrollTop = 0;\n    }\n    reset() {\n        if (this.requestX) this.requestX.action = null;\n        if (this.requestY) this.requestY.action = null;\n        this.element = null;\n        this.requestX = null;\n        this.requestY = null;\n        this.scrollLeft = 0;\n        this.scrollTop = 0;\n    }\n    addRequest(request) {\n        if ($292e4d9baf691c8b$export$5bbd74ab6c855dff.x & request.direction) {\n            this.requestX && this.removeRequest(this.requestX);\n            this.requestX = request;\n        } else {\n            this.requestY && this.removeRequest(this.requestY);\n            this.requestY = request;\n        }\n        request.action = this;\n    }\n    removeRequest(request) {\n        if (this.requestX === request) {\n            this.requestX = null;\n            request.action = null;\n        } else if (this.requestY === request) {\n            this.requestY = null;\n            request.action = null;\n        }\n    }\n    computeScrollValues() {\n        if (!this.element) return;\n        this.scrollLeft = this.requestX ? this.requestX.value : (0, $8e79f2bef02bf7a3$export$1389d168952b34b5)(this.element);\n        this.scrollTop = this.requestY ? this.requestY.value : (0, $b796ea00009cfb0f$export$c4a223a8ba9e4ea5)(this.element);\n    }\n    scroll() {\n        if (!this.element) return;\n        if (this.element.scrollTo) this.element.scrollTo(this.scrollLeft, this.scrollTop);\n        else {\n            this.element.scrollLeft = this.scrollLeft;\n            this.element.scrollTop = this.scrollTop;\n        }\n    }\n}\nclass $292e4d9baf691c8b$var$AutoScrollRequest {\n    constructor(){\n        this.item = null;\n        this.element = null;\n        this.isActive = false;\n        this.isEnding = false;\n        this.direction = 0;\n        this.value = NaN;\n        this.maxValue = 0;\n        this.threshold = 0;\n        this.distance = 0;\n        this.deltaTime = 0;\n        this.speed = 0;\n        this.duration = 0;\n        this.action = null;\n    }\n    reset() {\n        if (this.isActive) this.onStop();\n        this.item = null;\n        this.element = null;\n        this.isActive = false;\n        this.isEnding = false;\n        this.direction = 0;\n        this.value = NaN;\n        this.maxValue = 0;\n        this.threshold = 0;\n        this.distance = 0;\n        this.deltaTime = 0;\n        this.speed = 0;\n        this.duration = 0;\n        this.action = null;\n    }\n    hasReachedEnd() {\n        return $292e4d9baf691c8b$export$3eeb7a7b68c92567.forward & this.direction ? $292e4d9baf691c8b$var$isScrolledToMax(this.value, this.maxValue) : this.value <= 0;\n    }\n    computeCurrentScrollValue() {\n        if (!this.element) return 0;\n        if (this.value !== this.value) return $292e4d9baf691c8b$export$5bbd74ab6c855dff.x & this.direction ? (0, $8e79f2bef02bf7a3$export$1389d168952b34b5)(this.element) : (0, $b796ea00009cfb0f$export$c4a223a8ba9e4ea5)(this.element);\n        return Math.max(0, Math.min(this.value, this.maxValue));\n    }\n    computeNextScrollValue() {\n        const delta = this.speed * (this.deltaTime / 1000);\n        const nextValue = $292e4d9baf691c8b$export$3eeb7a7b68c92567.forward & this.direction ? this.value + delta : this.value - delta;\n        return Math.max(0, Math.min(nextValue, this.maxValue));\n    }\n    computeSpeed() {\n        if (!this.item || !this.element) return 0;\n        const { speed: speed } = this.item;\n        if (typeof speed === \"function\") {\n            $292e4d9baf691c8b$var$SPEED_DATA.direction = $292e4d9baf691c8b$var$getDirectionAsString(this.direction);\n            $292e4d9baf691c8b$var$SPEED_DATA.threshold = this.threshold;\n            $292e4d9baf691c8b$var$SPEED_DATA.distance = this.distance;\n            $292e4d9baf691c8b$var$SPEED_DATA.value = this.value;\n            $292e4d9baf691c8b$var$SPEED_DATA.maxValue = this.maxValue;\n            $292e4d9baf691c8b$var$SPEED_DATA.duration = this.duration;\n            $292e4d9baf691c8b$var$SPEED_DATA.speed = this.speed;\n            $292e4d9baf691c8b$var$SPEED_DATA.deltaTime = this.deltaTime;\n            $292e4d9baf691c8b$var$SPEED_DATA.isEnding = this.isEnding;\n            return speed(this.element, $292e4d9baf691c8b$var$SPEED_DATA);\n        } else return speed;\n    }\n    tick(deltaTime) {\n        if (!this.isActive) {\n            this.isActive = true;\n            this.onStart();\n        }\n        this.deltaTime = deltaTime;\n        this.value = this.computeCurrentScrollValue();\n        this.speed = this.computeSpeed();\n        this.value = this.computeNextScrollValue();\n        this.duration += deltaTime;\n        return this.value;\n    }\n    onStart() {\n        if (!this.item || !this.element) return;\n        const { onStart: onStart } = this.item;\n        if (typeof onStart === \"function\") onStart(this.element, $292e4d9baf691c8b$var$getDirectionAsString(this.direction));\n    }\n    onStop() {\n        if (!this.item || !this.element) return;\n        const { onStop: onStop } = this.item;\n        if (typeof onStop === \"function\") onStop(this.element, $292e4d9baf691c8b$var$getDirectionAsString(this.direction));\n    }\n}\nfunction $292e4d9baf691c8b$export$55a384729d91296b(// Pixels per second.\nmaxSpeed = 500, // Time in seconds, how long it will take to accelerate from 0 to maxSpeed.\naccelerationFactor = 0.5, // Time in seconds, how long it will take to decelerate maxSpeed to 0.\ndecelerationFactor = 0.25) {\n    const acceleration = maxSpeed * (accelerationFactor > 0 ? 1 / accelerationFactor : Infinity);\n    const deceleration = maxSpeed * (decelerationFactor > 0 ? 1 / decelerationFactor : Infinity);\n    return function(_element, data) {\n        let targetSpeed = 0;\n        if (!data.isEnding) {\n            if (data.threshold > 0) {\n                const factor = data.threshold - Math.max(0, data.distance);\n                targetSpeed = maxSpeed / data.threshold * factor;\n            } else targetSpeed = maxSpeed;\n        }\n        const currentSpeed = data.speed;\n        if (currentSpeed === targetSpeed) return targetSpeed;\n        let nextSpeed = targetSpeed;\n        if (currentSpeed < targetSpeed) {\n            nextSpeed = currentSpeed + acceleration * (data.deltaTime / 1000);\n            return Math.min(targetSpeed, nextSpeed);\n        } else {\n            nextSpeed = currentSpeed - deceleration * (data.deltaTime / 1000);\n            return Math.max(targetSpeed, nextSpeed);\n        }\n    };\n}\nclass $292e4d9baf691c8b$export$3fb39aee5567f02e {\n    constructor(options = {}){\n        const { overlapCheckInterval: overlapCheckInterval = 150 } = options;\n        this.items = [];\n        this.settings = {\n            overlapCheckInterval: overlapCheckInterval\n        };\n        this._actions = [];\n        this._isDestroyed = false;\n        this._isTicking = false;\n        this._tickTime = 0;\n        this._tickDeltaTime = 0;\n        this._requests = {\n            [$292e4d9baf691c8b$export$5bbd74ab6c855dff.x]: new Map(),\n            [$292e4d9baf691c8b$export$5bbd74ab6c855dff.y]: new Map()\n        };\n        this._itemData = new Map();\n        this._requestPool = new (0, $f045deb6d07519b3$export$14963ee5c8637e11)(()=>new $292e4d9baf691c8b$var$AutoScrollRequest(), (request)=>request.reset());\n        this._actionPool = new (0, $f045deb6d07519b3$export$14963ee5c8637e11)(()=>new $292e4d9baf691c8b$var$AutoScrollAction(), (action)=>action.reset());\n        this._frameRead = this._frameRead.bind(this);\n        this._frameWrite = this._frameWrite.bind(this);\n    }\n    _frameRead(time) {\n        if (this._isDestroyed) return;\n        if (time && this._tickTime) {\n            this._tickDeltaTime = time - this._tickTime;\n            this._tickTime = time;\n            this._updateItems();\n            this._updateRequests();\n            this._updateActions();\n        } else {\n            this._tickTime = time;\n            this._tickDeltaTime = 0;\n        }\n    }\n    _frameWrite() {\n        if (this._isDestroyed) return;\n        this._applyActions();\n    }\n    _startTicking() {\n        if (this._isTicking) return;\n        this._isTicking = true;\n        (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).on((0, $c1fd6b62e08b3d47$export$ef9171fc2626).read, this._frameRead, this._frameRead);\n        (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).on((0, $c1fd6b62e08b3d47$export$ef9171fc2626).write, this._frameWrite, this._frameWrite);\n    }\n    _stopTicking() {\n        if (!this._isTicking) return;\n        this._isTicking = false;\n        this._tickTime = 0;\n        this._tickDeltaTime = 0;\n        (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).off((0, $c1fd6b62e08b3d47$export$ef9171fc2626).read, this._frameRead);\n        (0, $c1fd6b62e08b3d47$export$e94d57566be028aa).off((0, $c1fd6b62e08b3d47$export$ef9171fc2626).write, this._frameWrite);\n    }\n    _requestItemScroll(item, axis, element, direction, threshold, distance, maxValue) {\n        const reqMap = this._requests[axis];\n        let request = reqMap.get(item);\n        if (request) {\n            if (request.element !== element || request.direction !== direction) request.reset();\n        } else {\n            request = this._requestPool.pick();\n            reqMap.set(item, request);\n        }\n        request.item = item;\n        request.element = element;\n        request.direction = direction;\n        request.threshold = threshold;\n        request.distance = distance;\n        request.maxValue = maxValue;\n    }\n    _cancelItemScroll(item, axis) {\n        const reqMap = this._requests[axis];\n        const request = reqMap.get(item);\n        if (!request) return;\n        if (request.action) request.action.removeRequest(request);\n        this._requestPool.put(request);\n        reqMap.delete(item);\n    }\n    _checkItemOverlap(item, checkX, checkY) {\n        const { inertAreaSize: inertAreaSize, targets: targets, clientRect: clientRect } = item;\n        if (!targets.length) {\n            checkX && this._cancelItemScroll(item, $292e4d9baf691c8b$export$5bbd74ab6c855dff.x);\n            checkY && this._cancelItemScroll(item, $292e4d9baf691c8b$export$5bbd74ab6c855dff.y);\n            return;\n        }\n        const itemData = this._itemData.get(item);\n        const moveDirectionX = itemData?.directionX;\n        const moveDirectionY = itemData?.directionY;\n        if (!moveDirectionX && !moveDirectionY) {\n            checkX && this._cancelItemScroll(item, $292e4d9baf691c8b$export$5bbd74ab6c855dff.x);\n            checkY && this._cancelItemScroll(item, $292e4d9baf691c8b$export$5bbd74ab6c855dff.y);\n            return;\n        }\n        let xElement = null;\n        let xPriority = -Infinity;\n        let xThreshold = 0;\n        let xScore = -Infinity;\n        let xDirection = $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.none;\n        let xDistance = 0;\n        let xMaxScroll = 0;\n        let yElement = null;\n        let yPriority = -Infinity;\n        let yThreshold = 0;\n        let yScore = -Infinity;\n        let yDirection = $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.none;\n        let yDistance = 0;\n        let yMaxScroll = 0;\n        let i = 0;\n        for(; i < targets.length; i++){\n            const target = targets[i];\n            const targetThreshold = typeof target.threshold === \"number\" ? target.threshold : $292e4d9baf691c8b$var$DEFAULT_THRESHOLD;\n            const testAxisX = !!(checkX && moveDirectionX && target.axis !== \"y\");\n            const testAxisY = !!(checkY && moveDirectionY && target.axis !== \"x\");\n            const testPriority = target.priority || 0;\n            // Ignore this item if it's x-axis and y-axis priority is lower than\n            // the currently matching item's.\n            if ((!testAxisX || testPriority < xPriority) && (!testAxisY || testPriority < yPriority)) continue;\n            const testElement = (0, $1d5c880696869e94$export$31d37ff78a483ce2)(target.element || target);\n            const testMaxScrollX = testAxisX ? (0, $6a48622145310dd6$export$c16047c7a398106d)(testElement) : -1;\n            const testMaxScrollY = testAxisY ? (0, $6ba3127b64f1801b$export$39d53b245a98193e)(testElement) : -1;\n            // Ignore this item if there is no possibility to scroll.\n            if (testMaxScrollX <= 0 && testMaxScrollY <= 0) continue;\n            const testRect = (0, $a91d17aaf97bddf1$export$4b834cebd9e5cebe)([\n                testElement,\n                \"padding\"\n            ], window);\n            let testScore = (0, $6551604847fd2088$export$25b3e1e24e1ba229)(clientRect, testRect) || -Infinity;\n            // If the item has no overlap with the target.\n            if (testScore === -Infinity) {\n                // If the target has virtual extra padding defined and it's padded\n                // version overlaps with item then let's compute the shortest distance\n                // between item and target and use that value (negated) as testScore.\n                if (target.padding && (0, $dce4f2a3d0d356ef$export$8d3dd0be5eb9f11f)(clientRect, $292e4d9baf691c8b$var$getPaddedRect(testRect, target.padding, $292e4d9baf691c8b$var$TEMP_RECT))) testScore = -((0, $b2dcf2463b3f9899$export$79376507b09a66f)(clientRect, testRect) || 0);\n                else continue;\n            }\n            // Test x-axis.\n            if (testAxisX && testPriority >= xPriority && testMaxScrollX > 0 && (testPriority > xPriority || testScore > xScore)) {\n                let testDistance = 0;\n                let testDirection = $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.none;\n                const testThreshold = $292e4d9baf691c8b$var$computeThreshold(targetThreshold, testRect.width);\n                const testEdgeOffset = $292e4d9baf691c8b$var$computeEdgeOffset(testThreshold, inertAreaSize, clientRect.width, testRect.width);\n                if (moveDirectionX === $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.right) {\n                    testDistance = testRect.x + testRect.width + testEdgeOffset - (clientRect.x + clientRect.width);\n                    if (testDistance <= testThreshold && !$292e4d9baf691c8b$var$isScrolledToMax((0, $8e79f2bef02bf7a3$export$1389d168952b34b5)(testElement), testMaxScrollX)) testDirection = $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.right;\n                } else if (moveDirectionX === $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.left) {\n                    testDistance = clientRect.x - (testRect.x - testEdgeOffset);\n                    if (testDistance <= testThreshold && (0, $8e79f2bef02bf7a3$export$1389d168952b34b5)(testElement) > 0) testDirection = $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.left;\n                }\n                if (testDirection) {\n                    xElement = testElement;\n                    xPriority = testPriority;\n                    xThreshold = testThreshold;\n                    xScore = testScore;\n                    xDirection = testDirection;\n                    xDistance = testDistance;\n                    xMaxScroll = testMaxScrollX;\n                }\n            }\n            // Test y-axis.\n            if (testAxisY && testPriority >= yPriority && testMaxScrollY > 0 && (testPriority > yPriority || testScore > yScore)) {\n                let testDistance = 0;\n                let testDirection = $292e4d9baf691c8b$var$AUTO_SCROLL_DIRECTION_Y.none;\n                const testThreshold = $292e4d9baf691c8b$var$computeThreshold(targetThreshold, testRect.height);\n                const testEdgeOffset = $292e4d9baf691c8b$var$computeEdgeOffset(testThreshold, inertAreaSize, clientRect.height, testRect.height);\n                if (moveDirectionY === $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.down) {\n                    testDistance = testRect.y + testRect.height + testEdgeOffset - (clientRect.y + clientRect.height);\n                    if (testDistance <= testThreshold && !$292e4d9baf691c8b$var$isScrolledToMax((0, $b796ea00009cfb0f$export$c4a223a8ba9e4ea5)(testElement), testMaxScrollY)) testDirection = $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.down;\n                } else if (moveDirectionY === $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.up) {\n                    testDistance = clientRect.y - (testRect.y - testEdgeOffset);\n                    if (testDistance <= testThreshold && (0, $b796ea00009cfb0f$export$c4a223a8ba9e4ea5)(testElement) > 0) testDirection = $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.up;\n                }\n                if (testDirection) {\n                    yElement = testElement;\n                    yPriority = testPriority;\n                    yThreshold = testThreshold;\n                    yScore = testScore;\n                    yDirection = testDirection;\n                    yDistance = testDistance;\n                    yMaxScroll = testMaxScrollY;\n                }\n            }\n        }\n        // Request or cancel x-axis scroll.\n        if (checkX) {\n            if (xElement && xDirection) this._requestItemScroll(item, $292e4d9baf691c8b$export$5bbd74ab6c855dff.x, xElement, xDirection, xThreshold, xDistance, xMaxScroll);\n            else this._cancelItemScroll(item, $292e4d9baf691c8b$export$5bbd74ab6c855dff.x);\n        }\n        // Request or cancel y-axis scroll.\n        if (checkY) {\n            if (yElement && yDirection) this._requestItemScroll(item, $292e4d9baf691c8b$export$5bbd74ab6c855dff.y, yElement, yDirection, yThreshold, yDistance, yMaxScroll);\n            else this._cancelItemScroll(item, $292e4d9baf691c8b$export$5bbd74ab6c855dff.y);\n        }\n    }\n    _updateScrollRequest(scrollRequest) {\n        const item = scrollRequest.item;\n        const { inertAreaSize: inertAreaSize, smoothStop: smoothStop, targets: targets, clientRect: clientRect } = item;\n        let hasReachedEnd = null;\n        let i = 0;\n        for(; i < targets.length; i++){\n            const target = targets[i];\n            // Make sure we have a matching element.\n            const testElement = (0, $1d5c880696869e94$export$31d37ff78a483ce2)(target.element || target);\n            if (testElement !== scrollRequest.element) continue;\n            // Make sure we have a matching axis.\n            const testIsAxisX = !!($292e4d9baf691c8b$export$5bbd74ab6c855dff.x & scrollRequest.direction);\n            if (testIsAxisX) {\n                if (target.axis === \"y\") continue;\n            } else {\n                if (target.axis === \"x\") continue;\n            }\n            // Make sure the element is still scrollable.\n            const testMaxScroll = testIsAxisX ? (0, $6a48622145310dd6$export$c16047c7a398106d)(testElement) : (0, $6ba3127b64f1801b$export$39d53b245a98193e)(testElement);\n            if (testMaxScroll <= 0) break;\n            const testRect = (0, $a91d17aaf97bddf1$export$4b834cebd9e5cebe)([\n                testElement,\n                \"padding\"\n            ], window);\n            const testScore = (0, $6551604847fd2088$export$25b3e1e24e1ba229)(clientRect, testRect) || -Infinity;\n            // If the item has no overlap with the target nor the padded target rect\n            // let's stop scrolling.\n            if (testScore === -Infinity) {\n                const padding = target.scrollPadding || target.padding;\n                if (!(padding && (0, $dce4f2a3d0d356ef$export$8d3dd0be5eb9f11f)(clientRect, $292e4d9baf691c8b$var$getPaddedRect(testRect, padding, $292e4d9baf691c8b$var$TEMP_RECT)))) break;\n            }\n            // Compute threshold.\n            const targetThreshold = typeof target.threshold === \"number\" ? target.threshold : $292e4d9baf691c8b$var$DEFAULT_THRESHOLD;\n            const testThreshold = $292e4d9baf691c8b$var$computeThreshold(targetThreshold, testIsAxisX ? testRect.width : testRect.height);\n            // Compute edge offset.\n            const testEdgeOffset = $292e4d9baf691c8b$var$computeEdgeOffset(testThreshold, inertAreaSize, testIsAxisX ? clientRect.width : clientRect.height, testIsAxisX ? testRect.width : testRect.height);\n            // Compute distance (based on current direction).\n            let testDistance = 0;\n            if (scrollRequest.direction === $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.left) testDistance = clientRect.x - (testRect.x - testEdgeOffset);\n            else if (scrollRequest.direction === $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.right) testDistance = testRect.x + testRect.width + testEdgeOffset - (clientRect.x + clientRect.width);\n            else if (scrollRequest.direction === $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.up) testDistance = clientRect.y - (testRect.y - testEdgeOffset);\n            else testDistance = testRect.y + testRect.height + testEdgeOffset - (clientRect.y + clientRect.height);\n            // Stop scrolling if threshold is not exceeded.\n            if (testDistance > testThreshold) break;\n            // Stop scrolling if we have reached max scroll value.\n            const testScroll = testIsAxisX ? (0, $8e79f2bef02bf7a3$export$1389d168952b34b5)(testElement) : (0, $b796ea00009cfb0f$export$c4a223a8ba9e4ea5)(testElement);\n            hasReachedEnd = $292e4d9baf691c8b$export$3eeb7a7b68c92567.forward & scrollRequest.direction ? $292e4d9baf691c8b$var$isScrolledToMax(testScroll, testMaxScroll) : testScroll <= 0;\n            if (hasReachedEnd) break;\n            // Scrolling can continue, let's update the values.\n            scrollRequest.maxValue = testMaxScroll;\n            scrollRequest.threshold = testThreshold;\n            scrollRequest.distance = testDistance;\n            scrollRequest.isEnding = false;\n            return true;\n        }\n        // Before we end the request, let's see if we need to stop the scrolling\n        // smoothly or immediately.\n        if (smoothStop === true && scrollRequest.speed > 0) {\n            if (hasReachedEnd === null) hasReachedEnd = scrollRequest.hasReachedEnd();\n            scrollRequest.isEnding = hasReachedEnd ? false : true;\n        } else scrollRequest.isEnding = false;\n        return scrollRequest.isEnding;\n    }\n    _updateItems() {\n        for(let i = 0; i < this.items.length; i++){\n            const item = this.items[i];\n            const itemData = this._itemData.get(item);\n            const { x: x, y: y } = item.position;\n            const prevX = itemData.positionX;\n            const prevY = itemData.positionY;\n            // If there is no change in position -> skip.\n            if (x === prevX && y === prevY) continue;\n            // Update direction x.\n            itemData.directionX = x > prevX ? $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.right : x < prevX ? $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.left : itemData.directionX;\n            // Update direction y.\n            itemData.directionY = y > prevY ? $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.down : y < prevY ? $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.up : itemData.directionY;\n            // Update positions.\n            itemData.positionX = x;\n            itemData.positionY = y;\n            // Request overlap check (if not already requested).\n            if (itemData.overlapCheckRequestTime === 0) itemData.overlapCheckRequestTime = this._tickTime;\n        }\n    }\n    _updateRequests() {\n        const items = this.items;\n        const requestsX = this._requests[$292e4d9baf691c8b$export$5bbd74ab6c855dff.x];\n        const requestsY = this._requests[$292e4d9baf691c8b$export$5bbd74ab6c855dff.y];\n        let i = 0;\n        for(; i < items.length; i++){\n            const item = items[i];\n            const itemData = this._itemData.get(item);\n            const checkTime = itemData.overlapCheckRequestTime;\n            let needsCheck = checkTime > 0 && this._tickTime - checkTime > this.settings.overlapCheckInterval;\n            let checkX = true;\n            const reqX = requestsX.get(item);\n            if (reqX && reqX.isActive) {\n                checkX = !this._updateScrollRequest(reqX);\n                if (checkX) {\n                    needsCheck = true;\n                    this._cancelItemScroll(item, $292e4d9baf691c8b$export$5bbd74ab6c855dff.x);\n                }\n            }\n            let checkY = true;\n            const reqY = requestsY.get(item);\n            if (reqY && reqY.isActive) {\n                checkY = !this._updateScrollRequest(reqY);\n                if (checkY) {\n                    needsCheck = true;\n                    this._cancelItemScroll(item, $292e4d9baf691c8b$export$5bbd74ab6c855dff.y);\n                }\n            }\n            if (needsCheck) {\n                itemData.overlapCheckRequestTime = 0;\n                this._checkItemOverlap(item, checkX, checkY);\n            }\n        }\n    }\n    _requestAction(request, axis) {\n        const isAxisX = axis === $292e4d9baf691c8b$export$5bbd74ab6c855dff.x;\n        let action = null;\n        let i = 0;\n        for(; i < this._actions.length; i++){\n            action = this._actions[i];\n            // If the action's request does not match the request's -> skip.\n            if (request.element !== action.element) {\n                action = null;\n                continue;\n            }\n            // If the request and action share the same element, but the request slot\n            // for the requested axis is already reserved let's ignore and cancel this\n            // request.\n            if (isAxisX ? action.requestX : action.requestY) {\n                this._cancelItemScroll(request.item, axis);\n                return;\n            }\n            break;\n        }\n        if (!action) action = this._actionPool.pick();\n        action.element = request.element;\n        action.addRequest(request);\n        request.tick(this._tickDeltaTime);\n        this._actions.push(action);\n    }\n    _updateActions() {\n        let i = 0;\n        // Generate actions.\n        for(i = 0; i < this.items.length; i++){\n            const item = this.items[i];\n            const reqX = this._requests[$292e4d9baf691c8b$export$5bbd74ab6c855dff.x].get(item);\n            const reqY = this._requests[$292e4d9baf691c8b$export$5bbd74ab6c855dff.y].get(item);\n            if (reqX) this._requestAction(reqX, $292e4d9baf691c8b$export$5bbd74ab6c855dff.x);\n            if (reqY) this._requestAction(reqY, $292e4d9baf691c8b$export$5bbd74ab6c855dff.y);\n        }\n        // Compute scroll values.\n        for(i = 0; i < this._actions.length; i++)this._actions[i].computeScrollValues();\n    }\n    _applyActions() {\n        // No actions -> no scrolling.\n        if (!this._actions.length) return;\n        // Scroll all the required elements.\n        let i = 0;\n        for(i = 0; i < this._actions.length; i++){\n            this._actions[i].scroll();\n            this._actionPool.put(this._actions[i]);\n        }\n        // Reset actions.\n        this._actions.length = 0;\n    }\n    addItem(item) {\n        if (this._isDestroyed || this._itemData.has(item)) return;\n        const { x: x, y: y } = item.position;\n        const itemData = new $292e4d9baf691c8b$var$AutoScrollItemData();\n        itemData.positionX = x;\n        itemData.positionY = y;\n        itemData.directionX = $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.none;\n        itemData.directionY = $292e4d9baf691c8b$export$c9fbd1f9176bc8ed.none;\n        itemData.overlapCheckRequestTime = this._tickTime;\n        this._itemData.set(item, itemData);\n        this.items.push(item);\n        if (!this._isTicking) this._startTicking();\n    }\n    removeItem(item) {\n        if (this._isDestroyed) return;\n        const index = this.items.indexOf(item);\n        if (index === -1) return;\n        if (this._requests[$292e4d9baf691c8b$export$5bbd74ab6c855dff.x].get(item)) {\n            this._cancelItemScroll(item, $292e4d9baf691c8b$export$5bbd74ab6c855dff.x);\n            this._requests[$292e4d9baf691c8b$export$5bbd74ab6c855dff.x].delete(item);\n        }\n        if (this._requests[$292e4d9baf691c8b$export$5bbd74ab6c855dff.y].get(item)) {\n            this._cancelItemScroll(item, $292e4d9baf691c8b$export$5bbd74ab6c855dff.y);\n            this._requests[$292e4d9baf691c8b$export$5bbd74ab6c855dff.y].delete(item);\n        }\n        this._itemData.delete(item);\n        this.items.splice(index, 1);\n        if (this._isTicking && !this.items.length) this._stopTicking();\n    }\n    isDestroyed() {\n        return this._isDestroyed;\n    }\n    isItemScrollingX(item) {\n        return !!this._requests[$292e4d9baf691c8b$export$5bbd74ab6c855dff.x].get(item)?.isActive;\n    }\n    isItemScrollingY(item) {\n        return !!this._requests[$292e4d9baf691c8b$export$5bbd74ab6c855dff.y].get(item)?.isActive;\n    }\n    isItemScrolling(item) {\n        return this.isItemScrollingX(item) || this.isItemScrollingY(item);\n    }\n    updateSettings(options = {}) {\n        const { overlapCheckInterval: overlapCheckInterval = this.settings.overlapCheckInterval } = options;\n        this.settings.overlapCheckInterval = overlapCheckInterval;\n    }\n    destroy() {\n        if (this._isDestroyed) return;\n        const items = this.items.slice(0);\n        let i = 0;\n        for(; i < items.length; i++)this.removeItem(items[i]);\n        this._actions.length = 0;\n        this._requestPool.reset();\n        this._actionPool.reset();\n        this._isDestroyed = true;\n    }\n}\n\n\n\nconst $b7221aa668f0d343$export$d976747ecb966cea = new (0, $292e4d9baf691c8b$export$3fb39aee5567f02e)();\n\n\nconst $6f9254451c60a12c$var$AUTOSCROLL_POSITION = {\n    x: 0,\n    y: 0\n};\nconst $6f9254451c60a12c$var$AUTOSCROLL_CLIENT_RECT = {\n    width: 0,\n    height: 0,\n    x: 0,\n    y: 0\n};\nfunction $6f9254451c60a12c$var$getDefaultSettings() {\n    return {\n        targets: [],\n        inertAreaSize: 0.2,\n        speed: (0, $292e4d9baf691c8b$export$55a384729d91296b)(),\n        smoothStop: false,\n        getPosition: (draggable)=>{\n            const { drag: drag } = draggable;\n            const primaryItem = drag?.items[0];\n            // Try to use the first item for the autoscroll data.\n            if (primaryItem) return primaryItem.position;\n            // Fallback to the sensor's clientX/clientY values.\n            const e = drag && (drag.event || drag.startEvent);\n            $6f9254451c60a12c$var$AUTOSCROLL_POSITION.x = e ? e.x : 0;\n            $6f9254451c60a12c$var$AUTOSCROLL_POSITION.y = e ? e.y : 0;\n            return $6f9254451c60a12c$var$AUTOSCROLL_POSITION;\n        },\n        getClientRect: (draggable)=>{\n            const { drag: drag } = draggable;\n            const primaryItem = drag?.items[0];\n            // Try to use the first item for the autoscroll data.\n            if (primaryItem && primaryItem.element) return primaryItem.clientRect;\n            // Fallback to the sensor's clientX/clientY values and a static size of\n            // 50x50px.\n            const e = drag && (drag.event || drag.startEvent);\n            $6f9254451c60a12c$var$AUTOSCROLL_CLIENT_RECT.width = e ? 50 : 0;\n            $6f9254451c60a12c$var$AUTOSCROLL_CLIENT_RECT.height = e ? 50 : 0;\n            $6f9254451c60a12c$var$AUTOSCROLL_CLIENT_RECT.x = e ? e.x - 25 : 0;\n            $6f9254451c60a12c$var$AUTOSCROLL_CLIENT_RECT.y = e ? e.y - 25 : 0;\n            return $6f9254451c60a12c$var$AUTOSCROLL_CLIENT_RECT;\n        },\n        onStart: null,\n        onStop: null\n    };\n}\nclass $6f9254451c60a12c$var$DraggableAutoScrollProxy {\n    constructor(draggableAutoScroll, draggable){\n        this._draggableAutoScroll = draggableAutoScroll;\n        this._draggable = draggable;\n        this._position = {\n            x: 0,\n            y: 0\n        };\n        this._clientRect = {\n            width: 0,\n            height: 0,\n            x: 0,\n            y: 0\n        };\n    }\n    _getSettings() {\n        return this._draggableAutoScroll.settings;\n    }\n    get targets() {\n        let { targets: targets } = this._getSettings();\n        if (typeof targets === \"function\") targets = targets(this._draggable);\n        return targets;\n    }\n    get position() {\n        const position = this._position;\n        const { getPosition: getPosition } = this._getSettings();\n        if (typeof getPosition === \"function\") Object.assign(position, getPosition(this._draggable));\n        else {\n            position.x = 0;\n            position.y = 0;\n        }\n        return position;\n    }\n    get clientRect() {\n        const rect = this._clientRect;\n        const { getClientRect: getClientRect } = this._getSettings();\n        if (typeof getClientRect === \"function\") Object.assign(rect, getClientRect(this._draggable));\n        else {\n            rect.width = 0;\n            rect.height = 0;\n            rect.x = 0;\n            rect.y = 0;\n        }\n        return rect;\n    }\n    get inertAreaSize() {\n        return this._getSettings().inertAreaSize;\n    }\n    get smoothStop() {\n        return this._getSettings().smoothStop;\n    }\n    get speed() {\n        return this._getSettings().speed;\n    }\n    get onStart() {\n        return this._getSettings().onStart;\n    }\n    get onStop() {\n        return this._getSettings().onStop;\n    }\n}\nclass $6f9254451c60a12c$export$5059276ad4233de3 {\n    constructor(draggable, options = {}){\n        this.name = \"autoscroll\";\n        this.version = \"0.0.3\";\n        this.settings = this._parseSettings(options);\n        this._autoScrollProxy = null;\n        draggable.on(\"start\", ()=>{\n            if (!this._autoScrollProxy) {\n                this._autoScrollProxy = new $6f9254451c60a12c$var$DraggableAutoScrollProxy(this, draggable);\n                (0, $b7221aa668f0d343$export$d976747ecb966cea).addItem(this._autoScrollProxy);\n            }\n        });\n        draggable.on(\"end\", ()=>{\n            if (this._autoScrollProxy) {\n                (0, $b7221aa668f0d343$export$d976747ecb966cea).removeItem(this._autoScrollProxy);\n                this._autoScrollProxy = null;\n            }\n        });\n    }\n    _parseSettings(options, defaults = $6f9254451c60a12c$var$getDefaultSettings()) {\n        const { targets: targets = defaults.targets, inertAreaSize: inertAreaSize = defaults.inertAreaSize, speed: speed = defaults.speed, smoothStop: smoothStop = defaults.smoothStop, getPosition: getPosition = defaults.getPosition, getClientRect: getClientRect = defaults.getClientRect, onStart: onStart = defaults.onStart, onStop: onStop = defaults.onStop } = options || {};\n        return {\n            targets: targets,\n            inertAreaSize: inertAreaSize,\n            speed: speed,\n            smoothStop: smoothStop,\n            getPosition: getPosition,\n            getClientRect: getClientRect,\n            onStart: onStart,\n            onStop: onStop\n        };\n    }\n    updateSettings(options = {}) {\n        this.settings = this._parseSettings(options, this.settings);\n    }\n}\nfunction $6f9254451c60a12c$export$c0f5c18ade842ccd(options) {\n    return (draggable)=>{\n        const p = new $6f9254451c60a12c$export$5059276ad4233de3(draggable, options);\n        const d = draggable;\n        d.plugins[p.name] = p;\n        return d;\n    };\n}\n\n\n\n\n\n\n\nconst $a4c0af497ada6b6c$var$SCROLLABLE_OVERFLOWS = new Set([\n    \"auto\",\n    \"scroll\",\n    \"overlay\"\n]);\nfunction $a4c0af497ada6b6c$export$2bb74740c4e19def(element) {\n    const style = (0, $0c69ffc8ab90052a$export$3d2f074408bd1b82)(element);\n    return !!($a4c0af497ada6b6c$var$SCROLLABLE_OVERFLOWS.has(style.overflowY) || $a4c0af497ada6b6c$var$SCROLLABLE_OVERFLOWS.has(style.overflowX));\n}\n\n\n/**\n * Check if the current value is a document.\n */ function $9cf65cecf46550ef$export$62858bae88b53fd0(value) {\n    return value instanceof Document;\n}\n\n\nfunction $319ed547835de975$export$e4864aa91b5ed091(element, result = []) {\n    let parent = element?.parentNode;\n    while(parent && !(0, $9cf65cecf46550ef$export$62858bae88b53fd0)(parent)){\n        if (parent instanceof Element) {\n            if ((0, $a4c0af497ada6b6c$export$2bb74740c4e19def)(parent)) result.push(parent);\n            parent = parent.parentNode;\n        } else if (parent instanceof ShadowRoot) parent = parent.host;\n        else parent = parent.parentNode;\n    }\n    // Always push window to the results (as last scrollable element).\n    result.push(window);\n    return result;\n}\n\n\n\nfunction $27dd69ed29855bb5$var$getScrollables(element) {\n    const scrollables = [];\n    if ((0, $a4c0af497ada6b6c$export$2bb74740c4e19def)(element)) scrollables.push(element);\n    (0, $319ed547835de975$export$e4864aa91b5ed091)(element, scrollables);\n    return scrollables;\n}\nfunction $27dd69ed29855bb5$export$88d83dc4a35d804f(options = {}) {\n    let dragAllowed = undefined;\n    let startTimeStamp = 0;\n    let targetElement = null;\n    let timer = undefined;\n    const { timeout: timeout = 250, fallback: fallback = ()=>true } = options;\n    const onContextMenu = (e)=>e.preventDefault();\n    const onTouchMove = (e)=>{\n        if (!startTimeStamp) return;\n        if (dragAllowed) {\n            e.cancelable && e.preventDefault();\n            return;\n        }\n        if (dragAllowed === undefined) {\n            if (e.cancelable && e.timeStamp - startTimeStamp > timeout) {\n                dragAllowed = true;\n                e.preventDefault();\n            } else dragAllowed = false;\n        }\n    };\n    const pointerSensorStartPredicate = (data)=>{\n        if (!(data.sensor instanceof (0, $4998740c882fb340$export$b26af955418d6638))) return fallback(data);\n        const { draggable: draggable, sensor: sensor, event: event } = data;\n        const e = event;\n        if (e.pointerType === \"touch\") {\n            // On first event (touchstart/pointerdown) we need to store the drag start\n            // data and bind listeners for touchmove and contextmenu.\n            if (e.type === \"start\" && (e.srcEvent.type === \"pointerdown\" || e.srcEvent.type === \"touchstart\")) {\n                // Prevent potentially scrollable nodes from scrolling to make sure\n                // native scrolling does not interfere with dragging.\n                targetElement = e.target;\n                const scrollables = targetElement ? $27dd69ed29855bb5$var$getScrollables(targetElement) : [];\n                scrollables.forEach((scrollable)=>{\n                    scrollable.addEventListener(\"touchmove\", onTouchMove, {\n                        passive: false,\n                        capture: true\n                    });\n                });\n                const dragEndListener = ()=>{\n                    if (!startTimeStamp) return;\n                    // Unbind listeners.\n                    draggable.off(\"end\", dragEndListener);\n                    draggable.sensors.forEach((sensor)=>{\n                        if (sensor instanceof (0, $4998740c882fb340$export$b26af955418d6638)) sensor.off(\"end\", dragEndListener);\n                    });\n                    targetElement?.removeEventListener(\"contextmenu\", onContextMenu);\n                    scrollables.forEach((scrollable)=>{\n                        scrollable.removeEventListener(\"touchmove\", onTouchMove, {\n                            capture: true\n                        });\n                    });\n                    // Reset state.\n                    startTimeStamp = 0;\n                    dragAllowed = undefined;\n                    targetElement = null;\n                    timer = void window.clearTimeout(timer);\n                };\n                // Set start state.\n                dragAllowed = undefined;\n                startTimeStamp = e.srcEvent.timeStamp;\n                // Prevent context menu popping up.\n                targetElement?.addEventListener(\"contextmenu\", onContextMenu);\n                // Reset data on drag end.\n                draggable.on(\"end\", dragEndListener);\n                draggable.sensors.forEach((sensor)=>{\n                    if (sensor instanceof (0, $4998740c882fb340$export$b26af955418d6638)) sensor.off(\"end\", dragEndListener);\n                });\n                // If we have timeout defined, let's set a timer that force starts\n                // the drag process after the timeout.\n                // TODO: This will start drag sometimes when it's not actually possible\n                // to prevent the native scrolling on touch devices. We'd need a way\n                // to check if the first touchstart/touchmove is cancelable. Needs\n                // testing on real devices. The funky thing is that we seem to need to\n                // get one touchmove event to check if we can prevent native scrolling\n                // but that is kind of too late already.. let's see if we can detect\n                // that earlier somehow.\n                if (timeout > 0) timer = window.setTimeout(()=>{\n                    draggable.resolveStartPredicate(sensor);\n                    dragAllowed = true;\n                    timer = undefined;\n                }, timeout);\n            }\n            return dragAllowed;\n        }\n        // On mouse/pen let's allow starting drag immediately if mouse's left button\n        // is pressed down.\n        if (e.type === \"start\" && !e.srcEvent.button) return true;\n        else return false;\n    };\n    return pointerSensorStartPredicate;\n}\n\n\nfunction $1e65bdb9051e6b19$var$round(value, multipleOf) {\n    return Math.round(value / multipleOf) * multipleOf;\n}\nfunction $1e65bdb9051e6b19$var$getAxisChange(gridSize, snapPosition, sensorPosition) {\n    let change = sensorPosition - snapPosition;\n    let changeAbs = Math.abs(change);\n    if (changeAbs >= gridSize) {\n        const overflow = changeAbs % gridSize;\n        return $1e65bdb9051e6b19$var$round(change > 0 ? change - overflow : change + overflow, gridSize);\n    }\n    return 0;\n}\nfunction $1e65bdb9051e6b19$export$7f11ea1f0ba255b5(gridWidth, gridHeight) {\n    return function snapModifier({ item: item, event: event, startEvent: startEvent }) {\n        let { __snapX__: __snapX__ = startEvent.x, __snapY__: __snapY__ = startEvent.y } = item.data;\n        const changeX = $1e65bdb9051e6b19$var$getAxisChange(gridWidth, __snapX__, event.x);\n        const changeY = $1e65bdb9051e6b19$var$getAxisChange(gridHeight, __snapY__, event.y);\n        if (changeX) item.data.__snapX__ = __snapX__ + changeX;\n        if (changeY) item.data.__snapY__ = __snapY__ + changeY;\n        return {\n            x: changeX,\n            y: changeY\n        };\n    };\n}\n\n\n\n\nconst $ba879827a05774f5$var$element = document.querySelector(\".draggable\");\nconst $ba879827a05774f5$var$dragContainer = document.querySelector(\".drag-container\");\nconst $ba879827a05774f5$var$pointerSensor = new (0, $4998740c882fb340$export$b26af955418d6638)($ba879827a05774f5$var$element);\nconst $ba879827a05774f5$var$keyboardSensor = new (0, $5f12a12b1bebeb44$export$436f6efcc297171)($ba879827a05774f5$var$element, {\n    computeSpeed: ()=>100\n});\nconst $ba879827a05774f5$var$draggable = new (0, $e9cd0e353e15b4ae$export$f2a139e5d18b9882)([\n    $ba879827a05774f5$var$pointerSensor,\n    $ba879827a05774f5$var$keyboardSensor\n], {\n    container: $ba879827a05774f5$var$dragContainer,\n    getElements: ()=>[\n            $ba879827a05774f5$var$element\n        ],\n    getFrozenProps: ()=>[\n            \"left\",\n            \"top\"\n        ],\n    startPredicate: (0, $27dd69ed29855bb5$export$88d83dc4a35d804f)()\n}).use((0, $6f9254451c60a12c$export$c0f5c18ade842ccd)({\n    targets: [\n        {\n            element: window,\n            axis: \"y\",\n            padding: {\n                top: Infinity,\n                bottom: Infinity\n            }\n        }\n    ]\n}));\n$ba879827a05774f5$var$draggable.on(\"start\", ()=>{\n    $ba879827a05774f5$var$element.classList.add(\"dragging\");\n});\n$ba879827a05774f5$var$draggable.on(\"end\", ()=>{\n    $ba879827a05774f5$var$element.classList.remove(\"dragging\");\n});\n\n\n//# sourceMappingURL=index.46978fe1.js.map\n","import {\n  Draggable,\n  PointerSensor,\n  KeyboardMotionSensor,\n  createPointerSensorStartPredicate,\n  autoScrollPlugin,\n} from '../../src';\n\nconst element = document.querySelector('.draggable') as HTMLElement;\nconst dragContainer = document.querySelector('.drag-container') as HTMLElement;\nconst pointerSensor = new PointerSensor(element);\nconst keyboardSensor = new KeyboardMotionSensor(element, {\n  computeSpeed: () => 100,\n});\nconst draggable = new Draggable([pointerSensor, keyboardSensor], {\n  container: dragContainer,\n  getElements: () => [element],\n  getFrozenProps: () => ['left', 'top'],\n  startPredicate: createPointerSensorStartPredicate(),\n}).use(\n  autoScrollPlugin({\n    targets: [\n      {\n        element: window,\n        axis: 'y',\n        padding: { top: Infinity, bottom: Infinity },\n      },\n    ],\n  }),\n);\n\ndraggable.on('start', () => {\n  element.classList.add('dragging');\n});\n\ndraggable.on('end', () => {\n  element.classList.remove('dragging');\n});\n","export * from './sensors/sensor.js';\n\nexport * from './sensors/base-sensor.js';\n\nexport * from './sensors/base-motion-sensor.js';\n\nexport * from './sensors/pointer-sensor.js';\n\nexport * from './sensors/keyboard-sensor.js';\n\nexport * from './sensors/keyboard-motion-sensor.js';\n\nexport * from './draggable/draggable.js';\n\nexport * from './draggable/plugins/auto-scroll-plugin.js';\n\nexport * from './auto-scroll/auto-scroll.js';\n\nexport * from './singletons/auto-scroll.js';\n\nexport * from './singletons/ticker.js';\n\nexport * from './utils/create-pointer-sensor-start-predicate.js';\n\nexport * from './utils/create-snap-modifier.js';\n","import type { EventListenerId } from 'eventti';\n\nexport const SensorEventType = {\n  start: 'start',\n  move: 'move',\n  cancel: 'cancel',\n  end: 'end',\n  destroy: 'destroy',\n} as const;\n\nexport interface SensorStartEvent {\n  type: typeof SensorEventType.start;\n  x: number;\n  y: number;\n}\n\nexport interface SensorMoveEvent {\n  type: typeof SensorEventType.move;\n  x: number;\n  y: number;\n}\n\nexport interface SensorCancelEvent {\n  type: typeof SensorEventType.cancel;\n  x: number;\n  y: number;\n}\n\nexport interface SensorEndEvent {\n  type: typeof SensorEventType.end;\n  x: number;\n  y: number;\n}\n\nexport interface SensorDestroyEvent {\n  type: typeof SensorEventType.destroy;\n}\n\nexport interface SensorEvents {\n  start: SensorStartEvent;\n  move: SensorMoveEvent;\n  cancel: SensorCancelEvent;\n  end: SensorEndEvent;\n  destroy: SensorDestroyEvent;\n}\n\nexport interface Sensor<E extends SensorEvents = SensorEvents> {\n  events: E;\n  on<T extends keyof E>(\n    type: T,\n    listener: (eventData: E[T]) => void,\n    listenerId?: EventListenerId,\n  ): EventListenerId;\n  off<T extends keyof E>(type: T, listenerId: EventListenerId): void;\n  cancel(): void;\n  destroy(): void;\n}\n","import { Emitter, Events, EventListenerId } from 'eventti';\n\nimport { Sensor, SensorEvents, SensorEventType } from './sensor.js';\n\nimport { Writeable } from '../types.js';\n\nexport interface BaseSensorDragData {\n  readonly x: number;\n  readonly y: number;\n}\n\nexport class BaseSensor<E extends SensorEvents = SensorEvents> implements Sensor<E> {\n  declare events: E;\n  readonly drag: BaseSensorDragData | null;\n  readonly isDestroyed: boolean;\n  protected _emitter: Emitter<Events>;\n\n  constructor() {\n    this.drag = null;\n    this.isDestroyed = false;\n    this._emitter = new Emitter();\n  }\n\n  protected _createDragData(data: E['start']): BaseSensorDragData {\n    return {\n      x: data.x,\n      y: data.y,\n    };\n  }\n\n  protected _updateDragData(data: E['move'] | E['end'] | E['cancel']) {\n    if (!this.drag) return;\n    (this.drag.x as Writeable<number>) = data.x;\n    (this.drag.y as Writeable<number>) = data.y;\n  }\n\n  protected _resetDragData() {\n    (this as Writeable<this>).drag = null;\n  }\n\n  protected _start(data: E['start']) {\n    if (this.isDestroyed || this.drag) return;\n    (this as Writeable<this>).drag = this._createDragData(data);\n    this._emitter.emit(SensorEventType.start, data);\n  }\n\n  protected _move(data: E['move']) {\n    if (!this.drag) return;\n    this._updateDragData(data);\n    this._emitter.emit(SensorEventType.move, data);\n  }\n\n  protected _end(data: E['end']) {\n    if (!this.drag) return;\n    this._updateDragData(data);\n    this._emitter.emit(SensorEventType.end, data);\n    this._resetDragData();\n  }\n\n  protected _cancel(data: E['cancel']) {\n    if (!this.drag) return;\n    this._updateDragData(data);\n    this._emitter.emit(SensorEventType.cancel, data);\n    this._resetDragData();\n  }\n\n  on<T extends keyof E>(\n    type: T,\n    listener: (e: E[T]) => void,\n    listenerId?: EventListenerId,\n  ): EventListenerId {\n    return this._emitter.on(type, listener, listenerId);\n  }\n\n  off<T extends keyof E>(type: T, listenerId: EventListenerId): void {\n    this._emitter.off(type, listenerId);\n  }\n\n  cancel() {\n    if (!this.drag) return;\n    this._cancel({\n      type: SensorEventType.cancel,\n      x: this.drag.x,\n      y: this.drag.y,\n    } as E['cancel']);\n  }\n\n  destroy() {\n    if (this.isDestroyed) return;\n    (this as Writeable<this>).isDestroyed = true;\n    this.cancel();\n    this._emitter.emit(SensorEventType.destroy, {\n      type: SensorEventType.destroy,\n    });\n    this._emitter.off();\n  }\n}\n","var r={ADD:\"add\",UPDATE:\"update\",IGNORE:\"ignore\",THROW:\"throw\"},a=class{constructor(n={}){let{dedupe:t=r.ADD,getId:e=()=>Symbol()}=n;this.dedupe=t,this.getId=e,this._events=new Map}_getListeners(n){let t=this._events.get(n);if(t){let{idMap:e}=t;if(e.size)return t.emitList=t.emitList||[...e.values()]}return null}on(n,t,e){let{_events:s}=this,i=s.get(n);i||(i={idMap:new Map,emitList:null},s.set(n,i));let{idMap:d,emitList:o}=i;if(e=e===void 0?this.getId(t):e,d.has(e))switch(this.dedupe){case r.THROW:throw new Error(\"Eventti: duplicate listener id!\");case r.IGNORE:return e;case r.UPDATE:{i.emitList=null;break}default:d.delete(e),i.emitList=null}return d.set(e,t),o?.push(t),e}once(n,t,e){let s=!1;return e=e===void 0?this.getId(t):e,this.on(n,(...i)=>{s||(s=!0,this.off(n,e),t(...i))},e)}off(n,t){if(n===void 0){this._events.clear();return}if(t===void 0){this._events.delete(n);return}let e=this._events.get(n);e&&e.idMap.delete(t)&&(e.emitList=null,e.idMap.size||this._events.delete(n))}emit(n,...t){let e=this._getListeners(n);if(!e)return;let{length:s}=e;if(t.length)if(s===1)e[0](...t);else{let i=0;for(;i<s;i++)e[i](...t)}else if(s===1)e[0]();else{let i=0;for(;i<s;i++)e[i]()}}listenerCount(n){if(n===void 0){let t=0;return this._events.forEach((e,s)=>{t+=this.listenerCount(s)}),t}return this._events.get(n)?.idMap.size||0}};export{a as Emitter,r as EmitterDedupe};\n","import { Sensor, SensorEvents } from './sensor.js';\n\nimport { BaseSensor, BaseSensorDragData } from './base-sensor.js';\n\nimport { Point, Writeable } from '../types.js';\n\nimport { ticker, tickerPhases } from '../singletons/ticker.js';\n\nexport interface BaseMotionSensorTickEvent {\n  type: 'tick';\n  time: number;\n  deltaTime: number;\n}\n\nexport interface BaseMotionSensorEvents extends SensorEvents {\n  tick: BaseMotionSensorTickEvent;\n}\n\nexport interface BaseMotionSensorDragData extends BaseSensorDragData {\n  readonly time: number;\n  readonly deltaTime: number;\n}\n\nexport class BaseMotionSensor<E extends BaseMotionSensorEvents = BaseMotionSensorEvents>\n  extends BaseSensor<E>\n  implements Sensor<E>\n{\n  declare events: E;\n  readonly drag: BaseMotionSensorDragData | null;\n  protected _direction: Point;\n  protected _speed: number;\n\n  constructor() {\n    super();\n    this.drag = null;\n    this._direction = { x: 0, y: 0 };\n    this._speed = 0;\n\n    this._tick = this._tick.bind(this);\n  }\n\n  protected _createDragData(data: E['start']): BaseMotionSensorDragData {\n    return {\n      ...super._createDragData(data),\n      time: 0,\n      deltaTime: 0,\n    };\n  }\n\n  protected _start(data: E['start']) {\n    if (this.isDestroyed || this.drag) return;\n    super._start(data);\n    ticker.on(tickerPhases.read, this._tick, this._tick);\n  }\n\n  protected _end(data: E['end']) {\n    if (!this.drag) return;\n    ticker.off(tickerPhases.read, this._tick);\n    super._end(data);\n  }\n\n  protected _cancel(data: E['cancel']) {\n    if (!this.drag) return;\n    ticker.off(tickerPhases.read, this._tick);\n    super._cancel(data);\n  }\n\n  protected _tick(time: number) {\n    if (!this.drag) return;\n    if (time && this.drag.time) {\n      // Update tick time and delta time.\n      (this.drag.deltaTime as Writeable<number>) = time - this.drag.time;\n      (this.drag.time as Writeable<number>) = time;\n\n      // Emit tick event.\n      const tickEvent: BaseMotionSensorTickEvent = {\n        type: 'tick',\n        time: this.drag.time,\n        deltaTime: this.drag.deltaTime,\n      };\n      this._emitter.emit('tick', tickEvent);\n\n      // Make sure the sensor is still active.\n      if (!this.drag) return;\n\n      // Compute the movement offset (delta) by applying time factor to\n      // the speed. The speed is assumed to be provided as pixels-per-second.\n      const speedFactor = this._speed * (this.drag.deltaTime / 1000);\n      const deltaX = this._direction.x * speedFactor;\n      const deltaY = this._direction.y * speedFactor;\n\n      // Trigger move event if the clientX/Y needs change. Note that calling\n      // this._move() automatically updates clientX/Y values also so we don't\n      // need to do it here.\n      if (deltaX || deltaY) {\n        this._move({\n          type: 'move',\n          x: this.drag.x + deltaX,\n          y: this.drag.y + deltaY,\n        });\n      }\n    } else {\n      (this.drag.time as Writeable<number>) = time;\n      (this.drag.deltaTime as Writeable<number>) = 0;\n    }\n  }\n}\n","import { AutoTicker, Phase, FrameCallback } from 'tikki';\n\nexport const tickerPhases = {\n  read: Symbol(),\n  write: Symbol(),\n};\n\nexport let ticker = new AutoTicker<Phase>({\n  phases: [tickerPhases.read, tickerPhases.write],\n});\n\nexport function setTicker(\n  newTicker: AutoTicker<Phase, FrameCallback>,\n  phases: typeof tickerPhases,\n) {\n  ticker = newTicker;\n  Object.assign(tickerPhases, phases);\n}\n","import{Emitter as m,EmitterDedupe as p}from\"eventti\";var _=p,o=class{constructor(e={}){let{phases:t=[],dedupe:r,getId:s}=e;this._phases=t,this._emitter=new m({getId:s,dedupe:r}),this._queue=[],this.tick=this.tick.bind(this),this._getListeners=this._emitter._getListeners.bind(this._emitter)}get phases(){return this._phases}set phases(e){this._phases=e}get dedupe(){return this._emitter.dedupe}set dedupe(e){this._emitter.dedupe=e}get getId(){return this._emitter.getId}set getId(e){this._emitter.getId=e}tick(...e){this._assertEmptyQueue(),this._fillQueue(),this._processQueue(...e)}on(e,t,r){return this._emitter.on(e,t,r)}once(e,t,r){return this._emitter.once(e,t,r)}off(e,t){return this._emitter.off(e,t)}count(e){return this._emitter.listenerCount(e)}_assertEmptyQueue(){if(this._queue.length)throw new Error(\"Ticker: Can't tick before the previous tick has finished!\")}_fillQueue(){let e=this._queue,t=this._phases,r=this._getListeners,s=0,a=t.length,n;for(;s<a;s++)n=r(t[s]),n&&e.push(n);return e}_processQueue(...e){let t=this._queue,r=t.length;if(!r)return;let s=0,a=0,n,c;for(;s<r;s++)for(n=t[s],a=0,c=n.length;a<c;a++)n[a](...e);t.length=0}};function u(i=60){if(typeof requestAnimationFrame==\"function\"&&typeof cancelAnimationFrame==\"function\")return e=>{let t=requestAnimationFrame(e);return()=>cancelAnimationFrame(t)};{let e=1e3/i,t=typeof performance>\"u\"?()=>Date.now():()=>performance.now();return r=>{let s=setTimeout(()=>r(t()),e);return()=>clearTimeout(s)}}}var l=class extends o{constructor(e={}){let{paused:t=!1,onDemand:r=!1,requestFrame:s=u(),...a}=e;super(a),this._paused=t,this._onDemand=r,this._requestFrame=s,this._cancelFrame=null,this._empty=!0,!t&&!r&&this._request()}get phases(){return this._phases}set phases(e){this._phases=e,e.length?(this._empty=!1,this._request()):this._empty=!0}get paused(){return this._paused}set paused(e){this._paused=e,e?this._cancel():this._request()}get onDemand(){return this._onDemand}set onDemand(e){this._onDemand=e,e||this._request()}get requestFrame(){return this._requestFrame}set requestFrame(e){this._requestFrame!==e&&(this._requestFrame=e,this._cancelFrame&&(this._cancel(),this._request()))}tick(...e){if(this._assertEmptyQueue(),this._cancelFrame=null,this._onDemand||this._request(),!this._empty){if(!this._fillQueue().length){this._empty=!0;return}this._onDemand&&this._request(),this._processQueue(...e)}}on(e,t,r){let s=super.on(e,t,r);return this._empty=!1,this._request(),s}once(e,t,r){let s=super.once(e,t,r);return this._empty=!1,this._request(),s}_request(){this._paused||this._cancelFrame||(this._cancelFrame=this._requestFrame(this.tick))}_cancel(){this._cancelFrame&&(this._cancelFrame(),this._cancelFrame=null)}};function I(i){return e=>{let t=i.requestAnimationFrame(e);return()=>i.cancelAnimationFrame(t)}}export{l as AutoTicker,o as Ticker,_ as TickerDedupe,u as createRequestFrame,I as createXrRequestFrame};\n","import { Emitter, Events, EventListenerId } from 'eventti';\n\nimport { ListenerOptions, Writeable, PointerType } from '../types.js';\n\nimport {\n  Sensor,\n  SensorEventType,\n  SensorStartEvent,\n  SensorMoveEvent,\n  SensorCancelEvent,\n  SensorEndEvent,\n  SensorDestroyEvent,\n} from './sensor.js';\n\nimport { getPointerEventData } from '../utils/get-pointer-event-data.js';\n\nimport { getPointerType } from '../utils/get-pointer-type.js';\n\nimport { getPointerId } from '../utils/get-pointer-id.js';\n\nimport { parseListenerOptions } from '../utils/parse-listener-options.js';\n\nimport { parseSourceEvents } from '../utils/parse-source-events.js';\n\nconst POINTER_EVENTS = {\n  start: 'pointerdown',\n  move: 'pointermove',\n  cancel: 'pointercancel',\n  end: 'pointerup',\n} as const;\n\nconst TOUCH_EVENTS = {\n  start: 'touchstart',\n  move: 'touchmove',\n  cancel: 'touchcancel',\n  end: 'touchend',\n} as const;\n\nconst MOUSE_EVENTS = {\n  start: 'mousedown',\n  move: 'mousemove',\n  cancel: '',\n  end: 'mouseup',\n} as const;\n\nconst SOURCE_EVENTS = {\n  pointer: POINTER_EVENTS,\n  touch: TOUCH_EVENTS,\n  mouse: MOUSE_EVENTS,\n} as const;\n\ntype PointerSensorSourceEvent = PointerEvent | TouchEvent | MouseEvent;\n\nexport type PointerSensorDragData = {\n  readonly pointerId: number;\n  readonly pointerType: PointerType;\n  readonly x: number;\n  readonly y: number;\n};\n\nexport interface PointerSensorSettings {\n  listenerOptions: ListenerOptions;\n  sourceEvents: keyof typeof SOURCE_EVENTS | 'auto';\n  startPredicate: (e: PointerSensorSourceEvent) => boolean;\n}\n\nexport interface PointerSensorStartEvent extends SensorStartEvent {\n  pointerId: number;\n  pointerType: PointerType;\n  srcEvent: PointerSensorSourceEvent;\n  target: EventTarget | null;\n}\n\nexport interface PointerSensorMoveEvent extends SensorMoveEvent {\n  pointerId: number;\n  pointerType: PointerType;\n  srcEvent: PointerSensorSourceEvent;\n  target: EventTarget | null;\n}\n\nexport interface PointerSensorCancelEvent extends SensorCancelEvent {\n  pointerId: number;\n  pointerType: PointerType;\n  srcEvent: PointerSensorSourceEvent | null;\n  target: EventTarget | null;\n}\n\nexport interface PointerSensorEndEvent extends SensorEndEvent {\n  pointerId: number;\n  pointerType: PointerType;\n  srcEvent: PointerSensorSourceEvent | null;\n  target: EventTarget | null;\n}\n\nexport interface PointerSensorDestroyEvent extends SensorDestroyEvent {}\n\nexport interface PointerSensorEvents {\n  start: PointerSensorStartEvent;\n  move: PointerSensorMoveEvent;\n  cancel: PointerSensorCancelEvent;\n  end: PointerSensorEndEvent;\n  destroy: PointerSensorDestroyEvent;\n}\n\nexport class PointerSensor<E extends PointerSensorEvents = PointerSensorEvents>\n  implements Sensor<E>\n{\n  declare events: E;\n\n  /**\n   * The observed element or window.\n   */\n  readonly element: Element | Window;\n\n  /**\n   * Current drag data, null if drag is not active.\n   */\n  readonly drag: PointerSensorDragData | null;\n\n  /**\n   * Indicator if the instance is destroyed.\n   */\n  readonly isDestroyed: boolean;\n\n  /**\n   * The options object to be used for `addEventListener`.\n   */\n  protected _startPredicate: (e: PointerSensorSourceEvent) => boolean;\n\n  /**\n   * The options object to be used for `addEventListener`.\n   */\n  protected _listenerOptions: ListenerOptions;\n\n  /**\n   * Type of tracked source events.\n   */\n  protected _sourceEvents: keyof typeof SOURCE_EVENTS;\n\n  /**\n   * Indicator if window's listener's are bound.\n   */\n  protected _areWindowListenersBound: boolean;\n\n  /**\n   * Internal event emitter instance.\n   */\n  protected _emitter: Emitter<Events>;\n\n  constructor(element: Element | Window, options: Partial<PointerSensorSettings> = {}) {\n    const {\n      listenerOptions = {},\n      sourceEvents = 'auto',\n      startPredicate = (e) => ('button' in e && e.button > 0 ? false : true),\n    } = options;\n\n    this.element = element;\n    this.drag = null;\n    this.isDestroyed = false;\n\n    this._areWindowListenersBound = false;\n    this._startPredicate = startPredicate;\n    this._listenerOptions = parseListenerOptions(listenerOptions);\n    this._sourceEvents = parseSourceEvents(sourceEvents);\n    this._emitter = new Emitter();\n\n    this._onStart = this._onStart.bind(this);\n    this._onMove = this._onMove.bind(this);\n    this._onCancel = this._onCancel.bind(this);\n    this._onEnd = this._onEnd.bind(this);\n\n    // Listen to start event.\n    element.addEventListener(\n      SOURCE_EVENTS[this._sourceEvents].start,\n      this._onStart as EventListener,\n      this._listenerOptions,\n    );\n  }\n\n  /**\n   * Check if the provided event contains the tracked pointer id or in the case\n   * of touch event if the first changed touch is the tracked touch object and\n   * return the event or touch object. Otherwise return null.\n   */\n  protected _getTrackedPointerEventData(\n    e: PointerSensorSourceEvent,\n  ): PointerEvent | MouseEvent | Touch | null {\n    return this.drag ? getPointerEventData(e, this.drag.pointerId) : null;\n  }\n\n  /**\n   * Listener for start event.\n   */\n  protected _onStart(e: PointerSensorSourceEvent) {\n    if (this.isDestroyed || this.drag) return;\n\n    // Make sure start predicate is fulfilled.\n    if (!this._startPredicate(e)) return;\n\n    // Try to get pointer id.\n    const pointerId = getPointerId(e);\n    if (pointerId === null) return;\n\n    // Try to get pointer.\n    const pointerEventData = getPointerEventData(e, pointerId);\n    if (pointerEventData === null) return;\n\n    // Create drag data.\n    const dragData: PointerSensorDragData = {\n      pointerId,\n      pointerType: getPointerType(e),\n      x: pointerEventData.clientX,\n      y: pointerEventData.clientY,\n    };\n\n    // Set drag data.\n    (this as Writeable<this>).drag = dragData;\n\n    // Emit start event.\n    const eventData: PointerSensorStartEvent = {\n      ...dragData,\n      type: SensorEventType.start,\n      srcEvent: e,\n      target: pointerEventData.target,\n    };\n    this._emitter.emit(eventData.type, eventData);\n\n    // If the drag procedure was not reset within the start procedure let's\n    // activate the instance (start listening to move/cancel/end events).\n    if (this.drag) {\n      this._bindWindowListeners();\n    }\n  }\n\n  /**\n   * Listener for move event.\n   */\n  protected _onMove(e: PointerSensorSourceEvent) {\n    if (!this.drag) return;\n\n    const pointerEventData = this._getTrackedPointerEventData(e);\n    if (!pointerEventData) return;\n\n    (this.drag.x as Writeable<number>) = pointerEventData.clientX;\n    (this.drag.y as Writeable<number>) = pointerEventData.clientY;\n\n    const eventData: PointerSensorMoveEvent = {\n      type: SensorEventType.move,\n      srcEvent: e,\n      target: pointerEventData.target,\n      ...this.drag,\n    };\n\n    this._emitter.emit(eventData.type, eventData);\n  }\n\n  /**\n   * Listener for cancel event.\n   */\n  protected _onCancel(e: PointerEvent | TouchEvent) {\n    if (!this.drag) return;\n\n    const pointerEventData = this._getTrackedPointerEventData(e);\n    if (!pointerEventData) return;\n\n    (this.drag.x as Writeable<number>) = pointerEventData.clientX;\n    (this.drag.y as Writeable<number>) = pointerEventData.clientY;\n\n    const eventData: PointerSensorCancelEvent = {\n      type: SensorEventType.cancel,\n      srcEvent: e,\n      target: pointerEventData.target,\n      ...this.drag,\n    };\n\n    this._emitter.emit(eventData.type, eventData);\n\n    this._resetDrag();\n  }\n\n  /**\n   * Listener for end event.\n   */\n  protected _onEnd(e: PointerSensorSourceEvent) {\n    if (!this.drag) return;\n\n    const pointerEventData = this._getTrackedPointerEventData(e);\n    if (!pointerEventData) return;\n\n    (this.drag.x as Writeable<number>) = pointerEventData.clientX;\n    (this.drag.y as Writeable<number>) = pointerEventData.clientY;\n\n    const eventData: PointerSensorEndEvent = {\n      type: SensorEventType.end,\n      srcEvent: e,\n      target: pointerEventData.target,\n      ...this.drag,\n    };\n\n    this._emitter.emit(eventData.type, eventData);\n\n    this._resetDrag();\n  }\n\n  /**\n   * Bind window event listeners for move/end/cancel.\n   */\n  protected _bindWindowListeners() {\n    if (this._areWindowListenersBound) return;\n    const { move, end, cancel } = SOURCE_EVENTS[this._sourceEvents];\n    window.addEventListener(move, this._onMove, this._listenerOptions);\n    window.addEventListener(end, this._onEnd, this._listenerOptions);\n    if (cancel) {\n      window.addEventListener(cancel, this._onCancel, this._listenerOptions);\n    }\n    this._areWindowListenersBound = true;\n  }\n\n  /**\n   * Unbind window event listeners for move/end/cancel.\n   */\n  protected _unbindWindowListeners() {\n    if (this._areWindowListenersBound) {\n      const { move, end, cancel } = SOURCE_EVENTS[this._sourceEvents];\n      window.removeEventListener(move, this._onMove, this._listenerOptions);\n      window.removeEventListener(end, this._onEnd, this._listenerOptions);\n      if (cancel) {\n        window.removeEventListener(cancel, this._onCancel, this._listenerOptions);\n      }\n      this._areWindowListenersBound = false;\n    }\n  }\n\n  /**\n   * Reset drag data.\n   */\n  protected _resetDrag() {\n    (this as Writeable<this>).drag = null;\n    this._unbindWindowListeners();\n  }\n\n  /**\n   * Forcefully cancel the drag process.\n   */\n  cancel() {\n    if (!this.drag) return;\n\n    const eventData: PointerSensorCancelEvent = {\n      type: SensorEventType.cancel,\n      srcEvent: null,\n      target: null,\n      ...this.drag,\n    };\n\n    this._emitter.emit(eventData.type, eventData);\n\n    this._resetDrag();\n  }\n\n  /**\n   * Update the instance's settings.\n   */\n  updateSettings(options: Partial<PointerSensorSettings>) {\n    if (this.isDestroyed) return;\n\n    const { listenerOptions, sourceEvents, startPredicate } = options;\n    const nextSourceEvents = parseSourceEvents(sourceEvents);\n    const nextListenerOptions = parseListenerOptions(listenerOptions);\n\n    // Update start predicate if needed.\n    if (startPredicate && this._startPredicate !== startPredicate) {\n      this._startPredicate = startPredicate;\n    }\n\n    // Update listener options and/or source events if needed.\n    if (\n      (listenerOptions &&\n        (this._listenerOptions.capture !== nextListenerOptions.capture ||\n          this._listenerOptions.passive === nextListenerOptions.passive)) ||\n      (sourceEvents && this._sourceEvents !== nextSourceEvents)\n    ) {\n      // Unbind start listener.\n      this.element.removeEventListener(\n        SOURCE_EVENTS[this._sourceEvents].start,\n        this._onStart as EventListener,\n        this._listenerOptions,\n      );\n\n      // Unbind window listeners.\n      this._unbindWindowListeners();\n\n      // Cancel current drag process.\n      this.cancel();\n\n      // Update options to instace.\n      if (sourceEvents) {\n        this._sourceEvents = nextSourceEvents;\n      }\n      if (listenerOptions && nextListenerOptions) {\n        this._listenerOptions = nextListenerOptions;\n      }\n\n      // Rebind start listener with new options.\n      this.element.addEventListener(\n        SOURCE_EVENTS[this._sourceEvents].start,\n        this._onStart as EventListener,\n        this._listenerOptions,\n      );\n    }\n  }\n\n  /**\n   * Bind a drag event listener.\n   */\n  on<T extends keyof E>(\n    type: T,\n    listener: (e: E[T]) => void,\n    listenerId?: EventListenerId,\n  ): EventListenerId {\n    return this._emitter.on(type, listener, listenerId);\n  }\n\n  /**\n   * Unbind a drag event listener.\n   */\n  off<T extends keyof E>(type: T, listenerId: EventListenerId): void {\n    this._emitter.off(type, listenerId);\n  }\n\n  /**\n   * Destroy the instance and unbind all drag event listeners.\n   */\n  destroy() {\n    if (this.isDestroyed) return;\n\n    // Mark as destroyed.\n    (this as Writeable<this>).isDestroyed = true;\n\n    // Cancel any ongoing drag process.\n    this.cancel();\n\n    // Emit destroy event.\n    this._emitter.emit(SensorEventType.destroy, {\n      type: SensorEventType.destroy,\n    });\n\n    // Destroy emitter.\n    this._emitter.off();\n\n    // Unbind start event listeners.\n    this.element.removeEventListener(\n      SOURCE_EVENTS[this._sourceEvents].start,\n      this._onStart as EventListener,\n      this._listenerOptions,\n    );\n  }\n}\n","export function getPointerEventData(\n  e: PointerEvent | TouchEvent | MouseEvent,\n  id: number,\n): PointerEvent | MouseEvent | Touch | null {\n  // If we have a pointer event return the whole event if there's a match, and\n  // null otherwise.\n  if ('pointerId' in e) {\n    return e.pointerId === id ? e : null;\n  }\n\n  // For touch events let's check if there's a changed touch object that matches\n  // the pointerId in which case return the touch object.\n  if ('changedTouches' in e) {\n    let i = 0;\n    for (; i < e.changedTouches.length; i++) {\n      if (e.changedTouches[i].identifier === id) {\n        return e.changedTouches[i];\n      }\n    }\n    return null;\n  }\n\n  // For mouse/other events let's assume there's only one pointer and just\n  // return the event.\n  return e;\n}\n","import { PointerType } from '../types.js';\n\nexport function getPointerType(e: PointerEvent | TouchEvent | MouseEvent): PointerType {\n  return 'pointerType' in e ? (e.pointerType as PointerType) : 'touches' in e ? 'touch' : 'mouse';\n}\n","export function getPointerId(e: PointerEvent | TouchEvent | MouseEvent) {\n  // If we have pointer id available let's use it.\n  if ('pointerId' in e) return e.pointerId;\n  // For touch events let's get the first changed touch's identifier.\n  if ('changedTouches' in e) return e.changedTouches[0] ? e.changedTouches[0].identifier : null;\n  // For mouse/other events let's provide a static id. And let's make it a\n  // negative number so it has it has not chance of clashing with touch/pointer\n  // ids.\n  return -1;\n}\n","import { HAS_PASSIVE_EVENTS } from '../constants.js';\n\nimport { ListenerOptions } from '../types.js';\n\nexport function parseListenerOptions(options: ListenerOptions = {}): ListenerOptions {\n  const { capture = true, passive = true } = options;\n  if (HAS_PASSIVE_EVENTS) {\n    return { capture, passive };\n  } else {\n    return { capture };\n  }\n}\n","export const IS_BROWSER = typeof window !== 'undefined' && typeof window.document !== 'undefined';\n\nexport const HAS_PASSIVE_EVENTS = (() => {\n  let isPassiveEventsSupported = false;\n  try {\n    const passiveOpts = Object.defineProperty({}, 'passive', {\n      get: function () {\n        isPassiveEventsSupported = true;\n      },\n    });\n    // @ts-ignore\n    window.addEventListener('testPassive', null, passiveOpts);\n    // @ts-ignore\n    window.removeEventListener('testPassive', null, passiveOpts);\n  } catch (e) {}\n  return isPassiveEventsSupported;\n})();\n\nexport const HAS_TOUCH_EVENTS = IS_BROWSER && 'ontouchstart' in window;\n\nexport const HAS_POINTER_EVENTS = IS_BROWSER && !!window.PointerEvent;\n\nexport const IS_SAFARI = !!(\n  IS_BROWSER &&\n  navigator.vendor &&\n  navigator.vendor.indexOf('Apple') > -1 &&\n  navigator.userAgent &&\n  navigator.userAgent.indexOf('CriOS') == -1 &&\n  navigator.userAgent.indexOf('FxiOS') == -1\n);\n","import { HAS_POINTER_EVENTS, HAS_TOUCH_EVENTS } from '../constants.js';\n\nexport function parseSourceEvents(\n  sourceEvents: 'pointer' | 'touch' | 'mouse' | 'auto' | undefined,\n): 'pointer' | 'touch' | 'mouse' {\n  return sourceEvents === 'auto' || sourceEvents === undefined\n    ? HAS_POINTER_EVENTS\n      ? 'pointer'\n      : HAS_TOUCH_EVENTS\n        ? 'touch'\n        : 'mouse'\n    : sourceEvents;\n}\n","import {\n  Sensor,\n  SensorStartEvent,\n  SensorMoveEvent,\n  SensorCancelEvent,\n  SensorEndEvent,\n  SensorDestroyEvent,\n} from './sensor.js';\n\nimport { BaseSensor } from './base-sensor.js';\n\nimport { Point } from 'types.js';\n\nexport type KeyboardSensorPredicate<E extends KeyboardSensorEvents = KeyboardSensorEvents> = (\n  e: KeyboardEvent,\n  sensor: KeyboardSensor<E>,\n) => Point | null | undefined;\n\nexport interface KeyboardSensorSettings<E extends KeyboardSensorEvents = KeyboardSensorEvents> {\n  moveDistance: number | Point;\n  cancelOnBlur: boolean;\n  cancelOnVisibilityChange: boolean;\n  startPredicate: KeyboardSensorPredicate<E>;\n  movePredicate: KeyboardSensorPredicate<E>;\n  cancelPredicate: KeyboardSensorPredicate<E>;\n  endPredicate: KeyboardSensorPredicate<E>;\n}\n\nexport interface KeyboardSensorStartEvent extends SensorStartEvent {\n  srcEvent: KeyboardEvent;\n}\n\nexport interface KeyboardSensorMoveEvent extends SensorMoveEvent {\n  srcEvent: KeyboardEvent;\n}\n\nexport interface KeyboardSensorCancelEvent extends SensorCancelEvent {\n  srcEvent: KeyboardEvent;\n}\n\nexport interface KeyboardSensorEndEvent extends SensorEndEvent {\n  srcEvent: KeyboardEvent;\n}\n\nexport interface KeyboardSensorDestroyEvent extends SensorDestroyEvent {}\n\nexport interface KeyboardSensorEvents {\n  start: KeyboardSensorStartEvent;\n  move: KeyboardSensorMoveEvent;\n  cancel: KeyboardSensorCancelEvent;\n  end: KeyboardSensorEndEvent;\n  destroy: KeyboardSensorDestroyEvent;\n}\n\nexport const keyboardSensorDefaults: KeyboardSensorSettings<any> = {\n  moveDistance: 25,\n  cancelOnBlur: true,\n  cancelOnVisibilityChange: true,\n  startPredicate: (e, sensor) => {\n    if (sensor.element && (e.key === 'Enter' || e.key === ' ')) {\n      if (document.activeElement === sensor.element) {\n        const { x, y } = sensor.element.getBoundingClientRect();\n        return { x, y };\n      }\n    }\n    return null;\n  },\n  movePredicate: (e, sensor) => {\n    if (!sensor.drag) return null;\n\n    switch (e.key) {\n      case 'ArrowLeft': {\n        return {\n          x: sensor.drag.x - sensor.moveDistance.x,\n          y: sensor.drag.y,\n        };\n      }\n      case 'ArrowRight': {\n        return {\n          x: sensor.drag.x + sensor.moveDistance.x,\n          y: sensor.drag.y,\n        };\n      }\n      case 'ArrowUp': {\n        return {\n          x: sensor.drag.x,\n          y: sensor.drag.y - sensor.moveDistance.y,\n        };\n      }\n      case 'ArrowDown': {\n        return {\n          x: sensor.drag.x,\n          y: sensor.drag.y + sensor.moveDistance.y,\n        };\n      }\n      default: {\n        return null;\n      }\n    }\n  },\n  cancelPredicate: (e, sensor) => {\n    if (sensor.drag && e.key === 'Escape') {\n      const { x, y } = sensor.drag;\n      return { x, y };\n    }\n    return null;\n  },\n  endPredicate: (e, sensor) => {\n    if (sensor.drag && (e.key === 'Enter' || e.key === ' ')) {\n      const { x, y } = sensor.drag;\n      return { x, y };\n    }\n    return null;\n  },\n} as const;\n\nexport class KeyboardSensor<E extends KeyboardSensorEvents = KeyboardSensorEvents>\n  extends BaseSensor<E>\n  implements Sensor<E>\n{\n  declare events: E;\n  readonly element: Element | null;\n  readonly moveDistance: Point;\n  protected _cancelOnBlur: boolean;\n  protected _cancelOnVisibilityChange: boolean;\n  protected _startPredicate: KeyboardSensorPredicate<E>;\n  protected _movePredicate: KeyboardSensorPredicate<E>;\n  protected _cancelPredicate: KeyboardSensorPredicate<E>;\n  protected _endPredicate: KeyboardSensorPredicate<E>;\n\n  constructor(element: Element | null, options: Partial<KeyboardSensorSettings<E>> = {}) {\n    super();\n\n    const {\n      moveDistance = keyboardSensorDefaults.moveDistance,\n      cancelOnBlur = keyboardSensorDefaults.cancelOnBlur,\n      cancelOnVisibilityChange = keyboardSensorDefaults.cancelOnVisibilityChange,\n      startPredicate = keyboardSensorDefaults.startPredicate,\n      movePredicate = keyboardSensorDefaults.movePredicate,\n      cancelPredicate = keyboardSensorDefaults.cancelPredicate,\n      endPredicate = keyboardSensorDefaults.endPredicate,\n    } = options;\n\n    this.element = element;\n    this.moveDistance =\n      typeof moveDistance === 'number' ? { x: moveDistance, y: moveDistance } : { ...moveDistance };\n    this._cancelOnBlur = cancelOnBlur;\n    this._cancelOnVisibilityChange = cancelOnVisibilityChange;\n    this._startPredicate = startPredicate;\n    this._movePredicate = movePredicate;\n    this._cancelPredicate = cancelPredicate;\n    this._endPredicate = endPredicate;\n\n    this._onKeyDown = this._onKeyDown.bind(this);\n    this._internalCancel = this._internalCancel.bind(this);\n    this._blurCancelHandler = this._blurCancelHandler.bind(this);\n\n    document.addEventListener('keydown', this._onKeyDown);\n    if (cancelOnBlur) {\n      element?.addEventListener('blur', this._blurCancelHandler);\n    }\n    if (cancelOnVisibilityChange) {\n      document.addEventListener('visibilitychange', this._internalCancel);\n    }\n  }\n\n  protected _internalCancel() {\n    this.cancel();\n  }\n\n  protected _blurCancelHandler() {\n    // If the Draggable has a container defined the dragged element will be\n    // appended to the container, which will cause the element to lose focus\n    // temporarily in some browsers (e.g. Chrome). Draggable will automatically\n    // restore the focus immediately after the element is appended, but the blur\n    // event will be triggered anyway. This is why we need to defer the cancel\n    // call to the next microtask, where we can check if the element is still\n    // focused.\n    queueMicrotask(() => {\n      if (document.activeElement !== this.element) {\n        this.cancel();\n      }\n    });\n  }\n\n  protected _onKeyDown(e: KeyboardEvent) {\n    // Handle start.\n    if (!this.drag) {\n      const startPosition = this._startPredicate(e, this);\n      if (startPosition) {\n        e.preventDefault();\n        this._start({\n          type: 'start',\n          x: startPosition.x,\n          y: startPosition.y,\n          srcEvent: e,\n        });\n      }\n      return;\n    }\n\n    // Handle cancel.\n    const cancelPosition = this._cancelPredicate(e, this);\n    if (cancelPosition) {\n      e.preventDefault();\n      this._cancel({\n        type: 'cancel',\n        x: cancelPosition.x,\n        y: cancelPosition.y,\n        srcEvent: e,\n      });\n      return;\n    }\n\n    // Handle end.\n    const endPosition = this._endPredicate(e, this);\n    if (endPosition) {\n      e.preventDefault();\n      this._end({\n        type: 'end',\n        x: endPosition.x,\n        y: endPosition.y,\n        srcEvent: e,\n      });\n      return;\n    }\n\n    // Handle move.\n    const movePosition = this._movePredicate(e, this);\n    if (movePosition) {\n      e.preventDefault();\n      this._move({\n        type: 'move',\n        x: movePosition.x,\n        y: movePosition.y,\n        srcEvent: e,\n      });\n      return;\n    }\n  }\n\n  updateSettings(options: Partial<KeyboardSensorSettings<E>> = {}) {\n    const {\n      moveDistance,\n      cancelOnBlur,\n      cancelOnVisibilityChange,\n      startPredicate,\n      movePredicate,\n      cancelPredicate,\n      endPredicate,\n    } = options;\n\n    if (moveDistance !== undefined) {\n      if (typeof moveDistance === 'number') {\n        this.moveDistance.x = this.moveDistance.y = moveDistance;\n      } else {\n        this.moveDistance.x = moveDistance.x;\n        this.moveDistance.y = moveDistance.y;\n      }\n    }\n\n    if (cancelOnBlur !== undefined && this._cancelOnBlur !== cancelOnBlur) {\n      this._cancelOnBlur = cancelOnBlur;\n      if (cancelOnBlur) {\n        this.element?.addEventListener('blur', this._blurCancelHandler);\n      } else {\n        this.element?.removeEventListener('blur', this._blurCancelHandler);\n      }\n    }\n\n    if (\n      cancelOnVisibilityChange !== undefined &&\n      this._cancelOnVisibilityChange !== cancelOnVisibilityChange\n    ) {\n      this._cancelOnVisibilityChange = cancelOnVisibilityChange;\n      if (cancelOnVisibilityChange) {\n        document.addEventListener('visibilitychange', this._internalCancel);\n      } else {\n        document.removeEventListener('visibilitychange', this._internalCancel);\n      }\n    }\n\n    if (startPredicate) {\n      this._startPredicate = startPredicate;\n    }\n\n    if (movePredicate) {\n      this._movePredicate = movePredicate;\n    }\n\n    if (cancelPredicate) {\n      this._cancelPredicate = cancelPredicate;\n    }\n\n    if (endPredicate) {\n      this._endPredicate = endPredicate;\n    }\n  }\n\n  destroy() {\n    if (this.isDestroyed) return;\n    super.destroy();\n    document.removeEventListener('keydown', this._onKeyDown);\n    if (this._cancelOnBlur) {\n      this.element?.removeEventListener('blur', this._blurCancelHandler);\n    }\n    if (this._cancelOnVisibilityChange) {\n      document.removeEventListener('visibilitychange', this._internalCancel);\n    }\n  }\n}\n","import { Sensor } from './sensor.js';\n\nimport { BaseMotionSensor, BaseMotionSensorEvents } from './base-motion-sensor.js';\n\nimport { Point } from 'types.js';\n\nexport interface KeyboardMotionSensorSettings<\n  E extends KeyboardMotionSensorEvents = KeyboardMotionSensorEvents,\n> {\n  startKeys: string[];\n  moveLeftKeys: string[];\n  moveRightKeys: string[];\n  moveUpKeys: string[];\n  moveDownKeys: string[];\n  cancelKeys: string[];\n  endKeys: string[];\n  cancelOnBlur: boolean;\n  cancelOnVisibilityChange: boolean;\n  computeSpeed: (sensor: KeyboardMotionSensor<E>) => number;\n  startPredicate: (e: KeyboardEvent, sensor: KeyboardMotionSensor<E>) => Point | null | undefined;\n}\n\nexport interface KeyboardMotionSensorEvents extends BaseMotionSensorEvents {}\n\nconst KEY_TYPES = [\n  'start',\n  'cancel',\n  'end',\n  'moveLeft',\n  'moveRight',\n  'moveUp',\n  'moveDown',\n] as const;\n\nfunction getEarliestTimestamp(keys: Set<string>, timestamps: Map<string, number>) {\n  if (!keys.size || !timestamps.size) return Infinity;\n  let result = Infinity;\n  for (const key of keys) {\n    const timestamp = timestamps.get(key);\n    if (timestamp !== undefined && timestamp < result) {\n      result = timestamp;\n    }\n  }\n  return result;\n}\n\nexport const keyboardMotionSensorDefaults: KeyboardMotionSensorSettings<any> = {\n  startKeys: [' ', 'Enter'],\n  moveLeftKeys: ['ArrowLeft'],\n  moveRightKeys: ['ArrowRight'],\n  moveUpKeys: ['ArrowUp'],\n  moveDownKeys: ['ArrowDown'],\n  cancelKeys: ['Escape'],\n  endKeys: [' ', 'Enter'],\n  cancelOnBlur: true,\n  cancelOnVisibilityChange: true,\n  computeSpeed: () => 500,\n  startPredicate: (_e, sensor) => {\n    if (sensor.element && document.activeElement === sensor.element) {\n      const { left, top } = sensor.element.getBoundingClientRect();\n      return { x: left, y: top };\n    }\n    return null;\n  },\n} as const;\n\nexport class KeyboardMotionSensor<E extends KeyboardMotionSensorEvents = KeyboardMotionSensorEvents>\n  extends BaseMotionSensor<E>\n  implements Sensor<E>\n{\n  declare events: E;\n  readonly element: Element | null;\n  protected _moveKeys: Set<string>;\n  protected _moveKeyTimestamps: Map<string, number>;\n  protected _startKeys: Set<string>;\n  protected _moveLeftKeys: Set<string>;\n  protected _moveRightKeys: Set<string>;\n  protected _moveUpKeys: Set<string>;\n  protected _moveDownKeys: Set<string>;\n  protected _cancelKeys: Set<string>;\n  protected _endKeys: Set<string>;\n  protected _cancelOnBlur: boolean;\n  protected _cancelOnVisibilityChange: boolean;\n  protected _computeSpeed: Exclude<KeyboardMotionSensorSettings<E>['computeSpeed'], undefined>;\n  protected _startPredicate: Exclude<KeyboardMotionSensorSettings<E>['startPredicate'], undefined>;\n\n  constructor(element: Element | null, options: Partial<KeyboardMotionSensorSettings<E>> = {}) {\n    super();\n\n    const {\n      startPredicate = keyboardMotionSensorDefaults.startPredicate,\n      computeSpeed = keyboardMotionSensorDefaults.computeSpeed,\n      cancelOnVisibilityChange = keyboardMotionSensorDefaults.cancelOnVisibilityChange,\n      cancelOnBlur = keyboardMotionSensorDefaults.cancelOnBlur,\n      startKeys = keyboardMotionSensorDefaults.startKeys,\n      moveLeftKeys = keyboardMotionSensorDefaults.moveLeftKeys,\n      moveRightKeys = keyboardMotionSensorDefaults.moveRightKeys,\n      moveUpKeys = keyboardMotionSensorDefaults.moveUpKeys,\n      moveDownKeys = keyboardMotionSensorDefaults.moveDownKeys,\n      cancelKeys = keyboardMotionSensorDefaults.cancelKeys,\n      endKeys = keyboardMotionSensorDefaults.endKeys,\n    } = options;\n\n    this.element = element;\n    this._startKeys = new Set(startKeys);\n    this._cancelKeys = new Set(cancelKeys);\n    this._endKeys = new Set(endKeys);\n    this._moveLeftKeys = new Set(moveLeftKeys);\n    this._moveRightKeys = new Set(moveRightKeys);\n    this._moveUpKeys = new Set(moveUpKeys);\n    this._moveDownKeys = new Set(moveDownKeys);\n    this._moveKeys = new Set([...moveLeftKeys, ...moveRightKeys, ...moveUpKeys, ...moveDownKeys]);\n    this._moveKeyTimestamps = new Map();\n    this._cancelOnBlur = cancelOnBlur;\n    this._cancelOnVisibilityChange = cancelOnVisibilityChange;\n    this._computeSpeed = computeSpeed;\n    this._startPredicate = startPredicate;\n\n    this._onKeyDown = this._onKeyDown.bind(this);\n    this._onKeyUp = this._onKeyUp.bind(this);\n    this._onTick = this._onTick.bind(this);\n    this._internalCancel = this._internalCancel.bind(this);\n    this._blurCancelHandler = this._blurCancelHandler.bind(this);\n\n    this.on('tick', this._onTick, this._onTick);\n    document.addEventListener('keydown', this._onKeyDown);\n    document.addEventListener('keyup', this._onKeyUp);\n    if (cancelOnBlur) {\n      element?.addEventListener('blur', this._blurCancelHandler);\n    }\n    if (cancelOnVisibilityChange) {\n      document.addEventListener('visibilitychange', this._internalCancel);\n    }\n  }\n\n  protected _end(data: E['end']) {\n    if (!this.drag) return;\n    this._moveKeyTimestamps.clear();\n    this._direction.x = 0;\n    this._direction.y = 0;\n    super._end(data);\n  }\n\n  protected _cancel(data: E['cancel']) {\n    if (!this.drag) return;\n    this._moveKeyTimestamps.clear();\n    this._direction.x = 0;\n    this._direction.y = 0;\n    super._cancel(data);\n  }\n\n  protected _internalCancel() {\n    this.cancel();\n  }\n\n  protected _blurCancelHandler() {\n    // If the Draggable has a container defined the dragged element will be\n    // appended to the container, which will cause the element to lose focus\n    // temporarily in some browsers (e.g. Chrome). Draggable will automatically\n    // restore the focus immediately after the element is appended, but the blur\n    // event will be triggered anyway. This is why we need to defer the cancel\n    // call to the next microtask, where we can check if the element is still\n    // focused.\n    queueMicrotask(() => {\n      if (document.activeElement !== this.element) {\n        this.cancel();\n      }\n    });\n  }\n\n  protected _updateDirection() {\n    const leftTime = getEarliestTimestamp(this._moveLeftKeys, this._moveKeyTimestamps);\n    const rightTime = getEarliestTimestamp(this._moveRightKeys, this._moveKeyTimestamps);\n    const upTime = getEarliestTimestamp(this._moveUpKeys, this._moveKeyTimestamps);\n    const downTime = getEarliestTimestamp(this._moveDownKeys, this._moveKeyTimestamps);\n\n    let x = leftTime === rightTime ? 0 : leftTime < rightTime ? -1 : 1;\n    let y = upTime === downTime ? 0 : upTime < downTime ? -1 : 1;\n\n    // If the direction is NE/NW/SE/SW we need to normalize the direction\n    // vector.\n    if (!(x === 0 || y === 0)) {\n      const normFactor = 1 / (Math.sqrt(x * x + y * y) || 1);\n      x *= normFactor;\n      y *= normFactor;\n    }\n\n    this._direction.x = x;\n    this._direction.y = y;\n  }\n\n  protected _onTick() {\n    this._speed = this._computeSpeed(this);\n  }\n\n  protected _onKeyUp(e: KeyboardEvent) {\n    if (this._moveKeyTimestamps.get(e.key)) {\n      this._moveKeyTimestamps.delete(e.key);\n      this._updateDirection();\n    }\n  }\n\n  protected _onKeyDown(e: KeyboardEvent) {\n    // Handle start.\n    if (!this.drag) {\n      if (this._startKeys.has(e.key)) {\n        const startPosition = this._startPredicate(e, this);\n        if (startPosition) {\n          e.preventDefault();\n          this._start({\n            type: 'start',\n            x: startPosition.x,\n            y: startPosition.y,\n          });\n        }\n      }\n      return;\n    }\n\n    // Handle cancel.\n    if (this._cancelKeys.has(e.key)) {\n      e.preventDefault();\n      this._internalCancel();\n      return;\n    }\n\n    // Handle end.\n    if (this._endKeys.has(e.key)) {\n      e.preventDefault();\n      this._end({\n        type: 'end',\n        x: this.drag.x,\n        y: this.drag.y,\n      });\n      return;\n    }\n\n    // Handle move.\n    if (this._moveKeys.has(e.key)) {\n      e.preventDefault();\n      if (!this._moveKeyTimestamps.get(e.key)) {\n        this._moveKeyTimestamps.set(e.key, Date.now());\n        this._updateDirection();\n      }\n      return;\n    }\n  }\n\n  updateSettings(options: Partial<KeyboardMotionSensorSettings<E>> = {}) {\n    let moveKeysMayNeedUpdate = false;\n\n    const { cancelOnBlur, cancelOnVisibilityChange, startPredicate, computeSpeed } = options;\n\n    if (cancelOnBlur !== undefined && this._cancelOnBlur !== cancelOnBlur) {\n      this._cancelOnBlur = cancelOnBlur;\n      if (cancelOnBlur) {\n        this.element?.addEventListener('blur', this._blurCancelHandler);\n      } else {\n        this.element?.removeEventListener('blur', this._blurCancelHandler);\n      }\n    }\n\n    if (\n      cancelOnVisibilityChange !== undefined &&\n      this._cancelOnVisibilityChange !== cancelOnVisibilityChange\n    ) {\n      this._cancelOnVisibilityChange = cancelOnVisibilityChange;\n      if (cancelOnVisibilityChange) {\n        document.addEventListener('visibilitychange', this._internalCancel);\n      } else {\n        document.removeEventListener('visibilitychange', this._internalCancel);\n      }\n    }\n\n    if (startPredicate !== undefined) {\n      this._startPredicate = startPredicate;\n    }\n\n    if (computeSpeed !== undefined) {\n      this._computeSpeed = computeSpeed;\n    }\n\n    KEY_TYPES.forEach((keyType, index) => {\n      const name = `${keyType}Keys` as const;\n      const value = options[name];\n      if (value !== undefined) {\n        this[`_${name}`] = new Set(value);\n        if (index >= 3) moveKeysMayNeedUpdate = true;\n      }\n    });\n\n    if (moveKeysMayNeedUpdate) {\n      // Construct the next move keys array.\n      const nextMoveKeys = [\n        ...this._moveLeftKeys,\n        ...this._moveRightKeys,\n        ...this._moveUpKeys,\n        ...this._moveDownKeys,\n      ];\n\n      // Check if the next move keys are equal to the current ones.\n      const areMoveKeysEqual = [...this._moveKeys].every(\n        (key, index) => nextMoveKeys[index] === key,\n      );\n\n      // Update move keys if needed.\n      if (!areMoveKeysEqual) {\n        this._moveKeys = new Set(nextMoveKeys);\n        this._moveKeyTimestamps.clear();\n        this._updateDirection();\n      }\n    }\n  }\n\n  destroy() {\n    if (this.isDestroyed) return;\n    super.destroy();\n    this.off('tick', this._onTick);\n    document.removeEventListener('keydown', this._onKeyDown);\n    document.removeEventListener('keyup', this._onKeyUp);\n    if (this._cancelOnBlur) {\n      this.element?.removeEventListener('blur', this._blurCancelHandler);\n    }\n    if (this._cancelOnVisibilityChange) {\n      document.removeEventListener('visibilitychange', this._internalCancel);\n    }\n  }\n}\n","import { HAS_PASSIVE_EVENTS } from '../constants.js';\n\nimport { Emitter, EventListenerId } from 'eventti';\n\nimport { Sensor, SensorEvents } from '../sensors/sensor.js';\n\nimport { DraggableDrag } from './draggable-drag.js';\n\nimport { DraggableDragItem } from './draggable-drag-item.js';\n\nimport { ticker, tickerPhases } from '../singletons/ticker.js';\n\nimport { appendElement } from 'utils/append-element.js';\n\nimport { roundNumber } from 'utils/round-number.js';\n\nimport { resetMatrix } from 'utils/reset-matrix.js';\n\nimport { areMatricesEqual } from 'utils/are-matrices-equal.js';\n\nimport { Writeable, CSSProperties, Point } from '../types.js';\n\nconst SCROLL_LISTENER_OPTIONS = HAS_PASSIVE_EVENTS ? { capture: true, passive: true } : true;\n\nconst POSITION_CHANGE = { x: 0, y: 0 };\n\nconst DOM_MATRIX = new DOMMatrix();\n\nconst TEMP_MATRIX = new DOMMatrix();\n\nenum DragStartPhase {\n  NONE = 0,\n  INIT = 1,\n  START_PREPARE = 2,\n  FINISH_APPLY = 3,\n}\n\nenum DraggableStartPredicateState {\n  PENDING = 0,\n  RESOLVED = 1,\n  REJECTED = 2,\n}\n\nexport interface DraggableSettings<S extends Sensor[], E extends S[number]['events']> {\n  container: HTMLElement | null;\n  startPredicate: (data: {\n    draggable: Draggable<S, E>;\n    sensor: S[number];\n    event: E['start'] | E['move'];\n  }) => boolean | undefined;\n  getElements: (data: {\n    draggable: Draggable<S, E>;\n    sensor: S[number];\n    startEvent: E['start'] | E['move'];\n  }) => (HTMLElement | SVGSVGElement)[] | null;\n  releaseElements: (data: {\n    draggable: Draggable<S, E>;\n    sensor: S[number];\n    elements: (HTMLElement | SVGSVGElement)[];\n  }) => void;\n  getFrozenProps: (data: {\n    draggable: Draggable<S, E>;\n    sensor: S[number];\n    item: DraggableDragItem<S, E>;\n    style: CSSStyleDeclaration;\n  }) => CSSProperties | (keyof CSSProperties)[] | null;\n  getStartPosition: (data: {\n    draggable: Draggable<S, E>;\n    sensor: S[number];\n    item: DraggableDragItem<S, E>;\n    style: CSSStyleDeclaration;\n  }) => Point;\n  setPosition: (data: {\n    draggable: Draggable<S, E>;\n    sensor: S[number];\n    phase: 'start' | 'move' | 'end' | 'align' | 'start-align';\n    item: DraggableDragItem<S, E>;\n    x: number;\n    y: number;\n  }) => void;\n  getPositionChange: (data: {\n    draggable: Draggable<S, E>;\n    sensor: S[number];\n    item: DraggableDragItem<S, E>;\n    event: E['start'] | E['move'];\n    prevEvent: E['start'] | E['move'];\n    startEvent: E['start'] | E['move'];\n  }) => Point;\n}\n\nexport interface DraggablePlugin {\n  name: string;\n  version: string;\n}\n\nexport type DraggablePluginMap = Record<string, DraggablePlugin | undefined>;\n\nexport interface DraggableEventCallbacks<E extends SensorEvents> {\n  preparestart(event: E['start'] | E['move']): void;\n  start(event: E['start'] | E['move']): void;\n  preparemove(event: E['move']): void;\n  move(event: E['move']): void;\n  end(event: E['end'] | E['cancel'] | E['destroy'] | null): void;\n  destroy(): void;\n}\n\nexport const DraggableDefaultSettings: DraggableSettings<any, any> = {\n  container: null,\n  startPredicate: () => true,\n  getElements: () => null,\n  releaseElements: () => null,\n  getFrozenProps: () => null,\n  getStartPosition: () => {\n    return { x: 0, y: 0 };\n  },\n  setPosition: ({ item, x, y, phase }) => {\n    const isEndPhase = phase === 'end';\n    const [containerMatrix, inverseContainerMatrix] = item.getContainerMatrix();\n    const [_dragContainerMatrix, inverseDragContainerMatrix] = item.getDragContainerMatrix();\n    const { startOffset, containerOffset, elementTransformMatrix, elementTransformOrigin } = item;\n    const { x: oX, y: oY, z: oZ } = elementTransformOrigin;\n    const needsOriginOffset =\n      !elementTransformMatrix.isIdentity && (oX !== 0 || oY !== 0 || oZ !== 0);\n    const tX = isEndPhase ? x : containerOffset.x + (x - startOffset.x);\n    const tY = isEndPhase ? y : containerOffset.y + (y - startOffset.y);\n\n    // Reset the matrix to identity.\n    resetMatrix(DOM_MATRIX);\n\n    // First of all negate the element's transform origin.\n    if (needsOriginOffset) {\n      if (oZ === 0) {\n        DOM_MATRIX.translateSelf(oX * -1, oY * -1);\n      } else {\n        DOM_MATRIX.translateSelf(oX * -1, oY * -1, oZ * -1);\n      }\n    }\n\n    // Invert the current container's matrix, so we can apply the\n    // translation in world space coordinates. If this is the end phase the\n    // element will have been appended back to the original container if\n    // there was a drag container defined. Otherwise the element will be\n    // appended to the drag container (if defined).\n    if (isEndPhase) {\n      if (!inverseContainerMatrix.isIdentity) {\n        DOM_MATRIX.multiplySelf(inverseContainerMatrix);\n      }\n    } else {\n      if (!inverseDragContainerMatrix.isIdentity) {\n        DOM_MATRIX.multiplySelf(inverseDragContainerMatrix);\n      }\n    }\n\n    // Apply the translation (in world space coordinates).\n    resetMatrix(TEMP_MATRIX).translateSelf(tX, tY);\n    DOM_MATRIX.multiplySelf(TEMP_MATRIX);\n\n    // Apply the element's original container's world matrix so we can apply\n    // the element's original transform as if it was in the original\n    // container's local space coordinates.\n    if (!containerMatrix.isIdentity) {\n      DOM_MATRIX.multiplySelf(containerMatrix);\n    }\n\n    // Undo the transform origin negation.\n    if (needsOriginOffset) {\n      resetMatrix(TEMP_MATRIX).translateSelf(oX, oY, oZ);\n      DOM_MATRIX.multiplySelf(TEMP_MATRIX);\n    }\n\n    // Apply the element's original transform.\n    if (!elementTransformMatrix.isIdentity) {\n      DOM_MATRIX.multiplySelf(elementTransformMatrix);\n    }\n\n    // Apply the matrix to the element.\n    item.element.style.transform = `${DOM_MATRIX}`;\n  },\n  getPositionChange: ({ event, prevEvent }) => {\n    POSITION_CHANGE.x = event.x - prevEvent.x;\n    POSITION_CHANGE.y = event.y - prevEvent.y;\n    return POSITION_CHANGE;\n  },\n} as const;\n\nexport class Draggable<\n  S extends Sensor[] = Sensor[],\n  E extends S[number]['events'] = S[number]['events'],\n  P extends DraggablePluginMap = {},\n> {\n  readonly sensors: S;\n  readonly settings: DraggableSettings<S, E>;\n  readonly plugins: P;\n  readonly drag: DraggableDrag<S, E> | null;\n  readonly isDestroyed: boolean;\n  protected _sensorData: Map<\n    S[number],\n    {\n      predicateState: DraggableStartPredicateState;\n      predicateEvent: E['start'] | E['move'] | null;\n      onMove: (e: Parameters<Draggable<S, E, P>['_onMove']>[0]) => void;\n      onEnd: (e: Parameters<Draggable<S, E, P>['_onEnd']>[0]) => void;\n    }\n  >;\n  protected _emitter: Emitter<{\n    [K in keyof DraggableEventCallbacks<E>]: DraggableEventCallbacks<E>[K];\n  }>;\n  protected _startPhase: DragStartPhase;\n  protected _startId: symbol;\n  protected _moveId: symbol;\n  protected _alignId: symbol;\n\n  constructor(sensors: S, options: Partial<DraggableSettings<S, E>> = {}) {\n    this.sensors = sensors;\n    this.settings = this._parseSettings(options);\n    this.plugins = {} as P;\n    this.drag = null;\n    this.isDestroyed = false;\n\n    this._sensorData = new Map();\n    this._emitter = new Emitter();\n    this._startPhase = DragStartPhase.NONE;\n    this._startId = Symbol();\n    this._moveId = Symbol();\n    this._alignId = Symbol();\n\n    // Bind methods (that need binding).\n    this._onMove = this._onMove.bind(this);\n    this._onScroll = this._onScroll.bind(this);\n    this._onEnd = this._onEnd.bind(this);\n    this._prepareStart = this._prepareStart.bind(this);\n    this._applyStart = this._applyStart.bind(this);\n    this._prepareMove = this._prepareMove.bind(this);\n    this._applyMove = this._applyMove.bind(this);\n    this._prepareAlign = this._prepareAlign.bind(this);\n    this._applyAlign = this._applyAlign.bind(this);\n\n    // Bind drag sensor events.\n    this.sensors.forEach((sensor) => {\n      this._sensorData.set(sensor, {\n        predicateState: DraggableStartPredicateState.PENDING,\n        predicateEvent: null,\n        onMove: (e) => this._onMove(e, sensor),\n        onEnd: (e) => this._onEnd(e, sensor),\n      });\n      const { onMove, onEnd } = this._sensorData.get(sensor)!;\n      sensor.on('start', onMove, onMove);\n      sensor.on('move', onMove, onMove);\n      sensor.on('cancel', onEnd, onEnd);\n      sensor.on('end', onEnd, onEnd);\n      sensor.on('destroy', onEnd, onEnd);\n    });\n  }\n\n  protected _parseSettings(\n    options?: Partial<this['settings']>,\n    defaults: this['settings'] = DraggableDefaultSettings,\n  ): this['settings'] {\n    const {\n      container = defaults.container,\n      startPredicate = defaults.startPredicate,\n      getElements = defaults.getElements,\n      releaseElements = defaults.releaseElements,\n      getFrozenProps = defaults.getFrozenProps,\n      getStartPosition = defaults.getStartPosition,\n      setPosition = defaults.setPosition,\n      getPositionChange = defaults.getPositionChange,\n    } = options || {};\n\n    return {\n      container,\n      startPredicate,\n      getElements,\n      releaseElements,\n      getFrozenProps,\n      getStartPosition,\n      setPosition,\n      getPositionChange,\n    };\n  }\n\n  protected _emit<K extends keyof DraggableEventCallbacks<E>>(\n    type: K,\n    ...e: Parameters<DraggableEventCallbacks<E>[K]>\n  ) {\n    this._emitter.emit(type, ...e);\n  }\n\n  protected _onMove(e: E['start'] | E['move'], sensor: S[number]) {\n    const sensorData = this._sensorData.get(sensor);\n    if (!sensorData) return;\n\n    switch (sensorData.predicateState) {\n      case DraggableStartPredicateState.PENDING: {\n        sensorData.predicateEvent = e;\n\n        // Check if drag should start.\n        const shouldStart = this.settings.startPredicate({\n          draggable: this,\n          sensor,\n          event: e,\n        });\n\n        // Resolve procedure (start move process).\n        if (shouldStart === true) {\n          this.resolveStartPredicate(sensor);\n        }\n        // Reject procedure.\n        else if (shouldStart === false) {\n          this.rejectStartPredicate(sensor);\n        }\n        break;\n      }\n      case DraggableStartPredicateState.RESOLVED: {\n        // Move the element if dragging is active.\n        if (this.drag) {\n          (this.drag as Writeable<typeof this.drag>).event = e;\n          ticker.once(tickerPhases.read, this._prepareMove, this._moveId);\n          ticker.once(tickerPhases.write, this._applyMove, this._moveId);\n        }\n        break;\n      }\n    }\n  }\n\n  protected _onScroll() {\n    this.align();\n  }\n\n  protected _onEnd(e: E['end'] | E['cancel'] | E['destroy'], sensor: S[number]) {\n    const sensorData = this._sensorData.get(sensor);\n    if (!sensorData) return;\n\n    // If there is no active drag yet, let's reset the sensor's start predicate\n    // so that it can try starting drag again.\n    if (!this.drag) {\n      sensorData.predicateState = DraggableStartPredicateState.PENDING;\n      sensorData.predicateEvent = null;\n    }\n    // Otherwise, if drag is active AND the sensor is the one that triggered the\n    // drag process, let's reset all sensors' start preidcate states.\n    else if (sensorData.predicateState === DraggableStartPredicateState.RESOLVED) {\n      (this.drag as Writeable<typeof this.drag>).endEvent = e;\n      this._sensorData.forEach((data) => {\n        data.predicateState = DraggableStartPredicateState.PENDING;\n        data.predicateEvent = null;\n      });\n      this.stop();\n    }\n  }\n\n  protected _prepareStart() {\n    const drag = this.drag;\n    if (!drag) return;\n\n    // Update start phase.\n    this._startPhase = DragStartPhase.START_PREPARE;\n\n    // Get elements that we'll need to move with the drag.\n    // NB: It is okay if there are no elements and thus no items. The drag\n    // process will process as usual, but nothing is moving by default.\n    const elements =\n      this.settings.getElements({\n        draggable: this,\n        sensor: drag.sensor,\n        startEvent: drag.startEvent,\n      }) || [];\n\n    // Create drag items.\n    (drag as Writeable<typeof drag>).items = elements.map((element) => {\n      return new DraggableDragItem(element, this);\n    });\n\n    // Emit preparestart event.\n    this._emit('preparestart', drag.startEvent);\n  }\n\n  protected _applyStart() {\n    const drag = this.drag;\n    if (!drag) return;\n\n    for (const item of drag.items) {\n      // Append element within the container element if such is provided.\n      if (item.dragContainer !== item.elementContainer) {\n        appendElement(item.element, item.dragContainer);\n      }\n\n      // Freeze element's props if such are provided.\n      if (item.frozenProps) {\n        Object.assign(item.element.style, item.frozenProps);\n      }\n\n      // Set element's start position.\n      this.settings.setPosition({\n        phase: 'start',\n        draggable: this,\n        sensor: drag.sensor,\n        item,\n        x: item.position.x,\n        y: item.position.y,\n      });\n    }\n\n    // Compute the start offset (if needed).\n    for (const item of drag.items) {\n      const containerMatrix = item.getContainerMatrix()[0];\n      const dragContainerMatrix = item.getDragContainerMatrix()[0];\n\n      // If both container matrices are equal, we can skip the computation.\n      if (areMatricesEqual(containerMatrix, dragContainerMatrix)) {\n        continue;\n      }\n\n      // TODO: We can probably also skip computation if both matrices contain\n      // only translations.\n\n      const rect = item.element.getBoundingClientRect();\n      const { startOffset } = item;\n\n      // Round the align diff to nearest 3rd decimal to avoid applying it if the\n      // value is so small that it's not visible.\n      startOffset.x = roundNumber(rect.x - item.clientRect.x, 3);\n      startOffset.y = roundNumber(rect.y - item.clientRect.y, 3);\n    }\n\n    // Apply start offset (if needed).\n    for (const item of drag.items) {\n      const { startOffset } = item;\n      if (startOffset.x !== 0 || startOffset.y !== 0) {\n        this.settings.setPosition({\n          phase: 'start-align',\n          draggable: this,\n          sensor: drag.sensor,\n          item,\n          x: item.position.x,\n          y: item.position.y,\n        });\n      }\n    }\n\n    // Bind scroll listeners.\n    window.addEventListener('scroll', this._onScroll, SCROLL_LISTENER_OPTIONS);\n\n    // Update start phase.\n    this._startPhase = DragStartPhase.FINISH_APPLY;\n\n    // Emit start event.\n    this._emit('start', drag.startEvent);\n  }\n\n  protected _prepareMove() {\n    const drag = this.drag;\n    if (!drag) return;\n\n    // Get next event and previous event so we can compute the movement\n    // difference between the clientX/Y values.\n    const { event, prevEvent, startEvent, sensor } = drag;\n    if (event === prevEvent) return;\n\n    for (const item of drag.items) {\n      // Compute how much x and y needs to be transformed.\n      const { x: changeX, y: changeY } = this.settings.getPositionChange({\n        draggable: this,\n        sensor,\n        item,\n        event,\n        prevEvent,\n        startEvent,\n      });\n\n      // Update horizontal position data.\n      if (changeX) {\n        item.position.x += changeX;\n        item.clientRect.x += changeX;\n        item['_moveDiff'].x += changeX;\n      }\n\n      // Update vertical position data.\n      if (changeY) {\n        item.position.y += changeY;\n        item.clientRect.y += changeY;\n        item['_moveDiff'].y += changeY;\n      }\n    }\n\n    // Store next event as previous event.\n    (drag as Writeable<typeof drag>).prevEvent = event;\n\n    // Emit preparemove event.\n    this._emit('preparemove', event as E['move']);\n  }\n\n  protected _applyMove() {\n    const drag = this.drag;\n    if (!drag) return;\n\n    // Reset movement diff and move the element.\n    for (const item of drag.items) {\n      item['_moveDiff'].x = 0;\n      item['_moveDiff'].y = 0;\n\n      this.settings.setPosition({\n        phase: 'move',\n        draggable: this,\n        sensor: drag.sensor,\n        item,\n        x: item.position.x,\n        y: item.position.y,\n      });\n    }\n\n    // Emit move event.\n    if (drag.event) {\n      this._emit('move', drag.event as E['move']);\n    }\n  }\n\n  protected _prepareAlign() {\n    const { drag } = this;\n    if (!drag) return;\n\n    for (const item of drag.items) {\n      const { x, y } = item.element.getBoundingClientRect();\n\n      // Note that we INTENTIONALLY DO NOT UPDATE THE CLIENT RECT COORDINATES\n      // here. The point of this method is to update the POSITION of the\n      // draggable item based on how much the client rect has drifted so that\n      // the element is visually repostioned to the correct place.\n\n      // Update horizontal position data.\n      const alignDiffX = item.clientRect.x - item['_moveDiff'].x - x;\n      item.position.x = item.position.x - item['_alignDiff'].x + alignDiffX;\n      item['_alignDiff'].x = alignDiffX;\n\n      // Update vertical position data.\n      const alignDiffY = item.clientRect.y - item['_moveDiff'].y - y;\n      item.position.y = item.position.y - item['_alignDiff'].y + alignDiffY;\n      item['_alignDiff'].y = alignDiffY;\n    }\n  }\n\n  protected _applyAlign() {\n    const { drag } = this;\n    if (!drag) return;\n\n    for (const item of drag.items) {\n      item['_alignDiff'].x = 0;\n      item['_alignDiff'].y = 0;\n\n      this.settings.setPosition({\n        phase: 'align',\n        draggable: this,\n        sensor: drag.sensor,\n        item,\n        x: item.position.x,\n        y: item.position.y,\n      });\n    }\n  }\n\n  on<T extends keyof DraggableEventCallbacks<E>>(\n    type: T,\n    listener: DraggableEventCallbacks<E>[T],\n    listenerId?: EventListenerId,\n  ): EventListenerId {\n    return this._emitter.on(type, listener, listenerId);\n  }\n\n  off<T extends keyof DraggableEventCallbacks<E>>(type: T, listenerId: EventListenerId): void {\n    this._emitter.off(type, listenerId);\n  }\n\n  resolveStartPredicate(sensor: S[number], e?: E['start'] | E['move']) {\n    const sensorData = this._sensorData.get(sensor);\n    if (!sensorData) return;\n\n    const startEvent = e || sensorData.predicateEvent;\n\n    if (sensorData.predicateState === DraggableStartPredicateState.PENDING && startEvent) {\n      //  Update start phase.\n      this._startPhase = DragStartPhase.INIT;\n\n      // Resolve the provided sensor's start predicate.\n      sensorData.predicateState = DraggableStartPredicateState.RESOLVED;\n      sensorData.predicateEvent = null;\n\n      (this as Writeable<this>).drag = new DraggableDrag(sensor, startEvent);\n\n      // Reject other sensors' start predicates.\n      this._sensorData.forEach((data, s) => {\n        if (s === sensor) return;\n        data.predicateState = DraggableStartPredicateState.REJECTED;\n        data.predicateEvent = null;\n      });\n\n      // Queue drag start.\n      ticker.once(tickerPhases.read, this._prepareStart, this._startId);\n      ticker.once(tickerPhases.write, this._applyStart, this._startId);\n    }\n  }\n\n  rejectStartPredicate(sensor: S[number]) {\n    const sensorData = this._sensorData.get(sensor);\n    if (sensorData?.predicateState === DraggableStartPredicateState.PENDING) {\n      sensorData.predicateState = DraggableStartPredicateState.REJECTED;\n      sensorData.predicateEvent = null;\n    }\n  }\n\n  stop() {\n    const drag = this.drag;\n    if (!drag || drag.isEnded) return;\n\n    // If drag start process is still in the prepare and apply phase, let's\n    // wait for it to finish before stopping the drag process. This is a very\n    // rare edge case, but it can happen if the drag process is stopped\n    // forcefully during the start phase.\n    // NB: We reuse the `_startId` symbol to queue the stop procedure.\n    if (this._startPhase === DragStartPhase.START_PREPARE) {\n      this.off('start', this._startId);\n      this.on('start', () => this.stop(), this._startId);\n      return;\n    }\n\n    // Reset drag start phase.\n    this._startPhase = DragStartPhase.NONE;\n\n    // Mark drag process as ended.\n    (drag as Writeable<typeof drag>).isEnded = true;\n\n    // Cancel all queued ticks.\n    ticker.off(tickerPhases.read, this._startId);\n    ticker.off(tickerPhases.write, this._startId);\n    ticker.off(tickerPhases.read, this._moveId);\n    ticker.off(tickerPhases.write, this._moveId);\n    ticker.off(tickerPhases.read, this._alignId);\n    ticker.off(tickerPhases.write, this._alignId);\n\n    // Unbind scroll listener.\n    window.removeEventListener('scroll', this._onScroll, SCROLL_LISTENER_OPTIONS);\n\n    // Adjust items' positions for the drop. When the drag starts the container\n    // offset is computed once, but not updated during drag (because we don't\n    // need to). But on drop we need to how much the offset diff has changed\n    // from the start and then add the diff to the item's position, and finally\n    // reset the container offset. Let's do this procedure in a separate loop to\n    // avoid layout thrashing.\n    drag['_clientOffsetCache'].clear();\n    for (const item of drag.items) {\n      if (item.elementContainer !== item.dragContainer) {\n        const { x: startX, y: startY } = item.containerOffset;\n        item.updateContainerOffset();\n        const { x: endX, y: endY } = item.containerOffset;\n        item.position.x += (endX - startX) * -1;\n        item.position.y += (endY - startY) * -1;\n        item.containerOffset.x = 0;\n        item.containerOffset.y = 0;\n      }\n    }\n\n    // Move elements within the root container and collect all elements\n    // to an elements array.\n    const elements: (HTMLElement | SVGSVGElement)[] = [];\n    for (const item of drag.items) {\n      elements.push(item.element);\n\n      if (item.elementContainer !== item.dragContainer) {\n        appendElement(item.element, item.elementContainer);\n      }\n\n      // Unfreeze element's props if such are provided.\n      if (item.unfrozenProps) {\n        for (const key in item.unfrozenProps) {\n          item.element.style[key] = item.unfrozenProps[key] || '';\n        }\n      }\n\n      // Set final position after drag.\n      this.settings.setPosition({\n        phase: 'end',\n        draggable: this,\n        sensor: drag.sensor,\n        item,\n        x: item.position.x,\n        y: item.position.y,\n      });\n    }\n\n    // Call \"releaseElements\" callback.\n    if (elements.length) {\n      this.settings.releaseElements({\n        draggable: this,\n        sensor: drag.sensor!,\n        elements,\n      });\n    }\n\n    // Remove measure elements.\n    drag['_measureElements'].forEach((el) => el.remove());\n\n    // Emit end event.\n    this._emit('end', drag.endEvent);\n\n    // Reset drag data.\n    (this as Writeable<this>).drag = null;\n  }\n\n  align(instant = false) {\n    if (!this.drag) return;\n    if (instant) {\n      this._prepareAlign();\n      this._applyAlign();\n    } else {\n      ticker.once(tickerPhases.read, this._prepareAlign, this._alignId);\n      ticker.once(tickerPhases.write, this._applyAlign, this._alignId);\n    }\n  }\n\n  updateSettings(options: Partial<this['settings']> = {}) {\n    (this as Writeable<this>).settings = this._parseSettings(options, this.settings);\n  }\n\n  use<SS extends S, EE extends SS[number]['events'], PP extends P>(\n    plugin: (draggable: this) => Draggable<SS, EE, PP>,\n  ) {\n    return plugin(this);\n  }\n\n  destroy() {\n    if (this.isDestroyed) return;\n    (this as Writeable<this>).isDestroyed = true;\n\n    this.stop();\n\n    this._sensorData.forEach(({ onMove, onEnd }, sensor) => {\n      sensor.off('start', onMove);\n      sensor.off('move', onMove);\n      sensor.off('cancel', onEnd);\n      sensor.off('end', onEnd);\n      sensor.off('destroy', onEnd);\n    });\n\n    this._sensorData.clear();\n\n    this._emit('destroy');\n\n    this._emitter.off();\n  }\n}\n","import { Sensor } from '../sensors/sensor.js';\n\nimport { DraggableDragItem } from './draggable-drag-item.js';\n\nimport { ObjectCache } from '../utils/object-cache.js';\n\nimport { Point } from '../types.js';\n\nexport class DraggableDrag<S extends Sensor[], E extends S[number]['events']> {\n  readonly sensor: S[number];\n  readonly isEnded: boolean;\n  readonly event: E['start'] | E['move'];\n  readonly prevEvent: E['start'] | E['move'];\n  readonly startEvent: E['start'] | E['move'];\n  readonly endEvent: E['end'] | E['cancel'] | E['destroy'] | null;\n  readonly items: DraggableDragItem[];\n  protected _measureElements: Map<HTMLElement, HTMLElement>;\n  protected _matrixCache: ObjectCache<HTMLElement | SVGSVGElement, [DOMMatrix, DOMMatrix]>;\n  protected _clientOffsetCache: ObjectCache<HTMLElement | SVGSVGElement | Window | Document, Point>;\n\n  constructor(sensor: S[number], startEvent: E['start'] | E['move']) {\n    this.sensor = sensor;\n    this.isEnded = false;\n    this.event = startEvent;\n    this.prevEvent = startEvent;\n    this.startEvent = startEvent;\n    this.endEvent = null;\n    this.items = [];\n    this._measureElements = new Map();\n    this._matrixCache = new ObjectCache();\n    this._clientOffsetCache = new ObjectCache();\n  }\n}\n","export class ObjectCache<Key extends any, Value extends any> {\n  private cache: Map<Key, Value> = new Map();\n  private validation: Map<Key, undefined> = new Map();\n\n  constructor() {\n    this.cache = new Map();\n    this.validation = new Map();\n  }\n\n  set(key: Key, value: Value) {\n    this.cache.set(key, value);\n    this.validation.set(key, undefined);\n  }\n\n  get(key: Key): Value | undefined {\n    return this.cache.get(key);\n  }\n\n  has(key: Key): boolean {\n    return this.cache.has(key);\n  }\n\n  delete(key: Key) {\n    this.cache.delete(key);\n    this.validation.delete(key);\n  }\n\n  isValid(key: Key): boolean {\n    return this.validation.has(key);\n  }\n\n  invalidate(key?: Key) {\n    if (key === undefined) {\n      this.validation.clear();\n    } else {\n      this.validation.delete(key);\n    }\n  }\n\n  clear() {\n    this.cache.clear();\n    this.validation.clear();\n  }\n}\n","import { getOffsetContainer } from 'mezr';\n\nimport { Sensor } from '../sensors/sensor.js';\n\nimport { CSSProperties, Point, Rect } from '../types.js';\n\nimport { getStyle } from 'utils/get-style.js';\n\nimport { getClientOffset } from 'utils/get-client-offset.js';\n\nimport { getOffsetDiff } from 'utils/get-offset-diff.js';\n\nimport { getWorldTransformMatrix } from 'utils/get-world-transform-matrix.js';\n\nimport { createWrapperElement } from 'utils/create-wrapper-element.js';\n\nimport { isMatrixWarped } from 'utils/is-matrix-warped.js';\n\nimport { parseTransformOrigin } from 'utils/parse-transform-origin.js';\n\nimport type { Draggable } from './draggable.js';\n\nimport type { ObjectCache } from 'utils/object-cache.js';\n\nexport class DraggableDragItem<\n  S extends Sensor[] = Sensor[],\n  E extends S[number]['events'] = S[number]['events'],\n> {\n  data: { [key: string]: any };\n  readonly element: HTMLElement | SVGSVGElement;\n  readonly elementContainer: HTMLElement;\n  readonly elementOffsetContainer: HTMLElement | SVGSVGElement | Window | Document;\n  readonly dragContainer: HTMLElement;\n  readonly dragOffsetContainer: HTMLElement | SVGSVGElement | Window | Document;\n  readonly elementTransformOrigin: { x: number; y: number; z: number };\n  readonly elementTransformMatrix: DOMMatrix;\n  readonly frozenProps: CSSProperties | null;\n  readonly unfrozenProps: CSSProperties | null;\n  readonly clientRect: Rect;\n  readonly position: Point;\n  readonly containerOffset: Point;\n  readonly startOffset: Point;\n  protected _moveDiff: Point;\n  protected _alignDiff: Point;\n  protected _measureElements: Map<HTMLElement, HTMLElement>;\n  protected _matrixCache: ObjectCache<HTMLElement | SVGSVGElement, [DOMMatrix, DOMMatrix]>;\n  protected _clientOffsetCache: ObjectCache<HTMLElement | SVGSVGElement | Window | Document, Point>;\n\n  constructor(element: HTMLElement | SVGSVGElement, draggable: Draggable<S, E>) {\n    // Make sure the element is in DOM.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected\n    if (!element.isConnected) {\n      throw new Error('Element is not connected');\n    }\n\n    // Make sure drag is defined.\n    const { drag } = draggable;\n    if (!drag) {\n      throw new Error('Drag is not defined');\n    }\n\n    const style = getStyle(element);\n    const clientRect = element.getBoundingClientRect();\n\n    this.data = {};\n    this.element = element;\n    this.elementTransformOrigin = parseTransformOrigin(style.transformOrigin);\n    this.elementTransformMatrix = new DOMMatrix().setMatrixValue(style.transform);\n    this.frozenProps = null;\n    this.unfrozenProps = null;\n    this.position = { x: 0, y: 0 };\n    this.containerOffset = { x: 0, y: 0 };\n    this.startOffset = { x: 0, y: 0 };\n    this._moveDiff = { x: 0, y: 0 };\n    this._alignDiff = { x: 0, y: 0 };\n    this._measureElements = drag['_measureElements'];\n    this._matrixCache = drag['_matrixCache'];\n    this._clientOffsetCache = drag['_clientOffsetCache'];\n\n    // Use element's parent element as the element container.\n    const elementContainer = element.parentElement;\n    if (!elementContainer) {\n      throw new Error('Dragged element does not have a parent element.');\n    }\n    this.elementContainer = elementContainer;\n\n    // Get element's drag parent, default to element's parent element.\n    const dragContainer = draggable.settings.container || elementContainer;\n    this.dragContainer = dragContainer;\n\n    // Make sure that the element is fixed or absolute positioned if there\n    // is a drag container.\n    if (elementContainer !== dragContainer) {\n      const { position } = style;\n      if (position !== 'fixed' && position !== 'absolute') {\n        throw new Error(\n          `Dragged element has \"${position}\" position, but only \"fixed\" or \"absolute\" are allowed when using a custom drag container.`,\n        );\n      }\n    }\n\n    // Compute element's offset container.\n    const elementOffsetContainer = getOffsetContainer(element) || element;\n    this.elementOffsetContainer = elementOffsetContainer;\n\n    // Get drag container's offset container.\n    const dragOffsetContainer =\n      dragContainer === elementContainer\n        ? elementOffsetContainer\n        : getOffsetContainer(element, { container: dragContainer })!;\n    this.dragOffsetContainer = dragOffsetContainer;\n\n    // Compute element's client rect.\n    {\n      const { width, height, x, y } = clientRect;\n      this.clientRect = { width, height, x, y };\n    }\n\n    // Compute container matrices and offset.\n    this._computeContainerMatrices();\n    this.updateContainerOffset();\n\n    // Get element's initial position. This position is relative to the\n    // properties the user is using to move the element. For example, if the\n    // user is using the `translate` transform to move the element then the\n    // initial position will be relative to the `translate` transform and the\n    // position here should reflect the transform value delta.\n    const { x, y } = draggable.settings.getStartPosition({\n      draggable,\n      sensor: drag.sensor,\n      item: this,\n      style,\n    });\n    this.position.x = x;\n    this.position.y = y;\n\n    // Get element's frozen props.\n    const frozenProps = draggable.settings.getFrozenProps({\n      draggable,\n      sensor: drag.sensor,\n      item: this,\n      style,\n    });\n    if (Array.isArray(frozenProps)) {\n      if (frozenProps.length) {\n        const props: CSSProperties = {};\n        for (const prop of frozenProps) {\n          props[prop] = style[prop];\n        }\n        this.frozenProps = props;\n      } else {\n        this.frozenProps = null;\n      }\n    } else {\n      this.frozenProps = frozenProps;\n    }\n\n    // Lastly, let's compute the unfrozen props. We store the current inline\n    // style values for all frozen props so that we can restore them after the\n    // drag process is over.\n    if (this.frozenProps) {\n      const unfrozenProps: CSSProperties = {};\n      for (const key in this.frozenProps) {\n        if (this.frozenProps.hasOwnProperty(key)) {\n          unfrozenProps[key] = element.style[key];\n        }\n      }\n      this.unfrozenProps = unfrozenProps;\n    }\n  }\n\n  protected _computeContainerMatrices() {\n    [this.elementContainer, this.dragContainer].forEach((container) => {\n      if (!this._matrixCache.isValid(container)) {\n        const matrices = this._matrixCache.get(container) || [new DOMMatrix(), new DOMMatrix()];\n        const [matrix, inverseMatrix] = matrices;\n        getWorldTransformMatrix(container, matrix);\n        inverseMatrix.setMatrixValue(matrix.toString()).invertSelf();\n        this._matrixCache.set(container, matrices);\n      }\n    });\n  }\n\n  getContainerMatrix() {\n    return this._matrixCache.get(this.elementContainer)!;\n  }\n\n  getDragContainerMatrix() {\n    return this._matrixCache.get(this.dragContainer)!;\n  }\n\n  updateContainerOffset(force = false) {\n    const {\n      elementOffsetContainer,\n      elementContainer,\n      dragOffsetContainer,\n      dragContainer,\n      containerOffset,\n      _clientOffsetCache,\n      _matrixCache,\n    } = this;\n\n    // If force is true, invalidate the client offset cache.\n    if (force) {\n      _clientOffsetCache.invalidate(dragOffsetContainer);\n      _clientOffsetCache.invalidate(elementOffsetContainer);\n    }\n\n    // If element's offset container is different than drag container's\n    // offset container let's compute the offset between the offset containers.\n    if (elementOffsetContainer !== dragOffsetContainer) {\n      // Get the client offsets for the element and drag containers.\n      const [dragOffset, elementOffset] = (\n        [\n          [dragContainer, dragOffsetContainer],\n          [elementContainer, elementOffsetContainer],\n        ] as const\n      ).map(([container, offsetContainer]) => {\n        // Get the client offset from the cache or create a new one.\n        const offset = _clientOffsetCache.get(offsetContainer) || { x: 0, y: 0 };\n\n        // If the client offset is not cached let's compute it.\n        if (!_clientOffsetCache.isValid(offsetContainer)) {\n          // Get the world transform matrices.\n          const matrices = _matrixCache.get(container);\n\n          // If the offset container is a valid HTMLElement and the matrix is\n          // not an identity matrix we need to do some extra work.\n          if (offsetContainer instanceof HTMLElement && matrices && !matrices[0].isIdentity) {\n            // If the matrix is scaled, rotated, skewed or 3d translated we\n            // (unfortunately) need to add a temporary measure element to\n            // compute the untransformed offset from the window's top-left\n            // corner. If there was a way to compute the offset without\n            // manipulating the DOM, we would definitely do that, but\n            // unfortunately, there seems to be no way to do that accurately\n            // with subpixel precision.\n            if (isMatrixWarped(matrices[0])) {\n              const measureElement =\n                this._measureElements.get(offsetContainer) || createWrapperElement(true);\n              measureElement.style.setProperty('transform', matrices[1].toString(), 'important');\n              if (!measureElement.isConnected) {\n                this._measureElements.set(offsetContainer, measureElement);\n                offsetContainer.append(measureElement);\n              }\n              getClientOffset(measureElement, offset);\n            }\n            // If the matrix only contains a 2d translation we can compute the\n            // client offset normally and subtract the translation values from\n            // the offset.\n            else {\n              getClientOffset(offsetContainer, offset);\n              offset.x -= matrices[0].m41;\n              offset.y -= matrices[0].m42;\n            }\n          }\n          // In all other cases, let's compute the client offset normally.\n          else {\n            getClientOffset(offsetContainer, offset);\n          }\n        }\n\n        // Cache the client offset.\n        _clientOffsetCache.set(offsetContainer, offset);\n\n        return offset;\n      });\n\n      getOffsetDiff(dragOffset, elementOffset, containerOffset);\n    } else {\n      containerOffset.x = 0;\n      containerOffset.y = 0;\n    }\n  }\n\n  updateSize(dimensions?: { width: number; height: number }) {\n    if (dimensions) {\n      this.clientRect.width = dimensions.width;\n      this.clientRect.height = dimensions.height;\n    } else {\n      const { width, height } = this.element.getBoundingClientRect();\n      this.clientRect.width = width;\n      this.clientRect.height = height;\n    }\n  }\n}\n","export*from\"./getContainingBlock.js\";export*from\"./getDistance.js\";export*from\"./getHeight.js\";export*from\"./getIntersection.js\";export*from\"./getOffset.js\";export*from\"./getOffsetContainer.js\";export*from\"./getOverflow.js\";export*from\"./getRect.js\";export*from\"./getWidth.js\";","import{getStyle}from\"./utils/getStyle.js\";import{isContainingBlockForFixedElement}from\"./utils/isContainingBlockForFixedElement.js\";import{isContainingBlockForAbsoluteElement}from\"./utils/isContainingBlockForAbsoluteElement.js\";import{isBlockElement}from\"./utils/isBlockElement.js\";import{isDocumentElement}from\"./utils/isDocumentElement.js\";export function getContainingBlock(e,t={}){if(isDocumentElement(e))return e.ownerDocument.defaultView;const n=t.position||getStyle(e).position,{skipDisplayNone:i,container:o}=t;switch(n){case\"static\":case\"relative\":case\"sticky\":case\"-webkit-sticky\":{let t=o||e.parentElement;for(;t;){const e=isBlockElement(t);if(e)return t;if(null===e&&!i)return null;t=t.parentElement}return e.ownerDocument.documentElement}case\"absolute\":case\"fixed\":{const t=\"fixed\"===n;let l=o||e.parentElement;for(;l;){const e=t?isContainingBlockForFixedElement(l):isContainingBlockForAbsoluteElement(l);if(!0===e)return l;if(null===e&&!i)return null;l=l.parentElement}return e.ownerDocument.defaultView}default:return null}}","const STYLE_DECLARATION_CACHE=new WeakMap;export function getStyle(e,t){if(t)return window.getComputedStyle(e,t);let C=STYLE_DECLARATION_CACHE.get(e)?.deref();return C||(C=window.getComputedStyle(e,null),STYLE_DECLARATION_CACHE.set(e,new WeakRef(C))),C}","import{IS_SAFARI}from\"./constants.js\";import{getStyle}from\"./getStyle.js\";import{isBlockElement}from\"./isBlockElement.js\";export function isContainingBlockForFixedElement(n){const t=getStyle(n);if(!IS_SAFARI){const{filter:n}=t;if(n&&\"none\"!==n)return!0;const{backdropFilter:e}=t;if(e&&\"none\"!==e)return!0;const{willChange:i}=t;if(i&&(i.indexOf(\"filter\")>-1||i.indexOf(\"backdrop-filter\")>-1))return!0}const e=isBlockElement(n);if(!e)return e;const{transform:i}=t;if(i&&\"none\"!==i)return!0;const{perspective:r}=t;if(r&&\"none\"!==r)return!0;const{contentVisibility:o}=t;if(o&&\"auto\"===o)return!0;const{contain:f}=t;if(f&&(\"strict\"===f||\"content\"===f||f.indexOf(\"paint\")>-1||f.indexOf(\"layout\")>-1))return!0;const{willChange:c}=t;return!(!c||!(c.indexOf(\"transform\")>-1||c.indexOf(\"perspective\")>-1||c.indexOf(\"contain\")>-1))||!!(IS_SAFARI&&c&&c.indexOf(\"filter\")>-1)}","export const IS_BROWSER=\"undefined\"!=typeof window&&void 0!==window.document;export const IS_SAFARI=!!(IS_BROWSER&&navigator.vendor&&navigator.vendor.indexOf(\"Apple\")>-1&&navigator.userAgent&&-1==navigator.userAgent.indexOf(\"CriOS\")&&-1==navigator.userAgent.indexOf(\"FxiOS\"));export const BOX_EDGE={content:\"content\",padding:\"padding\",scrollbar:\"scrollbar\",border:\"border\",margin:\"margin\"};export const INCLUDE_WINDOW_SCROLLBAR={[BOX_EDGE.content]:!1,[BOX_EDGE.padding]:!1,[BOX_EDGE.scrollbar]:!0,[BOX_EDGE.border]:!0,[BOX_EDGE.margin]:!0};export const SCROLLABLE_OVERFLOWS=new Set([\"auto\",\"scroll\"]);export const IS_CHROMIUM=(()=>{try{return window.navigator.userAgentData.brands.some((({brand:n})=>\"Chromium\"===n))}catch(n){return!1}})();","import{getStyle}from\"./getStyle.js\";export function isBlockElement(e){switch(getStyle(e).display){case\"none\":return null;case\"inline\":case\"contents\":return!1;default:return!0}}","import{getStyle}from\"./getStyle.js\";import{isContainingBlockForFixedElement}from\"./isContainingBlockForFixedElement.js\";export function isContainingBlockForAbsoluteElement(t){return\"static\"!==getStyle(t).position||isContainingBlockForFixedElement(t)}","export function isDocumentElement(e){return e instanceof HTMLHtmlElement}","import{getDistanceBetweenRects}from\"./utils/getDistanceBetweenRects.js\";import{getNormalizedRect}from\"./utils/getNormalizedRect.js\";export function getDistance(e,t){const c=getNormalizedRect(e),i=getNormalizedRect(t);return getDistanceBetweenRects(c,i)}","import{isIntersecting}from\"./isIntersecting.js\";import{getDistanceBetweenPoints}from\"./getDistanceBetweenPoints.js\";export function getDistanceBetweenRects(t,e){if(isIntersecting(t,e))return null;const n=t.left+t.width,i=t.top+t.height,o=e.left+e.width,s=e.top+e.height;return n<=e.left?i<=e.top?getDistanceBetweenPoints(n,i,e.left,e.top):t.top>=s?getDistanceBetweenPoints(n,t.top,e.left,s):e.left-n:t.left>=o?i<=e.top?getDistanceBetweenPoints(t.left,i,o,e.top):t.top>=s?getDistanceBetweenPoints(t.left,t.top,o,s):t.left-o:i<=e.top?e.top-i:t.top-s}","export function isIntersecting(t,e){return!(t.left+t.width<=e.left||e.left+e.width<=t.left||t.top+t.height<=e.top||e.top+e.height<=t.top)}","export function getDistanceBetweenPoints(t,e,n,o){return Math.sqrt(Math.pow(n-t,2)+Math.pow(o-e,2))}","import{getRect}from\"../getRect.js\";import{isRectObject}from\"./isRectObject.js\";export function getNormalizedRect(t){return isRectObject(t)?t:getRect(t)}","import{getWidth}from\"./getWidth.js\";import{getHeight}from\"./getHeight.js\";import{getOffset}from\"./getOffset.js\";import{isRectObject}from\"./utils/isRectObject.js\";export function getRect(t,e){let i=0,g=0;isRectObject(t)?(i=t.width,g=t.height):Array.isArray(t)?(i=getWidth(...t),g=getHeight(...t)):(i=getWidth(t),g=getHeight(t));const r=getOffset(t,e);return{width:i,height:g,...r,right:r.left+i,bottom:r.top+g}}","import{INCLUDE_WINDOW_SCROLLBAR,BOX_EDGE}from\"./utils/constants.js\";import{isWindow}from\"./utils/isWindow.js\";import{isDocument}from\"./utils/isDocument.js\";import{getWindowWidth}from\"./utils/getWindowWidth.js\";import{getDocumentWidth}from\"./utils/getDocumentWidth.js\";import{getElementWidth}from\"./utils/getElementWidth.js\";export function getWidth(t,i=BOX_EDGE.border){return isWindow(t)?getWindowWidth(t,INCLUDE_WINDOW_SCROLLBAR[i]):isDocument(t)?getDocumentWidth(t):getElementWidth(t,i)}","export function isWindow(n){return n instanceof Window}","export function isDocument(n){return n instanceof Document}","import{getPreciseScrollbarSize}from\"./getPreciseScrollbarSize.js\";export function getWindowWidth(e,r=!1){if(r)return e.innerWidth;const{innerWidth:t,document:i}=e,{documentElement:n}=i,{clientWidth:c}=n;return t-getPreciseScrollbarSize(n,\"y\",t-c)}","import{IS_CHROMIUM}from\"./constants.js\";import{getStyle}from\"./getStyle.js\";const SUBPIXEL_OFFSET=new Map;let testStyleElement=null,testParentElement=null,testChildElement=null;function getSubpixelScrollbarSize(t,e){const n=t.split(\".\");let l=SUBPIXEL_OFFSET.get(n[1]);if(void 0===l){testStyleElement||(testStyleElement=document.createElement(\"style\")),testStyleElement.innerHTML=`\\n      #mezr-scrollbar-test::-webkit-scrollbar {\\n        width: ${t} !important;\\n      }\\n    `,testParentElement&&testChildElement||(testParentElement=document.createElement(\"div\"),testChildElement=document.createElement(\"div\"),testParentElement.appendChild(testChildElement),testParentElement.id=\"mezr-scrollbar-test\",testParentElement.style.cssText=\"\\n        all: unset !important;\\n        position: fixed !important;\\n        top: -200px !important;\\n        left: 0px !important;\\n        width: 100px !important;\\n        height: 100px !important;\\n        overflow: scroll !important;\\n        pointer-events: none !important;\\n        visibility: hidden !important;\\n      \",testChildElement.style.cssText=\"\\n        all: unset !important;\\n        position: absolute !important;\\n        inset: 0 !important;\\n      \"),document.body.appendChild(testStyleElement),document.body.appendChild(testParentElement);l=testParentElement.getBoundingClientRect().width-testChildElement.getBoundingClientRect().width-e,SUBPIXEL_OFFSET.set(n[1],l),document.body.removeChild(testParentElement),document.body.removeChild(testStyleElement)}return e+l}export function getPreciseScrollbarSize(t,e,n){if(n<=0)return 0;if(IS_CHROMIUM){const n=getStyle(t,\"::-webkit-scrollbar\"),l=\"x\"===e?n.height:n.width,i=parseFloat(l);if(!Number.isNaN(i)&&!Number.isInteger(i))return getSubpixelScrollbarSize(l,i)}return n}","export function getDocumentWidth({documentElement:t}){return Math.max(t.scrollWidth,t.clientWidth,t.getBoundingClientRect().width)}","import{BOX_EDGE,SCROLLABLE_OVERFLOWS}from\"./constants.js\";import{getStyle}from\"./getStyle.js\";import{getPreciseScrollbarSize}from\"./getPreciseScrollbarSize.js\";import{isDocumentElement}from\"./isDocumentElement.js\";export function getElementWidth(t,e=BOX_EDGE.border){let{width:r}=t.getBoundingClientRect();if(e===BOX_EDGE.border)return r;const o=getStyle(t);return e===BOX_EDGE.margin?(r+=Math.max(0,parseFloat(o.marginLeft)||0),r+=Math.max(0,parseFloat(o.marginRight)||0),r):(r-=parseFloat(o.borderLeftWidth)||0,r-=parseFloat(o.borderRightWidth)||0,e===BOX_EDGE.scrollbar?r:(!isDocumentElement(t)&&SCROLLABLE_OVERFLOWS.has(o.overflowY)&&(r-=getPreciseScrollbarSize(t,\"y\",Math.round(r)-t.clientWidth)),e===BOX_EDGE.padding||(r-=parseFloat(o.paddingLeft)||0,r-=parseFloat(o.paddingRight)||0),r))}","import{INCLUDE_WINDOW_SCROLLBAR,BOX_EDGE}from\"./utils/constants.js\";import{isWindow}from\"./utils/isWindow.js\";import{isDocument}from\"./utils/isDocument.js\";import{getWindowHeight}from\"./utils/getWindowHeight.js\";import{getDocumentHeight}from\"./utils/getDocumentHeight.js\";import{getElementHeight}from\"./utils/getElementHeight.js\";export function getHeight(t,e=BOX_EDGE.border){return isWindow(t)?getWindowHeight(t,INCLUDE_WINDOW_SCROLLBAR[e]):isDocument(t)?getDocumentHeight(t):getElementHeight(t,e)}","import{getPreciseScrollbarSize}from\"./getPreciseScrollbarSize.js\";export function getWindowHeight(e,r=!1){if(r)return e.innerHeight;const{innerHeight:t,document:i}=e,{documentElement:n}=i,{clientHeight:c}=n;return t-getPreciseScrollbarSize(n,\"x\",t-c)}","export function getDocumentHeight({documentElement:t}){return Math.max(t.scrollHeight,t.clientHeight,t.getBoundingClientRect().height)}","import{BOX_EDGE,SCROLLABLE_OVERFLOWS}from\"./constants.js\";import{getStyle}from\"./getStyle.js\";import{getPreciseScrollbarSize}from\"./getPreciseScrollbarSize.js\";import{isDocumentElement}from\"./isDocumentElement.js\";export function getElementHeight(t,e=BOX_EDGE.border){let{height:r}=t.getBoundingClientRect();if(e===BOX_EDGE.border)return r;const o=getStyle(t);return e===BOX_EDGE.margin?(r+=Math.max(0,parseFloat(o.marginTop)||0),r+=Math.max(0,parseFloat(o.marginBottom)||0),r):(r-=parseFloat(o.borderTopWidth)||0,r-=parseFloat(o.borderBottomWidth)||0,e===BOX_EDGE.scrollbar?r:(!isDocumentElement(t)&&SCROLLABLE_OVERFLOWS.has(o.overflowX)&&(r-=getPreciseScrollbarSize(t,\"x\",Math.round(r)-t.clientHeight)),e===BOX_EDGE.padding||(r-=parseFloat(o.paddingTop)||0,r-=parseFloat(o.paddingBottom)||0),r))}","import{isRectObject}from\"./utils/isRectObject.js\";import{isDocument}from\"./utils/isDocument.js\";import{getOffsetFromDocument}from\"./utils/getOffsetFromDocument.js\";export function getOffset(t,e){const o=isRectObject(t)?{left:t.left,top:t.top}:Array.isArray(t)?getOffsetFromDocument(...t):getOffsetFromDocument(t);if(e&&!isDocument(e)){const t=isRectObject(e)?e:Array.isArray(e)?getOffsetFromDocument(e[0],e[1]):getOffsetFromDocument(e);o.left-=t.left,o.top-=t.top}return o}","export function isRectObject(t){return t?.constructor===Object}","import{BOX_EDGE}from\"./constants.js\";import{getStyle}from\"./getStyle.js\";import{isDocument}from\"./isDocument.js\";import{isWindow}from\"./isWindow.js\";export function getOffsetFromDocument(t,o=BOX_EDGE.border){const e={left:0,top:0};if(isDocument(t))return e;if(isWindow(t))return e.left+=t.scrollX||0,e.top+=t.scrollY||0,e;const r=t.ownerDocument.defaultView;r&&(e.left+=r.scrollX||0,e.top+=r.scrollY||0);const n=t.getBoundingClientRect();if(e.left+=n.left,e.top+=n.top,o===BOX_EDGE.border)return e;const l=getStyle(t);return o===BOX_EDGE.margin?(e.left-=Math.max(0,parseFloat(l.marginLeft)||0),e.top-=Math.max(0,parseFloat(l.marginTop)||0),e):(e.left+=parseFloat(l.borderLeftWidth)||0,e.top+=parseFloat(l.borderTopWidth)||0,o===BOX_EDGE.scrollbar||o===BOX_EDGE.padding||(e.left+=parseFloat(l.paddingLeft)||0,e.top+=parseFloat(l.paddingTop)||0),e)}","import{getNormalizedRect}from\"./utils/getNormalizedRect.js\";export function getIntersection(t,...e){const o={...getNormalizedRect(t),right:0,bottom:0};for(const t of e){const e=getNormalizedRect(t),i=Math.max(o.left,e.left),h=Math.min(o.left+o.width,e.left+e.width);if(h<=i)return null;const r=Math.max(o.top,e.top),l=Math.min(o.top+o.height,e.height+e.top);if(l<=r)return null;o.left=i,o.top=r,o.width=h-i,o.height=l-r}return o.right=o.left+o.width,o.bottom=o.top+o.height,o}","import{getStyle}from\"./utils/getStyle.js\";import{getContainingBlock}from\"./getContainingBlock.js\";import{isWindow}from\"./utils/isWindow.js\";export function getOffsetContainer(n,t={}){const i=getStyle(n),{display:o}=i;if(\"none\"===o||\"contents\"===o)return null;const e=t.position||getStyle(n).position,{skipDisplayNone:s,container:r}=t;switch(e){case\"relative\":return n;case\"fixed\":return getContainingBlock(n,{container:r,position:e,skipDisplayNone:s});case\"absolute\":{const t=getContainingBlock(n,{container:r,position:e,skipDisplayNone:s});return isWindow(t)?n.ownerDocument:t}default:return null}}","import{getNormalizedRect}from\"./utils/getNormalizedRect.js\";export function getOverflow(t,e){const o=getNormalizedRect(t),i=getNormalizedRect(e);return{left:i.left-o.left,right:o.left+o.width-(i.left+i.width),top:i.top-o.top,bottom:o.top+o.height-(i.top+i.height)}}","const STYLE_DECLARATION_CACHE: WeakMap<Element, WeakRef<CSSStyleDeclaration>> = new WeakMap();\n\n/**\n * Returns element's CSS Style Declaration. Caches reference to the declaration\n * object weakly for faster access.\n */\nexport function getStyle(element: Element) {\n  let styleDeclaration = STYLE_DECLARATION_CACHE.get(element)?.deref();\n\n  if (!styleDeclaration) {\n    styleDeclaration = window.getComputedStyle(element, null);\n    STYLE_DECLARATION_CACHE.set(element, new WeakRef(styleDeclaration));\n  }\n\n  return styleDeclaration;\n}\n","import { Point } from 'types.js';\nimport { getStyle } from './get-style.js';\n\n// Computes element's (padding box) offset from the window's top-left corner.\nexport function getClientOffset(\n  element: HTMLElement | SVGSVGElement | Window | Document,\n  result: Point = { x: 0, y: 0 },\n): Point {\n  result.x = 0;\n  result.y = 0;\n\n  // If window, return 0, 0.\n  if (element instanceof Window) {\n    return result;\n  }\n\n  // If document, return the offset from Window.\n  if (element instanceof Document) {\n    result.x = window.scrollX * -1;\n    result.y = window.scrollY * -1;\n    return result;\n  }\n\n  // If element, calculate the offset from the element's padding box to the\n  // window's top-left corner.\n  const { x, y } = element.getBoundingClientRect();\n  const style = getStyle(element);\n  result.x = x + (parseFloat(style.borderLeftWidth) || 0);\n  result.y = y + (parseFloat(style.borderTopWidth) || 0);\n  return result;\n}\n","import { Point } from 'types.js';\nimport { getClientOffset } from './get-client-offset.js';\nimport { isPoint } from './is-point.js';\n\nconst OFFSET_A = { x: 0, y: 0 };\nconst OFFSET_B = { x: 0, y: 0 };\n\n/**\n * Calculate the offset difference two elements.\n */\nexport function getOffsetDiff(\n  elemA: HTMLElement | SVGSVGElement | Window | Document | Point,\n  elemB: HTMLElement | SVGSVGElement | Window | Document | Point,\n  result: Point = { x: 0, y: 0 },\n) {\n  const offsetA = isPoint(elemA) ? elemA : getClientOffset(elemA, OFFSET_A);\n  const offsetB = isPoint(elemB) ? elemB : getClientOffset(elemB, OFFSET_B);\n  result.x = offsetB.x - offsetA.x;\n  result.y = offsetB.y - offsetA.y;\n  return result;\n}\n","import { Point } from 'types.js';\n\nexport function isPoint(value: any): value is Point {\n  return typeof value === 'object' && value !== null && 'x' in value && 'y' in value;\n}\n","import { getStyle } from './get-style.js';\nimport { parseTransformOrigin } from './parse-transform-origin.js';\nimport { resetMatrix } from './reset-matrix.js';\n\nconst MATRIX = new DOMMatrix();\n\nexport function getWorldTransformMatrix(\n  el: HTMLElement | SVGSVGElement,\n  result = new DOMMatrix(),\n): DOMMatrix {\n  let currentElement: HTMLElement | SVGSVGElement | null = el;\n\n  // Reset the result matrix to identity.\n  resetMatrix(result);\n\n  while (currentElement) {\n    const { transform, transformOrigin } = getStyle(currentElement);\n    if (transform && transform !== 'none') {\n      MATRIX.setMatrixValue(transform);\n      if (!MATRIX.isIdentity) {\n        const { x, y, z } = parseTransformOrigin(transformOrigin);\n        if (z === 0) {\n          MATRIX.setMatrixValue(\n            `translate(${x}px, ${y}px) ${MATRIX} translate(${x * -1}px, ${y * -1}px)`,\n          );\n        } else {\n          MATRIX.setMatrixValue(\n            `translate3d(${x}px, ${y}px, ${z}px) ${MATRIX} translate3d(${x * -1}px, ${y * -1}px, ${z * -1}px)`,\n          );\n        }\n        result.preMultiplySelf(MATRIX);\n      }\n    }\n    currentElement = currentElement.parentElement;\n  }\n\n  return result;\n}\n","export function parseTransformOrigin(transformOrigin: string): { x: number; y: number; z: number } {\n  const values = transformOrigin.split(' ');\n  let originX = '';\n  let originY = '';\n  let originZ = '';\n\n  if (values.length === 1) {\n    originX = originY = values[0];\n  } else if (values.length === 2) {\n    [originX, originY] = values;\n  } else {\n    [originX, originY, originZ] = values;\n  }\n\n  return {\n    x: parseFloat(originX) || 0,\n    y: parseFloat(originY) || 0,\n    z: parseFloat(originZ) || 0,\n  };\n}\n","const RESET_TRANSFORM = 'scale(1, 1)';\n\nexport function resetMatrix(m: DOMMatrix) {\n  return m.setMatrixValue(RESET_TRANSFORM);\n}\n","import { setStyles } from './set-styles.js';\n\nexport function createWrapperElement(isMeasureElement = false) {\n  const el = document.createElement('div');\n\n  setStyles(\n    el,\n    Object.assign<{}, {}>(\n      {\n        display: 'block',\n        position: 'absolute',\n        padding: '0px',\n        margin: '0px',\n        border: 'none',\n        transform: 'none',\n        'transform-origin': '0 0',\n        transition: 'none',\n        animation: 'none',\n      },\n      isMeasureElement\n        ? {\n            inset: '0px',\n            opacity: '0',\n            'pointer-events': 'none',\n          }\n        : {\n            width: '0px',\n            height: '0px',\n            left: '0px',\n            top: '0px',\n          },\n    ),\n    true,\n  );\n\n  if (isMeasureElement) {\n    el.classList.add('dragdoll-measure');\n  } else {\n    el.classList.add('dragdoll-container');\n  }\n\n  return el;\n}\n","export function setStyles(el: HTMLElement, styles: Record<string, string>, important = false) {\n  const { style } = el;\n  for (const key in styles) {\n    style.setProperty(key, styles[key], important ? 'important' : '');\n  }\n}\n","// The naming is a bit misleading here, but this function in essence checks if a\n// matrix contains any transformation other than a 2d translation.\nexport function isMatrixWarped(m: DOMMatrix) {\n  return (\n    m.m11 !== 1 ||\n    m.m12 !== 0 ||\n    m.m13 !== 0 ||\n    m.m14 !== 0 ||\n    m.m21 !== 0 ||\n    m.m22 !== 1 ||\n    m.m23 !== 0 ||\n    m.m24 !== 0 ||\n    m.m31 !== 0 ||\n    m.m32 !== 0 ||\n    m.m33 !== 1 ||\n    m.m34 !== 0 ||\n    m.m43 !== 0 ||\n    m.m44 !== 1\n  );\n}\n","// A special append method which doesn't lose focus when appending an element.\nexport function appendElement(\n  element: HTMLElement | SVGSVGElement,\n  container: HTMLElement,\n  innerContainer?: HTMLElement | null,\n) {\n  const focusedElement = document.activeElement;\n  const containsFocus = element.contains(focusedElement);\n  if (innerContainer) innerContainer.append(element);\n  container.append(innerContainer || element);\n  if (containsFocus && document.activeElement !== focusedElement) {\n    (focusedElement as HTMLElement).focus({ preventScroll: true });\n  }\n}\n","export function roundNumber(value: number, decimals = 0): number {\n  const multiplier = Math.pow(10, decimals);\n  return Math.round((value + Number.EPSILON) * multiplier) / multiplier;\n}\n","export function areMatricesEqual(m1: DOMMatrix, m2: DOMMatrix) {\n  if (m1.isIdentity && m2.isIdentity) return true;\n\n  if (m1.is2D && m2.is2D) {\n    return (\n      m1.a === m2.a &&\n      m1.b === m2.b &&\n      m1.c === m2.c &&\n      m1.d === m2.d &&\n      m1.e === m2.e &&\n      m1.f === m2.f\n    );\n  }\n\n  return (\n    m1.m11 === m2.m11 &&\n    m1.m12 === m2.m12 &&\n    m1.m13 === m2.m13 &&\n    m1.m14 === m2.m14 &&\n    m1.m21 === m2.m21 &&\n    m1.m22 === m2.m22 &&\n    m1.m23 === m2.m23 &&\n    m1.m24 === m2.m24 &&\n    m1.m31 === m2.m31 &&\n    m1.m32 === m2.m32 &&\n    m1.m33 === m2.m33 &&\n    m1.m34 === m2.m34 &&\n    m1.m41 === m2.m41 &&\n    m1.m42 === m2.m42 &&\n    m1.m43 === m2.m43 &&\n    m1.m44 === m2.m44\n  );\n}\n","import { Draggable, DraggablePluginMap } from '../draggable.js';\n\nimport { Sensor } from '../../sensors/sensor.js';\n\nimport {\n  AutoScrollItem,\n  AutoScrollItemSpeedCallback,\n  AutoScrollItemEventCallback,\n  AutoScrollItemTarget,\n  autoScrollSmoothSpeed,\n} from '../../auto-scroll/auto-scroll.js';\n\nimport { autoScroll } from '../../singletons/auto-scroll.js';\n\nimport { Point, Rect, Writeable } from '../../types.js';\n\nconst AUTOSCROLL_POSITION: Point = { x: 0, y: 0 };\n\nconst AUTOSCROLL_CLIENT_RECT: Rect = {\n  width: 0,\n  height: 0,\n  x: 0,\n  y: 0,\n};\n\nfunction getDefaultSettings<S extends Sensor[], E extends S[number]['events']>() {\n  return {\n    targets: [],\n    inertAreaSize: 0.2,\n    speed: autoScrollSmoothSpeed(),\n    smoothStop: false,\n    getPosition: (draggable: Draggable<S, E>) => {\n      const { drag } = draggable;\n      const primaryItem = drag?.items[0];\n\n      // Try to use the first item for the autoscroll data.\n      if (primaryItem) {\n        return primaryItem.position;\n      }\n\n      // Fallback to the sensor's clientX/clientY values.\n      const e = drag && (drag.event || drag.startEvent);\n      AUTOSCROLL_POSITION.x = e ? e.x : 0;\n      AUTOSCROLL_POSITION.y = e ? e.y : 0;\n      return AUTOSCROLL_POSITION;\n    },\n    getClientRect: (draggable: Draggable<S, E>) => {\n      const { drag } = draggable;\n      const primaryItem = drag?.items[0];\n\n      // Try to use the first item for the autoscroll data.\n      if (primaryItem && primaryItem.element) {\n        return primaryItem.clientRect;\n      }\n\n      // Fallback to the sensor's clientX/clientY values and a static size of\n      // 50x50px.\n      const e = drag && (drag.event || drag.startEvent);\n      AUTOSCROLL_CLIENT_RECT.width = e ? 50 : 0;\n      AUTOSCROLL_CLIENT_RECT.height = e ? 50 : 0;\n      AUTOSCROLL_CLIENT_RECT.x = e ? e.x - 25 : 0;\n      AUTOSCROLL_CLIENT_RECT.y = e ? e.y - 25 : 0;\n      return AUTOSCROLL_CLIENT_RECT;\n    },\n    onStart: null,\n    onStop: null,\n  };\n}\n\nclass DraggableAutoScrollProxy<S extends Sensor[], E extends S[number]['events']>\n  implements AutoScrollItem\n{\n  protected _draggableAutoScroll: DraggableAutoScroll<S, E>;\n  protected _draggable: Draggable<S, E>;\n  protected _position: AutoScrollItem['position'];\n  protected _clientRect: AutoScrollItem['clientRect'];\n\n  constructor(draggableAutoScroll: DraggableAutoScroll<S, E>, draggable: Draggable<S, E>) {\n    this._draggableAutoScroll = draggableAutoScroll;\n    this._draggable = draggable;\n    this._position = { x: 0, y: 0 };\n    this._clientRect = { width: 0, height: 0, x: 0, y: 0 };\n  }\n\n  private _getSettings() {\n    return this._draggableAutoScroll.settings;\n  }\n\n  get targets() {\n    let { targets } = this._getSettings();\n    if (typeof targets === 'function') {\n      targets = targets(this._draggable);\n    }\n    return targets;\n  }\n\n  get position() {\n    const position = this._position;\n    const { getPosition } = this._getSettings();\n    if (typeof getPosition === 'function') {\n      Object.assign(position, getPosition(this._draggable));\n    } else {\n      position.x = 0;\n      position.y = 0;\n    }\n    return position;\n  }\n\n  get clientRect() {\n    const rect = this._clientRect;\n    const { getClientRect } = this._getSettings();\n    if (typeof getClientRect === 'function') {\n      Object.assign(rect, getClientRect(this._draggable));\n    } else {\n      rect.width = 0;\n      rect.height = 0;\n      rect.x = 0;\n      rect.y = 0;\n    }\n    return rect;\n  }\n\n  get inertAreaSize() {\n    return this._getSettings().inertAreaSize;\n  }\n\n  get smoothStop() {\n    return this._getSettings().smoothStop;\n  }\n\n  get speed() {\n    return this._getSettings().speed;\n  }\n\n  get onStart() {\n    return this._getSettings().onStart;\n  }\n\n  get onStop() {\n    return this._getSettings().onStop;\n  }\n}\n\nexport interface DraggableAutoScrollSettings<S extends Sensor[], E extends S[number]['events']> {\n  targets: AutoScrollItemTarget[] | ((draggable: Draggable<S, E>) => AutoScrollItemTarget[]);\n  inertAreaSize: number;\n  speed: number | AutoScrollItemSpeedCallback;\n  smoothStop: boolean;\n  getPosition: ((draggable: Draggable<S, E>) => Point) | null;\n  getClientRect: ((draggable: Draggable<S, E>) => Rect) | null;\n  onStart: AutoScrollItemEventCallback | null;\n  onStop: AutoScrollItemEventCallback | null;\n}\n\nexport type DraggableAutoScrollOptions<S extends Sensor[], E extends S[number]['events']> = Partial<\n  DraggableAutoScrollSettings<S, E>\n>;\n\nexport class DraggableAutoScroll<\n  S extends Sensor[] = Sensor[],\n  E extends S[number]['events'] = S[number]['events'],\n> {\n  readonly name: 'autoscroll';\n  readonly version: string;\n  readonly settings: DraggableAutoScrollSettings<S, E>;\n  protected _autoScrollProxy: DraggableAutoScrollProxy<S, E> | null;\n\n  constructor(draggable: Draggable<S, E>, options: DraggableAutoScrollOptions<S, E> = {}) {\n    this.name = 'autoscroll';\n    this.version = '0.0.3';\n    this.settings = this._parseSettings(options);\n    this._autoScrollProxy = null;\n\n    draggable.on('start', () => {\n      if (!this._autoScrollProxy) {\n        this._autoScrollProxy = new DraggableAutoScrollProxy(this, draggable);\n        autoScroll.addItem(this._autoScrollProxy);\n      }\n    });\n\n    draggable.on('end', () => {\n      if (this._autoScrollProxy) {\n        autoScroll.removeItem(this._autoScrollProxy);\n        this._autoScrollProxy = null;\n      }\n    });\n  }\n\n  protected _parseSettings(\n    options?: Partial<this['settings']>,\n    defaults: this['settings'] = getDefaultSettings(),\n  ): this['settings'] {\n    const {\n      targets = defaults.targets,\n      inertAreaSize = defaults.inertAreaSize,\n      speed = defaults.speed,\n      smoothStop = defaults.smoothStop,\n      getPosition = defaults.getPosition,\n      getClientRect = defaults.getClientRect,\n      onStart = defaults.onStart,\n      onStop = defaults.onStop,\n    } = options || {};\n\n    return {\n      targets,\n      inertAreaSize,\n      speed,\n      smoothStop,\n      getPosition,\n      getClientRect,\n      onStart,\n      onStop,\n    };\n  }\n\n  updateSettings(options: Partial<this['settings']> = {}) {\n    (this as Writeable<this>).settings = this._parseSettings(options, this.settings);\n  }\n}\n\nexport function autoScrollPlugin<\n  S extends Sensor[],\n  E extends S[number]['events'],\n  P extends DraggablePluginMap,\n>(options?: DraggableAutoScrollOptions<S, E>) {\n  return (draggable: Draggable<S, E, P>) => {\n    const p = new DraggableAutoScroll(draggable, options);\n    const d = draggable as typeof draggable & {\n      plugins: { [p.name]: typeof p };\n    };\n    d.plugins[p.name] = p;\n    return d;\n  };\n}\n","import { Point, Rect } from '../types.js';\n\nimport { Pool } from '../pool.js';\n\nimport { ticker, tickerPhases } from '../singletons/ticker.js';\n\nimport { getDistance } from '../utils/get-distance.js';\n\nimport { getIntersectionScore } from '../utils/get-intersection-score.js';\n\nimport { getRect } from '../utils/get-rect.js';\n\nimport { getScrollElement } from '../utils/get-scroll-element.js';\n\nimport { getScrollLeft } from '../utils/get-scroll-left.js';\n\nimport { getScrollLeftMax } from '../utils/get-scroll-left-max.js';\n\nimport { getScrollTop } from '../utils/get-scroll-top.js';\n\nimport { getScrollTopMax } from '../utils/get-scroll-top-max.js';\n\nimport { isIntersecting } from '../utils/is-intersecting.js';\n\n//\n// CONSTANTS\n//\n\nconst TEMP_RECT: Rect = {\n  width: 0,\n  height: 0,\n  x: 0,\n  y: 0,\n};\n\nconst DEFAULT_THRESHOLD = 50;\n\nconst SPEED_DATA: AutoScrollSpeedData = {\n  direction: 'none',\n  threshold: 0,\n  distance: 0,\n  value: 0,\n  maxValue: 0,\n  duration: 0,\n  speed: 0,\n  deltaTime: 0,\n  isEnding: false,\n};\n\nexport const AUTO_SCROLL_AXIS = {\n  x: 1,\n  y: 2,\n} as const;\n\nexport const AUTO_SCROLL_AXIS_DIRECTION = {\n  forward: 4,\n  reverse: 8,\n} as const;\n\nconst AUTO_SCROLL_DIRECTION_X = {\n  none: 0,\n  left: (AUTO_SCROLL_AXIS.x | AUTO_SCROLL_AXIS_DIRECTION.reverse) as 9,\n  right: (AUTO_SCROLL_AXIS.x | AUTO_SCROLL_AXIS_DIRECTION.forward) as 5,\n} as const;\n\nconst AUTO_SCROLL_DIRECTION_Y = {\n  none: 0,\n  up: (AUTO_SCROLL_AXIS.y | AUTO_SCROLL_AXIS_DIRECTION.reverse) as 10,\n  down: (AUTO_SCROLL_AXIS.y | AUTO_SCROLL_AXIS_DIRECTION.forward) as 6,\n} as const;\n\nexport const AUTO_SCROLL_DIRECTION = {\n  ...AUTO_SCROLL_DIRECTION_X,\n  ...AUTO_SCROLL_DIRECTION_Y,\n} as const;\n\nfunction getDirectionAsString(direction: number) {\n  switch (direction) {\n    case AUTO_SCROLL_DIRECTION_X.none:\n    case AUTO_SCROLL_DIRECTION_Y.none:\n      return 'none';\n    case AUTO_SCROLL_DIRECTION_X.left:\n      return 'left';\n    case AUTO_SCROLL_DIRECTION_X.right:\n      return 'right';\n    case AUTO_SCROLL_DIRECTION_Y.up:\n      return 'up';\n    case AUTO_SCROLL_DIRECTION_Y.down:\n      return 'down';\n    default:\n      throw new Error(`Unknown direction value: ${direction}`);\n  }\n}\n\nfunction getPaddedRect(rect: Rect, padding: AutoScrollTargetPadding, result: Rect) {\n  let { left = 0, right = 0, top = 0, bottom = 0 } = padding;\n\n  // Don't allow negative padding.\n  left = Math.max(0, left);\n  right = Math.max(0, right);\n  top = Math.max(0, top);\n  bottom = Math.max(0, bottom);\n\n  result.width = rect.width + left + right;\n  result.height = rect.height + top + bottom;\n  result.x = rect.x - left;\n  result.y = rect.y - top;\n\n  return result;\n}\n\nfunction isScrolledToMax(scrollValue: number, maxScrollValue: number) {\n  // In some scenarios the scrollValue and/or maxScrollValue can be a float\n  // with subpixel values which might cause some funky scenarios where the\n  // element tries to scroll to the end but never actually reaches it. In such\n  // cases we want to do some rounding to detect that the element has actually\n  // reached the end of the scroll.\n  return Math.ceil(scrollValue) >= Math.floor(maxScrollValue);\n}\n\n//\n// PRIVATE TYPES\n//\n\ntype AutoScrollAxis = (typeof AUTO_SCROLL_AXIS)[keyof typeof AUTO_SCROLL_AXIS];\n\ntype AutoScrollDirectionX = (typeof AUTO_SCROLL_DIRECTION_X)[keyof typeof AUTO_SCROLL_DIRECTION_X];\n\ntype AutoScrollDirectionY = (typeof AUTO_SCROLL_DIRECTION_Y)[keyof typeof AUTO_SCROLL_DIRECTION_Y];\n\ntype AutoScrollDirection = (typeof AUTO_SCROLL_DIRECTION)[keyof typeof AUTO_SCROLL_DIRECTION];\n\ninterface AutoScrollSpeedData {\n  direction: ReturnType<typeof getDirectionAsString>;\n  threshold: number;\n  distance: number;\n  value: number;\n  maxValue: number;\n  duration: number;\n  speed: number;\n  deltaTime: number;\n  isEnding: boolean;\n}\n\ntype AutoScrollTargetPadding = {\n  left?: number;\n  right?: number;\n  top?: number;\n  bottom?: number;\n};\n\n//\n// PUBLIC TYPES\n//\n\nexport interface AutoScrollItem {\n  readonly targets: AutoScrollItemTarget[];\n  readonly clientRect: Rect;\n  readonly position: Point;\n  readonly inertAreaSize: number;\n  readonly smoothStop: boolean;\n  readonly speed: number | AutoScrollItemSpeedCallback;\n  readonly onStart?: AutoScrollItemEventCallback | null;\n  readonly onStop?: AutoScrollItemEventCallback | null;\n}\n\nexport interface AutoScrollSettings {\n  overlapCheckInterval: number;\n}\n\nexport interface AutoScrollOptions extends Partial<AutoScrollSettings> {}\n\nexport interface AutoScrollItemTarget {\n  element: Window | Element;\n  axis?: 'x' | 'y' | 'xy';\n  priority?: number;\n  threshold?: number;\n  padding?: AutoScrollTargetPadding;\n  scrollPadding?: AutoScrollTargetPadding;\n}\n\nexport type AutoScrollItemEventCallback = (\n  scrollElement: Window | Element,\n  scrollDirection: ReturnType<typeof getDirectionAsString>,\n) => void;\n\nexport type AutoScrollItemEffectCallback = () => void;\n\nexport type AutoScrollItemSpeedCallback = (\n  scrollElement: Window | Element,\n  scrollData: AutoScrollSpeedData,\n) => number;\n\n//\n// PRIVATE UTILS\n//\n\nfunction computeThreshold(idealThreshold: number, targetSize: number) {\n  return Math.min(targetSize / 2, idealThreshold);\n}\n\nfunction computeEdgeOffset(\n  threshold: number,\n  inertAreaSize: number,\n  itemSize: number,\n  targetSize: number,\n) {\n  return Math.max(0, itemSize + threshold * 2 + targetSize * inertAreaSize - targetSize) / 2;\n}\n\nclass AutoScrollItemData {\n  positionX: number;\n  positionY: number;\n  directionX: AutoScrollDirectionX;\n  directionY: AutoScrollDirectionY;\n  overlapCheckRequestTime: number;\n\n  constructor() {\n    this.positionX = 0;\n    this.positionY = 0;\n    this.directionX = AUTO_SCROLL_DIRECTION.none;\n    this.directionY = AUTO_SCROLL_DIRECTION.none;\n    this.overlapCheckRequestTime = 0;\n  }\n}\n\nclass AutoScrollAction {\n  element: Element | Window | null;\n  requestX: AutoScrollRequest | null;\n  requestY: AutoScrollRequest | null;\n  scrollLeft: number;\n  scrollTop: number;\n\n  constructor() {\n    this.element = null;\n    this.requestX = null;\n    this.requestY = null;\n    this.scrollLeft = 0;\n    this.scrollTop = 0;\n  }\n\n  reset() {\n    if (this.requestX) this.requestX.action = null;\n    if (this.requestY) this.requestY.action = null;\n    this.element = null;\n    this.requestX = null;\n    this.requestY = null;\n    this.scrollLeft = 0;\n    this.scrollTop = 0;\n  }\n\n  addRequest(request: AutoScrollRequest) {\n    if (AUTO_SCROLL_AXIS.x & request.direction) {\n      this.requestX && this.removeRequest(this.requestX);\n      this.requestX = request;\n    } else {\n      this.requestY && this.removeRequest(this.requestY);\n      this.requestY = request;\n    }\n    request.action = this;\n  }\n\n  removeRequest(request: AutoScrollRequest) {\n    if (this.requestX === request) {\n      this.requestX = null;\n      request.action = null;\n    } else if (this.requestY === request) {\n      this.requestY = null;\n      request.action = null;\n    }\n  }\n\n  computeScrollValues() {\n    if (!this.element) return;\n    this.scrollLeft = this.requestX ? this.requestX.value : getScrollLeft(this.element);\n    this.scrollTop = this.requestY ? this.requestY.value : getScrollTop(this.element);\n  }\n\n  scroll() {\n    if (!this.element) return;\n\n    if (this.element.scrollTo) {\n      this.element.scrollTo(this.scrollLeft, this.scrollTop);\n    } else {\n      (this.element as Element).scrollLeft = this.scrollLeft;\n      (this.element as Element).scrollTop = this.scrollTop;\n    }\n  }\n}\n\nclass AutoScrollRequest {\n  item: AutoScrollItem | null;\n  element: Element | Window | null;\n  isActive: boolean;\n  isEnding: boolean;\n  direction: AutoScrollDirection;\n  value: number;\n  maxValue: number;\n  threshold: number;\n  distance: number;\n  deltaTime: number;\n  speed: number;\n  duration: number;\n  action: AutoScrollAction | null;\n\n  constructor() {\n    this.item = null;\n    this.element = null;\n    this.isActive = false;\n    this.isEnding = false;\n    this.direction = 0;\n    this.value = NaN;\n    this.maxValue = 0;\n    this.threshold = 0;\n    this.distance = 0;\n    this.deltaTime = 0;\n    this.speed = 0;\n    this.duration = 0;\n    this.action = null;\n  }\n\n  reset() {\n    if (this.isActive) this.onStop();\n    this.item = null;\n    this.element = null;\n    this.isActive = false;\n    this.isEnding = false;\n    this.direction = 0;\n    this.value = NaN;\n    this.maxValue = 0;\n    this.threshold = 0;\n    this.distance = 0;\n    this.deltaTime = 0;\n    this.speed = 0;\n    this.duration = 0;\n    this.action = null;\n  }\n\n  hasReachedEnd() {\n    return AUTO_SCROLL_AXIS_DIRECTION.forward & this.direction\n      ? isScrolledToMax(this.value, this.maxValue)\n      : this.value <= 0;\n  }\n\n  computeCurrentScrollValue() {\n    if (!this.element) return 0;\n\n    if (this.value !== this.value) {\n      return AUTO_SCROLL_AXIS.x & this.direction\n        ? getScrollLeft(this.element)\n        : getScrollTop(this.element);\n    }\n\n    return Math.max(0, Math.min(this.value, this.maxValue));\n  }\n\n  computeNextScrollValue() {\n    const delta = this.speed * (this.deltaTime / 1000);\n    const nextValue =\n      AUTO_SCROLL_AXIS_DIRECTION.forward & this.direction ? this.value + delta : this.value - delta;\n    return Math.max(0, Math.min(nextValue, this.maxValue));\n  }\n\n  computeSpeed() {\n    if (!this.item || !this.element) return 0;\n    const { speed } = this.item;\n    if (typeof speed === 'function') {\n      SPEED_DATA.direction = getDirectionAsString(this.direction);\n      SPEED_DATA.threshold = this.threshold;\n      SPEED_DATA.distance = this.distance;\n      SPEED_DATA.value = this.value;\n      SPEED_DATA.maxValue = this.maxValue;\n      SPEED_DATA.duration = this.duration;\n      SPEED_DATA.speed = this.speed;\n      SPEED_DATA.deltaTime = this.deltaTime;\n      SPEED_DATA.isEnding = this.isEnding;\n      return speed(this.element, SPEED_DATA);\n    } else {\n      return speed;\n    }\n  }\n\n  tick(deltaTime: number) {\n    if (!this.isActive) {\n      this.isActive = true;\n      this.onStart();\n    }\n    this.deltaTime = deltaTime;\n    this.value = this.computeCurrentScrollValue();\n    this.speed = this.computeSpeed();\n    this.value = this.computeNextScrollValue();\n    this.duration += deltaTime;\n    return this.value;\n  }\n\n  onStart() {\n    if (!this.item || !this.element) return;\n    const { onStart } = this.item;\n    if (typeof onStart === 'function') {\n      onStart(this.element, getDirectionAsString(this.direction));\n    }\n  }\n\n  onStop() {\n    if (!this.item || !this.element) return;\n    const { onStop } = this.item;\n    if (typeof onStop === 'function') {\n      onStop(this.element, getDirectionAsString(this.direction));\n    }\n  }\n}\n\n//\n// PUBLIC UTILS\n//\n\nexport function autoScrollSmoothSpeed(\n  // Pixels per second.\n  maxSpeed = 500,\n  // Time in seconds, how long it will take to accelerate from 0 to maxSpeed.\n  accelerationFactor = 0.5,\n  // Time in seconds, how long it will take to decelerate maxSpeed to 0.\n  decelerationFactor = 0.25,\n): AutoScrollItemSpeedCallback {\n  const acceleration = maxSpeed * (accelerationFactor > 0 ? 1 / accelerationFactor : Infinity);\n  const deceleration = maxSpeed * (decelerationFactor > 0 ? 1 / decelerationFactor : Infinity);\n  return function (_element, data) {\n    let targetSpeed = 0;\n    if (!data.isEnding) {\n      if (data.threshold > 0) {\n        const factor = data.threshold - Math.max(0, data.distance);\n        targetSpeed = (maxSpeed / data.threshold) * factor;\n      } else {\n        targetSpeed = maxSpeed;\n      }\n    }\n\n    const currentSpeed = data.speed;\n    if (currentSpeed === targetSpeed) return targetSpeed;\n\n    let nextSpeed = targetSpeed;\n    if (currentSpeed < targetSpeed) {\n      nextSpeed = currentSpeed + acceleration * (data.deltaTime / 1000);\n      return Math.min(targetSpeed, nextSpeed);\n    } else {\n      nextSpeed = currentSpeed - deceleration * (data.deltaTime / 1000);\n      return Math.max(targetSpeed, nextSpeed);\n    }\n  };\n}\n\n//\n// AUTOSCROLL MAIN CLASS\n//\n\nexport class AutoScroll {\n  readonly items: AutoScrollItem[];\n  readonly settings: AutoScrollSettings;\n  protected _isDestroyed: boolean;\n  protected _isTicking: boolean;\n  protected _tickTime: number;\n  protected _tickDeltaTime: number;\n  protected _itemData: Map<AutoScrollItem, AutoScrollItemData>;\n  protected _actions: AutoScrollAction[];\n  protected _requests: {\n    [AUTO_SCROLL_AXIS.x]: Map<AutoScrollItem, AutoScrollRequest>;\n    [AUTO_SCROLL_AXIS.y]: Map<AutoScrollItem, AutoScrollRequest>;\n  };\n  protected _requestPool: Pool<AutoScrollRequest>;\n  protected _actionPool: Pool<AutoScrollAction>;\n\n  constructor(options: AutoScrollOptions = {}) {\n    const { overlapCheckInterval = 150 } = options;\n\n    this.items = [];\n    this.settings = {\n      overlapCheckInterval,\n    };\n\n    this._actions = [];\n    this._isDestroyed = false;\n    this._isTicking = false;\n    this._tickTime = 0;\n    this._tickDeltaTime = 0;\n    this._requests = {\n      [AUTO_SCROLL_AXIS.x]: new Map(),\n      [AUTO_SCROLL_AXIS.y]: new Map(),\n    };\n    this._itemData = new Map();\n    this._requestPool = new Pool<AutoScrollRequest>(\n      () => new AutoScrollRequest(),\n      (request) => request.reset(),\n    );\n    this._actionPool = new Pool<AutoScrollAction>(\n      () => new AutoScrollAction(),\n      (action) => action.reset(),\n    );\n\n    this._frameRead = this._frameRead.bind(this);\n    this._frameWrite = this._frameWrite.bind(this);\n  }\n\n  protected _frameRead(time: number) {\n    if (this._isDestroyed) return;\n    if (time && this._tickTime) {\n      this._tickDeltaTime = time - this._tickTime;\n      this._tickTime = time;\n      this._updateItems();\n      this._updateRequests();\n      this._updateActions();\n    } else {\n      this._tickTime = time;\n      this._tickDeltaTime = 0;\n    }\n  }\n\n  protected _frameWrite() {\n    if (this._isDestroyed) return;\n    this._applyActions();\n  }\n\n  protected _startTicking() {\n    if (this._isTicking) return;\n    this._isTicking = true;\n    ticker.on(tickerPhases.read, this._frameRead, this._frameRead);\n    ticker.on(tickerPhases.write, this._frameWrite, this._frameWrite);\n  }\n\n  protected _stopTicking() {\n    if (!this._isTicking) return;\n    this._isTicking = false;\n    this._tickTime = 0;\n    this._tickDeltaTime = 0;\n    ticker.off(tickerPhases.read, this._frameRead);\n    ticker.off(tickerPhases.write, this._frameWrite);\n  }\n\n  protected _requestItemScroll(\n    item: AutoScrollItem,\n    axis: AutoScrollAxis,\n    element: Window | Element,\n    direction: AutoScrollDirection,\n    threshold: number,\n    distance: number,\n    maxValue: number,\n  ) {\n    const reqMap = this._requests[axis];\n    let request = reqMap.get(item);\n\n    if (request) {\n      if (request.element !== element || request.direction !== direction) {\n        request.reset();\n      }\n    } else {\n      request = this._requestPool.pick();\n      reqMap.set(item, request);\n    }\n\n    request.item = item;\n    request.element = element;\n    request.direction = direction;\n    request.threshold = threshold;\n    request.distance = distance;\n    request.maxValue = maxValue;\n  }\n\n  protected _cancelItemScroll(item: AutoScrollItem, axis: AutoScrollAxis) {\n    const reqMap = this._requests[axis];\n    const request = reqMap.get(item);\n    if (!request) return;\n\n    if (request.action) request.action.removeRequest(request);\n    this._requestPool.put(request);\n    reqMap.delete(item);\n  }\n\n  protected _checkItemOverlap(item: AutoScrollItem, checkX: boolean, checkY: boolean) {\n    const { inertAreaSize, targets, clientRect } = item;\n    if (!targets.length) {\n      checkX && this._cancelItemScroll(item, AUTO_SCROLL_AXIS.x);\n      checkY && this._cancelItemScroll(item, AUTO_SCROLL_AXIS.y);\n      return;\n    }\n\n    const itemData = this._itemData.get(item);\n    const moveDirectionX = itemData?.directionX;\n    const moveDirectionY = itemData?.directionY;\n    if (!moveDirectionX && !moveDirectionY) {\n      checkX && this._cancelItemScroll(item, AUTO_SCROLL_AXIS.x);\n      checkY && this._cancelItemScroll(item, AUTO_SCROLL_AXIS.y);\n      return;\n    }\n\n    let xElement: Window | Element | null = null;\n    let xPriority = -Infinity;\n    let xThreshold = 0;\n    let xScore = -Infinity;\n    let xDirection: AutoScrollDirectionX = AUTO_SCROLL_DIRECTION.none;\n    let xDistance = 0;\n    let xMaxScroll = 0;\n\n    let yElement: Window | Element | null = null;\n    let yPriority = -Infinity;\n    let yThreshold = 0;\n    let yScore = -Infinity;\n    let yDirection: AutoScrollDirectionY = AUTO_SCROLL_DIRECTION.none;\n    let yDistance = 0;\n    let yMaxScroll = 0;\n\n    let i = 0;\n    for (; i < targets.length; i++) {\n      const target = targets[i];\n      const targetThreshold =\n        typeof target.threshold === 'number' ? target.threshold : DEFAULT_THRESHOLD;\n      const testAxisX = !!(checkX && moveDirectionX && target.axis !== 'y');\n      const testAxisY = !!(checkY && moveDirectionY && target.axis !== 'x');\n      const testPriority = target.priority || 0;\n\n      // Ignore this item if it's x-axis and y-axis priority is lower than\n      // the currently matching item's.\n      if ((!testAxisX || testPriority < xPriority) && (!testAxisY || testPriority < yPriority)) {\n        continue;\n      }\n\n      const testElement = getScrollElement(target.element || target);\n      const testMaxScrollX = testAxisX ? getScrollLeftMax(testElement) : -1;\n      const testMaxScrollY = testAxisY ? getScrollTopMax(testElement) : -1;\n\n      // Ignore this item if there is no possibility to scroll.\n      if (testMaxScrollX <= 0 && testMaxScrollY <= 0) continue;\n\n      const testRect = getRect([testElement, 'padding'], window);\n      let testScore = getIntersectionScore(clientRect, testRect) || -Infinity;\n\n      // If the item has no overlap with the target.\n      if (testScore === -Infinity) {\n        // If the target has virtual extra padding defined and it's padded\n        // version overlaps with item then let's compute the shortest distance\n        // between item and target and use that value (negated) as testScore.\n        if (\n          target.padding &&\n          isIntersecting(clientRect, getPaddedRect(testRect, target.padding, TEMP_RECT))\n        ) {\n          testScore = -(getDistance(clientRect, testRect) || 0);\n        }\n        // Otherwise let's ignore this target.\n        else {\n          continue;\n        }\n      }\n\n      // Test x-axis.\n      if (\n        testAxisX &&\n        testPriority >= xPriority &&\n        testMaxScrollX > 0 &&\n        (testPriority > xPriority || testScore > xScore)\n      ) {\n        let testDistance = 0;\n        let testDirection: AutoScrollDirectionX = AUTO_SCROLL_DIRECTION.none;\n        const testThreshold = computeThreshold(targetThreshold, testRect.width);\n        const testEdgeOffset = computeEdgeOffset(\n          testThreshold,\n          inertAreaSize,\n          clientRect.width,\n          testRect.width,\n        );\n\n        if (moveDirectionX === AUTO_SCROLL_DIRECTION.right) {\n          testDistance =\n            testRect.x + testRect.width + testEdgeOffset - (clientRect.x + clientRect.width);\n          if (\n            testDistance <= testThreshold &&\n            !isScrolledToMax(getScrollLeft(testElement), testMaxScrollX)\n          ) {\n            testDirection = AUTO_SCROLL_DIRECTION.right;\n          }\n        } else if (moveDirectionX === AUTO_SCROLL_DIRECTION.left) {\n          testDistance = clientRect.x - (testRect.x - testEdgeOffset);\n          if (testDistance <= testThreshold && getScrollLeft(testElement) > 0) {\n            testDirection = AUTO_SCROLL_DIRECTION.left;\n          }\n        }\n\n        if (testDirection) {\n          xElement = testElement;\n          xPriority = testPriority;\n          xThreshold = testThreshold;\n          xScore = testScore;\n          xDirection = testDirection;\n          xDistance = testDistance;\n          xMaxScroll = testMaxScrollX;\n        }\n      }\n\n      // Test y-axis.\n      if (\n        testAxisY &&\n        testPriority >= yPriority &&\n        testMaxScrollY > 0 &&\n        (testPriority > yPriority || testScore > yScore)\n      ) {\n        let testDistance = 0;\n        let testDirection: AutoScrollDirectionY = AUTO_SCROLL_DIRECTION_Y.none;\n        const testThreshold = computeThreshold(targetThreshold, testRect.height);\n        const testEdgeOffset = computeEdgeOffset(\n          testThreshold,\n          inertAreaSize,\n          clientRect.height,\n          testRect.height,\n        );\n\n        if (moveDirectionY === AUTO_SCROLL_DIRECTION.down) {\n          testDistance =\n            testRect.y + testRect.height + testEdgeOffset - (clientRect.y + clientRect.height);\n          if (\n            testDistance <= testThreshold &&\n            !isScrolledToMax(getScrollTop(testElement), testMaxScrollY)\n          ) {\n            testDirection = AUTO_SCROLL_DIRECTION.down;\n          }\n        } else if (moveDirectionY === AUTO_SCROLL_DIRECTION.up) {\n          testDistance = clientRect.y - (testRect.y - testEdgeOffset);\n          if (testDistance <= testThreshold && getScrollTop(testElement) > 0) {\n            testDirection = AUTO_SCROLL_DIRECTION.up;\n          }\n        }\n\n        if (testDirection) {\n          yElement = testElement;\n          yPriority = testPriority;\n          yThreshold = testThreshold;\n          yScore = testScore;\n          yDirection = testDirection;\n          yDistance = testDistance;\n          yMaxScroll = testMaxScrollY;\n        }\n      }\n    }\n\n    // Request or cancel x-axis scroll.\n    if (checkX) {\n      if (xElement && xDirection) {\n        this._requestItemScroll(\n          item,\n          AUTO_SCROLL_AXIS.x,\n          xElement,\n          xDirection,\n          xThreshold,\n          xDistance,\n          xMaxScroll,\n        );\n      } else {\n        this._cancelItemScroll(item, AUTO_SCROLL_AXIS.x);\n      }\n    }\n\n    // Request or cancel y-axis scroll.\n    if (checkY) {\n      if (yElement && yDirection) {\n        this._requestItemScroll(\n          item,\n          AUTO_SCROLL_AXIS.y,\n          yElement,\n          yDirection,\n          yThreshold,\n          yDistance,\n          yMaxScroll,\n        );\n      } else {\n        this._cancelItemScroll(item, AUTO_SCROLL_AXIS.y);\n      }\n    }\n  }\n\n  protected _updateScrollRequest(scrollRequest: AutoScrollRequest) {\n    const item = scrollRequest.item!;\n    const { inertAreaSize, smoothStop, targets, clientRect } = item;\n    let hasReachedEnd = null;\n\n    let i = 0;\n    for (; i < targets.length; i++) {\n      const target = targets[i];\n\n      // Make sure we have a matching element.\n      const testElement = getScrollElement(target.element || target);\n      if (testElement !== scrollRequest.element) continue;\n\n      // Make sure we have a matching axis.\n      const testIsAxisX = !!(AUTO_SCROLL_AXIS.x & scrollRequest.direction);\n      if (testIsAxisX) {\n        if (target.axis === 'y') continue;\n      } else {\n        if (target.axis === 'x') continue;\n      }\n\n      // Make sure the element is still scrollable.\n      const testMaxScroll = testIsAxisX\n        ? getScrollLeftMax(testElement)\n        : getScrollTopMax(testElement);\n      if (testMaxScroll <= 0) {\n        break;\n      }\n\n      const testRect = getRect([testElement, 'padding'], window);\n      const testScore = getIntersectionScore(clientRect, testRect) || -Infinity;\n\n      // If the item has no overlap with the target nor the padded target rect\n      // let's stop scrolling.\n      if (testScore === -Infinity) {\n        const padding = target.scrollPadding || target.padding;\n        if (!(padding && isIntersecting(clientRect, getPaddedRect(testRect, padding, TEMP_RECT)))) {\n          break;\n        }\n      }\n\n      // Compute threshold.\n      const targetThreshold =\n        typeof target.threshold === 'number' ? target.threshold : DEFAULT_THRESHOLD;\n      const testThreshold = computeThreshold(\n        targetThreshold,\n        testIsAxisX ? testRect.width : testRect.height,\n      );\n\n      // Compute edge offset.\n      const testEdgeOffset = computeEdgeOffset(\n        testThreshold,\n        inertAreaSize,\n        testIsAxisX ? clientRect.width : clientRect.height,\n        testIsAxisX ? testRect.width : testRect.height,\n      );\n\n      // Compute distance (based on current direction).\n      let testDistance = 0;\n      if (scrollRequest.direction === AUTO_SCROLL_DIRECTION.left) {\n        testDistance = clientRect.x - (testRect.x - testEdgeOffset);\n      } else if (scrollRequest.direction === AUTO_SCROLL_DIRECTION.right) {\n        testDistance =\n          testRect.x + testRect.width + testEdgeOffset - (clientRect.x + clientRect.width);\n      } else if (scrollRequest.direction === AUTO_SCROLL_DIRECTION.up) {\n        testDistance = clientRect.y - (testRect.y - testEdgeOffset);\n      } else {\n        testDistance =\n          testRect.y + testRect.height + testEdgeOffset - (clientRect.y + clientRect.height);\n      }\n\n      // Stop scrolling if threshold is not exceeded.\n      if (testDistance > testThreshold) {\n        break;\n      }\n\n      // Stop scrolling if we have reached max scroll value.\n      const testScroll = testIsAxisX ? getScrollLeft(testElement) : getScrollTop(testElement);\n      hasReachedEnd =\n        AUTO_SCROLL_AXIS_DIRECTION.forward & scrollRequest.direction\n          ? isScrolledToMax(testScroll, testMaxScroll)\n          : testScroll <= 0;\n      if (hasReachedEnd) break;\n\n      // Scrolling can continue, let's update the values.\n      scrollRequest.maxValue = testMaxScroll;\n      scrollRequest.threshold = testThreshold;\n      scrollRequest.distance = testDistance;\n      scrollRequest.isEnding = false;\n      return true;\n    }\n\n    // Before we end the request, let's see if we need to stop the scrolling\n    // smoothly or immediately.\n    if (smoothStop === true && scrollRequest.speed > 0) {\n      if (hasReachedEnd === null) hasReachedEnd = scrollRequest.hasReachedEnd();\n      scrollRequest.isEnding = hasReachedEnd ? false : true;\n    } else {\n      scrollRequest.isEnding = false;\n    }\n\n    return scrollRequest.isEnding;\n  }\n\n  protected _updateItems() {\n    for (let i = 0; i < this.items.length; i++) {\n      const item = this.items[i];\n      const itemData = this._itemData.get(item)!;\n      const { x, y } = item.position;\n      const prevX = itemData.positionX;\n      const prevY = itemData.positionY;\n\n      // If there is no change in position -> skip.\n      if (x === prevX && y === prevY) {\n        continue;\n      }\n\n      // Update direction x.\n      itemData.directionX =\n        x > prevX\n          ? AUTO_SCROLL_DIRECTION.right\n          : x < prevX\n            ? AUTO_SCROLL_DIRECTION.left\n            : itemData.directionX;\n\n      // Update direction y.\n      itemData.directionY =\n        y > prevY\n          ? AUTO_SCROLL_DIRECTION.down\n          : y < prevY\n            ? AUTO_SCROLL_DIRECTION.up\n            : itemData.directionY;\n\n      // Update positions.\n      itemData.positionX = x;\n      itemData.positionY = y;\n\n      // Request overlap check (if not already requested).\n      if (itemData.overlapCheckRequestTime === 0) {\n        itemData.overlapCheckRequestTime = this._tickTime;\n      }\n    }\n  }\n\n  protected _updateRequests() {\n    const items = this.items;\n    const requestsX = this._requests[AUTO_SCROLL_AXIS.x];\n    const requestsY = this._requests[AUTO_SCROLL_AXIS.y];\n\n    let i = 0;\n    for (; i < items.length; i++) {\n      const item = items[i];\n      const itemData = this._itemData.get(item)!;\n      const checkTime = itemData.overlapCheckRequestTime;\n      let needsCheck =\n        checkTime > 0 && this._tickTime - checkTime > this.settings.overlapCheckInterval;\n\n      let checkX = true;\n      const reqX = requestsX.get(item);\n      if (reqX && reqX.isActive) {\n        checkX = !this._updateScrollRequest(reqX);\n        if (checkX) {\n          needsCheck = true;\n          this._cancelItemScroll(item, AUTO_SCROLL_AXIS.x);\n        }\n      }\n\n      let checkY = true;\n      const reqY = requestsY.get(item);\n      if (reqY && reqY.isActive) {\n        checkY = !this._updateScrollRequest(reqY);\n        if (checkY) {\n          needsCheck = true;\n          this._cancelItemScroll(item, AUTO_SCROLL_AXIS.y);\n        }\n      }\n\n      if (needsCheck) {\n        itemData.overlapCheckRequestTime = 0;\n        this._checkItemOverlap(item, checkX, checkY);\n      }\n    }\n  }\n\n  protected _requestAction(request: AutoScrollRequest, axis: AutoScrollAxis) {\n    const isAxisX = axis === AUTO_SCROLL_AXIS.x;\n    let action: AutoScrollAction | null = null;\n\n    let i = 0;\n    for (; i < this._actions.length; i++) {\n      action = this._actions[i];\n\n      // If the action's request does not match the request's -> skip.\n      if (request.element !== action.element) {\n        action = null;\n        continue;\n      }\n\n      // If the request and action share the same element, but the request slot\n      // for the requested axis is already reserved let's ignore and cancel this\n      // request.\n      if (isAxisX ? action.requestX : action.requestY) {\n        this._cancelItemScroll(request.item!, axis);\n        return;\n      }\n\n      // Seems like we have found our action, let's break the loop.\n      break;\n    }\n\n    if (!action) action = this._actionPool.pick();\n    action.element = request.element;\n    action.addRequest(request);\n\n    request.tick(this._tickDeltaTime);\n    this._actions.push(action);\n  }\n\n  protected _updateActions() {\n    let i = 0;\n\n    // Generate actions.\n    for (i = 0; i < this.items.length; i++) {\n      const item = this.items[i];\n      const reqX = this._requests[AUTO_SCROLL_AXIS.x].get(item);\n      const reqY = this._requests[AUTO_SCROLL_AXIS.y].get(item);\n      if (reqX) this._requestAction(reqX, AUTO_SCROLL_AXIS.x);\n      if (reqY) this._requestAction(reqY, AUTO_SCROLL_AXIS.y);\n    }\n\n    // Compute scroll values.\n    for (i = 0; i < this._actions.length; i++) {\n      this._actions[i].computeScrollValues();\n    }\n  }\n\n  protected _applyActions() {\n    // No actions -> no scrolling.\n    if (!this._actions.length) return;\n\n    // Scroll all the required elements.\n    let i = 0;\n    for (i = 0; i < this._actions.length; i++) {\n      this._actions[i].scroll();\n      this._actionPool.put(this._actions[i]);\n    }\n\n    // Reset actions.\n    this._actions.length = 0;\n  }\n\n  addItem(item: AutoScrollItem) {\n    if (this._isDestroyed || this._itemData.has(item)) return;\n\n    const { x, y } = item.position;\n    const itemData = new AutoScrollItemData();\n\n    itemData.positionX = x;\n    itemData.positionY = y;\n    itemData.directionX = AUTO_SCROLL_DIRECTION.none;\n    itemData.directionY = AUTO_SCROLL_DIRECTION.none;\n    itemData.overlapCheckRequestTime = this._tickTime;\n\n    this._itemData.set(item, itemData);\n    this.items.push(item);\n    if (!this._isTicking) this._startTicking();\n  }\n\n  removeItem(item: AutoScrollItem) {\n    if (this._isDestroyed) return;\n\n    const index = this.items.indexOf(item);\n    if (index === -1) return;\n\n    if (this._requests[AUTO_SCROLL_AXIS.x].get(item)) {\n      this._cancelItemScroll(item, AUTO_SCROLL_AXIS.x);\n      this._requests[AUTO_SCROLL_AXIS.x].delete(item);\n    }\n\n    if (this._requests[AUTO_SCROLL_AXIS.y].get(item)) {\n      this._cancelItemScroll(item, AUTO_SCROLL_AXIS.y);\n      this._requests[AUTO_SCROLL_AXIS.y].delete(item);\n    }\n\n    this._itemData.delete(item);\n    this.items.splice(index, 1);\n\n    if (this._isTicking && !this.items.length) {\n      this._stopTicking();\n    }\n  }\n\n  isDestroyed() {\n    return this._isDestroyed;\n  }\n\n  isItemScrollingX(item: AutoScrollItem) {\n    return !!this._requests[AUTO_SCROLL_AXIS.x].get(item)?.isActive;\n  }\n\n  isItemScrollingY(item: AutoScrollItem) {\n    return !!this._requests[AUTO_SCROLL_AXIS.y].get(item)?.isActive;\n  }\n\n  isItemScrolling(item: AutoScrollItem) {\n    return this.isItemScrollingX(item) || this.isItemScrollingY(item);\n  }\n\n  updateSettings(options: AutoScrollOptions = {}) {\n    const { overlapCheckInterval = this.settings.overlapCheckInterval } = options;\n    this.settings.overlapCheckInterval = overlapCheckInterval;\n  }\n\n  destroy() {\n    if (this._isDestroyed) return;\n\n    const items = this.items.slice(0);\n    let i = 0;\n    for (; i < items.length; i++) {\n      this.removeItem(items[i]);\n    }\n\n    this._actions.length = 0;\n    this._requestPool.reset();\n    this._actionPool.reset();\n\n    this._isDestroyed = true;\n  }\n}\n","export class Pool<T> {\n  protected _data: T[];\n  protected _createObject: () => T;\n  protected _onPut: ((object: T) => void) | undefined;\n\n  constructor(createObject: () => T, onPut?: (object: T) => void) {\n    this._data = [];\n    this._createObject = createObject;\n    this._onPut = onPut;\n  }\n\n  pick() {\n    return this._data.length ? (this._data.pop() as T) : this._createObject();\n  }\n\n  put(object: T) {\n    if (this._data.indexOf(object) === -1) {\n      this._onPut && this._onPut(object);\n      this._data.push(object);\n    }\n  }\n\n  reset() {\n    this._data.length = 0;\n  }\n}\n","import { getDistance as _getDistance } from 'mezr';\n\nimport { createFullRect } from './create-full-rect.js';\n\nimport { Rect } from '../types.js';\n\nconst RECT_A = createFullRect();\nconst RECT_B = createFullRect();\n\n/**\n * Calculate distance between two rectangles.\n */\nexport function getDistance(a: Rect, b: Rect) {\n  return _getDistance(createFullRect(a, RECT_A), createFullRect(b, RECT_B));\n}\n","import { Rect, RectFull } from '../types.js';\n\nexport function createFullRect(\n  sourceRect?: Rect,\n  result: RectFull = { width: 0, height: 0, x: 0, y: 0, left: 0, top: 0, right: 0, bottom: 0 },\n) {\n  if (sourceRect) {\n    result.width = sourceRect.width;\n    result.height = sourceRect.height;\n    result.x = sourceRect.x;\n    result.y = sourceRect.y;\n    result.left = sourceRect.x;\n    result.top = sourceRect.y;\n    result.right = sourceRect.x + sourceRect.width;\n    result.bottom = sourceRect.y + sourceRect.height;\n  }\n  return result;\n}\n","import { getIntersectionArea } from './get-intersection-area.js';\n\nimport { Rect } from '../types.js';\n\n/**\n * Calculate how many percent the intersection area of two rectangles is from\n * the maximum potential intersection area between the rectangles.\n */\nexport function getIntersectionScore(a: Rect, b: Rect) {\n  const area = getIntersectionArea(a, b);\n  if (!area) return 0;\n  const maxArea = Math.min(a.width, b.width) * Math.min(a.height, b.height);\n  return (area / maxArea) * 100;\n}\n","import { getIntersection } from './get-intersection.js';\n\nimport { Rect } from '../types.js';\n\n/**\n * Calculate intersection area between two rectangle.\n */\nexport function getIntersectionArea(a: Rect, b: Rect) {\n  const intersection = getIntersection(a, b);\n  return intersection ? intersection.width * intersection.height : 0;\n}\n","import { Rect } from '../types.js';\n\n/**\n * Calculate intersection between two rectangles.\n */\nexport function getIntersection(\n  a: Rect,\n  b: Rect,\n  result: Rect = { width: 0, height: 0, x: 0, y: 0 },\n) {\n  const x1 = Math.max(a.x, b.x);\n  const x2 = Math.min(a.x + a.width, b.x + b.width);\n  if (x2 <= x1) return null;\n\n  const y1 = Math.max(a.y, b.y);\n  const y2 = Math.min(a.y + a.height, b.y + b.height);\n  if (y2 <= y1) return null;\n\n  result.x = x1;\n  result.y = y1;\n  result.width = x2 - x1;\n  result.height = y2 - y1;\n\n  return result;\n}\n","import { getRect as _getRect } from 'mezr';\n\nimport { Rect } from '../types.js';\n\n/**\n * A wrapper around `getRect` from `mezr` that returns a `Rect` object.\n */\nexport function getRect(...args: Parameters<typeof _getRect>): Rect {\n  const { width, height, left: x, top: y } = _getRect(...args);\n  return { width, height, x, y };\n}\n","import { isWindow } from './is-window.js';\n\nexport function getScrollElement(element: Element | Window) {\n  if (isWindow(element) || element === document.documentElement || element === document.body) {\n    return window;\n  } else {\n    return element;\n  }\n}\n","/**\n * Check if the current value is a window.\n */\nexport function isWindow(value: any): value is Window {\n  return value instanceof Window;\n}\n","import { isWindow } from './is-window.js';\n\nexport function getScrollLeft(element: Element | Window) {\n  return isWindow(element) ? element.scrollX : element.scrollLeft;\n}\n","import { isWindow } from './is-window.js';\n\nexport function getScrollLeftMax(element: Element | Window) {\n  if (isWindow(element)) element = document.documentElement;\n  return element.scrollWidth - element.clientWidth;\n}\n","import { isWindow } from './is-window.js';\n\nexport function getScrollTop(element: Element | Window) {\n  return isWindow(element) ? element.scrollY : element.scrollTop;\n}\n","import { isWindow } from './is-window.js';\n\nexport function getScrollTopMax(element: Element | Window) {\n  if (isWindow(element)) element = document.documentElement;\n  return element.scrollHeight - element.clientHeight;\n}\n","import { Rect } from '../types.js';\n\n/**\n * Check if two rectangles intersect.\n */\nexport function isIntersecting(a: Rect, b: Rect) {\n  return !(\n    a.x + a.width <= b.x ||\n    b.x + b.width <= a.x ||\n    a.y + a.height <= b.y ||\n    b.y + b.height <= a.y\n  );\n}\n","import { AutoScroll } from '../auto-scroll/auto-scroll.js';\n\nexport const autoScroll = new AutoScroll();\n","import { Sensor } from '../sensors/sensor.js';\n\nimport { Draggable } from '../draggable/draggable.js';\n\nimport { PointerSensor, PointerSensorEvents } from '../sensors/pointer-sensor.js';\n\nimport { getScrollableAncestors } from './get-scrollable-ancestors.js';\n\nimport { isScrollable } from './is-scrollable.js';\n\nfunction getScrollables(element: Element) {\n  const scrollables: (Element | Window)[] = [];\n\n  if (isScrollable(element)) {\n    scrollables.push(element);\n  }\n\n  getScrollableAncestors(element, scrollables);\n\n  return scrollables;\n}\n\nexport function createPointerSensorStartPredicate<\n  S extends (Sensor | PointerSensor)[] = (Sensor | PointerSensor)[],\n  D extends Draggable<S> = Draggable<S>,\n>(\n  options: {\n    timeout?: number;\n    fallback?: D['settings']['startPredicate'];\n  } = {},\n) {\n  let dragAllowed: boolean | undefined = undefined;\n\n  let startTimeStamp: number = 0;\n\n  let targetElement: Element | null = null;\n\n  let timer: number | undefined = undefined;\n\n  const { timeout = 250, fallback = () => true } = options;\n\n  const onContextMenu = (e: Event) => e.preventDefault();\n\n  const onTouchMove = (e: TouchEvent) => {\n    if (!startTimeStamp) return;\n\n    if (dragAllowed) {\n      e.cancelable && e.preventDefault();\n      return;\n    }\n\n    if (dragAllowed === undefined) {\n      if (e.cancelable && e.timeStamp - startTimeStamp > timeout) {\n        dragAllowed = true;\n        e.preventDefault();\n      } else {\n        dragAllowed = false;\n      }\n    }\n  };\n\n  const pointerSensorStartPredicate: D['settings']['startPredicate'] = (data) => {\n    if (!(data.sensor instanceof PointerSensor)) {\n      return fallback(data);\n    }\n\n    const { draggable, sensor, event } = data;\n    const e = event as PointerSensorEvents['start'] | PointerSensorEvents['move'];\n\n    if (e.pointerType === 'touch') {\n      // On first event (touchstart/pointerdown) we need to store the drag start\n      // data and bind listeners for touchmove and contextmenu.\n      if (\n        e.type === 'start' &&\n        (e.srcEvent.type === 'pointerdown' || e.srcEvent.type === 'touchstart')\n      ) {\n        // Prevent potentially scrollable nodes from scrolling to make sure\n        // native scrolling does not interfere with dragging.\n        targetElement = e.target as Element | null;\n        const scrollables = targetElement ? getScrollables(targetElement) : [];\n        scrollables.forEach((scrollable) => {\n          scrollable.addEventListener('touchmove', onTouchMove as EventListener, {\n            passive: false,\n            capture: true,\n          });\n        });\n\n        const dragEndListener = () => {\n          if (!startTimeStamp) return;\n\n          // Unbind listeners.\n          draggable.off('end', dragEndListener);\n          draggable.sensors.forEach((sensor) => {\n            if (sensor instanceof PointerSensor) {\n              sensor.off('end', dragEndListener);\n            }\n          });\n          targetElement?.removeEventListener('contextmenu', onContextMenu);\n          scrollables.forEach((scrollable) => {\n            scrollable.removeEventListener('touchmove', onTouchMove as EventListener, {\n              capture: true,\n            });\n          });\n\n          // Reset state.\n          startTimeStamp = 0;\n          dragAllowed = undefined;\n          targetElement = null;\n          timer = void window.clearTimeout(timer);\n        };\n\n        // Set start state.\n        dragAllowed = undefined;\n        startTimeStamp = e.srcEvent.timeStamp;\n\n        // Prevent context menu popping up.\n        targetElement?.addEventListener('contextmenu', onContextMenu);\n\n        // Reset data on drag end.\n        draggable.on('end', dragEndListener);\n        draggable.sensors.forEach((sensor) => {\n          if (sensor instanceof PointerSensor) {\n            sensor.off('end', dragEndListener);\n          }\n        });\n\n        // If we have timeout defined, let's set a timer that force starts\n        // the drag process after the timeout.\n        // TODO: This will start drag sometimes when it's not actually possible\n        // to prevent the native scrolling on touch devices. We'd need a way\n        // to check if the first touchstart/touchmove is cancelable. Needs\n        // testing on real devices. The funky thing is that we seem to need to\n        // get one touchmove event to check if we can prevent native scrolling\n        // but that is kind of too late already.. let's see if we can detect\n        // that earlier somehow.\n        if (timeout > 0) {\n          timer = window.setTimeout(() => {\n            draggable.resolveStartPredicate(sensor);\n            dragAllowed = true;\n            timer = undefined;\n          }, timeout);\n        }\n      }\n\n      return dragAllowed;\n    }\n\n    // On mouse/pen let's allow starting drag immediately if mouse's left button\n    // is pressed down.\n    if (e.type === 'start' && !(e.srcEvent as MouseEvent | PointerEvent).button) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  return pointerSensorStartPredicate;\n}\n","import { isScrollable } from './is-scrollable.js';\nimport { isDocument } from './is-document.js';\n\n/**\n * Compute the element's scrollable ancestor elements.\n */\nexport function getScrollableAncestors(\n  element: Element | Document | null,\n  result: (Element | Window)[] = [],\n) {\n  let parent = element?.parentNode;\n\n  while (parent && !isDocument(parent)) {\n    if (parent instanceof Element) {\n      if (isScrollable(parent)) result.push(parent);\n      parent = parent.parentNode;\n    } else if (parent instanceof ShadowRoot) {\n      parent = parent.host;\n    } else {\n      parent = parent.parentNode;\n    }\n  }\n\n  // Always push window to the results (as last scrollable element).\n  result.push(window);\n\n  return result;\n}\n","import { getStyle } from './get-style.js';\n\nconst SCROLLABLE_OVERFLOWS = new Set(['auto', 'scroll', 'overlay']);\n\n/**\n * Check if element is scrollable.\n */\nexport function isScrollable(element: Element) {\n  const style = getStyle(element);\n  return !!(SCROLLABLE_OVERFLOWS.has(style.overflowY) || SCROLLABLE_OVERFLOWS.has(style.overflowX));\n}\n","/**\n * Check if the current value is a document.\n */\nexport function isDocument(value: any): value is Document {\n  return value instanceof Document;\n}\n","import { Sensor } from '../sensors/sensor.js';\n\nimport { DraggableDragItem } from 'draggable/draggable-drag-item.js';\n\nfunction round(value: number, multipleOf: number) {\n  return Math.round(value / multipleOf) * multipleOf;\n}\n\nfunction getAxisChange(gridSize: number, snapPosition: number, sensorPosition: number) {\n  let change = sensorPosition - snapPosition;\n  let changeAbs = Math.abs(change);\n  if (changeAbs >= gridSize) {\n    const overflow = changeAbs % gridSize;\n    return round(change > 0 ? change - overflow : change + overflow, gridSize);\n  }\n  return 0;\n}\n\nexport function createSnapModifier<S extends Sensor[], E extends S[number]['events']>(\n  gridWidth: number,\n  gridHeight: number,\n) {\n  return function snapModifier({\n    item,\n    event,\n    startEvent,\n  }: {\n    item: DraggableDragItem<S, E>;\n    event: E['start'] | E['move'];\n    startEvent: E['start'] | E['move'];\n  }) {\n    let { __snapX__ = startEvent.x, __snapY__ = startEvent.y } = item.data;\n\n    const changeX = getAxisChange(gridWidth, __snapX__, event.x);\n    const changeY = getAxisChange(gridHeight, __snapY__, event.y);\n\n    if (changeX) {\n      item.data.__snapX__ = __snapX__ + changeX;\n    }\n    if (changeY) {\n      item.data.__snapY__ = __snapY__ + changeY;\n    }\n\n    return {\n      x: changeX,\n      y: changeY,\n    };\n  };\n}\n"],"names":["$e792636b9b5c481d$export$61fde4a8bbe7f5d5","start","move","cancel","end","destroy","DragStartPhase","DraggableStartPredicateState","options","$e9cd0e353e15b4ae$var$DragStartPhase","$e9cd0e353e15b4ae$var$DraggableStartPredicateState","$3d96966d628715ed$export$242b5ede4c93f7ba","ADD","UPDATE","IGNORE","THROW","$3d96966d628715ed$export$4293555f241ae35a","constructor","n","dedupe","t","getId","e","Symbol","_events","Map","_getListeners","get","idMap","size","emitList","values","on","s","i","set","d","o","has","Error","delete","push","once","off","clear","emit","length","listenerCount","forEach","$597a58f01afe9fb7$export$2176a6ff266bf511","drag","isDestroyed","_emitter","_createDragData","data","x","y","_updateDragData","_resetDragData","_start","_move","_end","_cancel","type","listener","listenerId","$4f159119173b96ee$export$39c54bcc89dcee11","phases","r","_phases","_queue","tick","bind","_assertEmptyQueue","_fillQueue","_processQueue","count","a","c","$4f159119173b96ee$export$bf5a5397711dbf71","paused","onDemand","requestFrame","$4f159119173b96ee$export$789135d3cf084551","requestAnimationFrame","cancelAnimationFrame","performance","Date","now","setTimeout","clearTimeout","_paused","_onDemand","_requestFrame","_cancelFrame","_empty","_request","$c1fd6b62e08b3d47$export$ef9171fc2626","read","write","$c1fd6b62e08b3d47$export$e94d57566be028aa","$75c93c044629d154$export$2f0ad9ba2f0800d","_direction","_speed","_tick","time","deltaTime","tickEvent","speedFactor","deltaX","deltaY","$63344f554ee4dd3f$export$6e8069a9617a39e2","id","pointerId","changedTouches","identifier","$9ecda7333d28e490$export$e44ffb50cc242ec5","window","document","$9ecda7333d28e490$export$ffcf6b6ce241bd05","isPassiveEventsSupported","passiveOpts","Object","defineProperty","addEventListener","removeEventListener","$9ecda7333d28e490$export$4af9b1d833a619de","$9ecda7333d28e490$export$7728c852ca75bb6d","PointerEvent","$578e243b57046d15$export$4d6c83612522bb80","capture","passive","$8909cb6563132761$export$6475a94861c59472","sourceEvents","undefined","navigator","vendor","indexOf","userAgent","$4998740c882fb340$var$SOURCE_EVENTS","pointer","touch","mouse","$4998740c882fb340$export$b26af955418d6638","element","listenerOptions","startPredicate","button","_areWindowListenersBound","_startPredicate","_listenerOptions","_sourceEvents","_onStart","_onMove","_onCancel","_onEnd","_getTrackedPointerEventData","pointerEventData","dragData","pointerType","clientX","clientY","eventData","srcEvent","target","_bindWindowListeners","_resetDrag","_unbindWindowListeners","updateSettings","nextSourceEvents","nextListenerOptions","$5f12a12b1bebeb44$var$KEY_TYPES","$5f12a12b1bebeb44$var$getEarliestTimestamp","keys","timestamps","Infinity","result","key","timestamp","_e","sensor","activeElement","left","top","getBoundingClientRect","$0895e978c48e9df2$export$ee7258b8691956a3","cache","validation","value","isValid","invalidate","$128271867868f1db$export$12e4b40eac1bcb71","startEvent","isEnded","event","prevEvent","endEvent","items","_measureElements","_matrixCache","_clientOffsetCache","$45554ebda029bd05$var$STYLE_DECLARATION_CACHE","WeakMap","$45554ebda029bd05$export$3d2f074408bd1b82","getComputedStyle","C","deref","WeakRef","$70e6b31ea6202e28$export$af54264dae9065e6","$70e6b31ea6202e28$export$e44ffb50cc242ec5","$70e6b31ea6202e28$export$11fd24d838ebde87","content","padding","scrollbar","border","margin","$70e6b31ea6202e28$export$76e909bcfd8ba196","$70e6b31ea6202e28$export$d2ad2856e215d28e","Set","$70e6b31ea6202e28$export$cd414719242f618c","userAgentData","brands","some","brand","$ac4a87157cb8fded$export$fab73c3646bf1f5e","display","$19cb8cdbc5921691$export$e5ce114ae0e5f4e8","filter","backdropFilter","willChange","transform","perspective","contentVisibility","contain","f","$8d1ba90c23ec3360$export$d8a62a489b442872","HTMLHtmlElement","$1f38751365ebdabf$export$940d8225183e1404","ownerDocument","defaultView","position","skipDisplayNone","container","parentElement","documentElement","l","$6473c4721ef9a7f0$export$53137579a3174918","Math","sqrt","pow","$0dd5d633d9254ede$export$5a096129d439f843","Window","$88986006632f0ab8$export$62858bae88b53fd0","Document","$9a36d0396b9b09d4$var$SUBPIXEL_OFFSET","$9a36d0396b9b09d4$var$testStyleElement","$9a36d0396b9b09d4$var$testParentElement","$9a36d0396b9b09d4$var$testChildElement","$9a36d0396b9b09d4$export$5ad86f4734d24a64","height","width","parseFloat","Number","isNaN","isInteger","$9a36d0396b9b09d4$var$getSubpixelScrollbarSize","split","createElement","innerHTML","appendChild","style","cssText","body","removeChild","$2e59c48b8f000a71$export$3c49c185de0c2bfc","innerWidth","clientWidth","max","scrollWidth","marginLeft","marginRight","borderLeftWidth","borderRightWidth","overflowY","round","paddingLeft","paddingRight","$646cecfa59ec4923$export$c08559766941f856","innerHeight","clientHeight","scrollHeight","marginTop","marginBottom","borderTopWidth","borderBottomWidth","overflowX","paddingTop","paddingBottom","$4de8edd731addea8$export$ff047630cae37d8e","$faeeed2de97ac6f7$export$9f1480883798e819","scrollX","scrollY","$4fec7741c67a29fc$export$4b834cebd9e5cebe","g","Array","isArray","right","bottom","$4effe6f7501c7f59$export$243d7fadef466e38","$0c69ffc8ab90052a$var$STYLE_DECLARATION_CACHE","$0c69ffc8ab90052a$export$3d2f074408bd1b82","styleDeclaration","$4131ae5fcb5e2d41$export$ee9ce4f6079fba39","$e38b00c029207e64$export$aff838a5553f2a92","$5b850440d58ca286$var$OFFSET_A","$5b850440d58ca286$var$OFFSET_B","$3b22a72fa25b3514$export$808822009ec670b1","transformOrigin","originX","originY","originZ","z","$dac91faf2d28787e$export$5e2c7a53f84076f2","m","setMatrixValue","$13dbe18eb44f2213$var$MATRIX","DOMMatrix","$6985a94cfe75e842$export$b87fb2dc7f11ca52","draggable","isConnected","clientRect","elementTransformOrigin","elementTransformMatrix","frozenProps","unfrozenProps","containerOffset","startOffset","_moveDiff","_alignDiff","elementContainer","dragContainer","settings","elementOffsetContainer","dragOffsetContainer","_computeContainerMatrices","updateContainerOffset","getStartPosition","item","getFrozenProps","props","prop","hasOwnProperty","matrices","matrix","inverseMatrix","el","currentElement","isIdentity","preMultiplySelf","toString","invertSelf","getContainerMatrix","getDragContainerMatrix","force","dragOffset","elementOffset","map","offsetContainer","offset","HTMLElement","m11","m12","m13","m14","m21","m22","m23","m24","m31","m32","m33","m34","m43","m44","measureElement","isMeasureElement","styles","important","setProperty","assign","transition","animation","inset","opacity","classList","add","append","m41","m42","elemA","elemB","offsetA","offsetB","updateSize","dimensions","$71d766ad3004a578$export$33e13bbfe889ab45","innerContainer","focusedElement","containsFocus","contains","focus","preventScroll","$73b931158359019b$export$a3992db8dd0fd9e6","decimals","multiplier","EPSILON","$e9cd0e353e15b4ae$var$SCROLL_LISTENER_OPTIONS","$e9cd0e353e15b4ae$var$POSITION_CHANGE","$e9cd0e353e15b4ae$var$DOM_MATRIX","$e9cd0e353e15b4ae$var$TEMP_MATRIX","$e9cd0e353e15b4ae$export$7ce0cd3869d5dcd9","getElements","releaseElements","setPosition","phase","isEndPhase","containerMatrix","inverseContainerMatrix","_dragContainerMatrix","inverseDragContainerMatrix","oX","oY","oZ","needsOriginOffset","tX","tY","translateSelf","multiplySelf","getPositionChange","$f045deb6d07519b3$export$14963ee5c8637e11","createObject","onPut","_data","_createObject","_onPut","pick","pop","put","object","reset","$1190f1d8a15545c9$export$3a8bd5429d724075","sourceRect","$b2dcf2463b3f9899$var$RECT_A","$b2dcf2463b3f9899$var$RECT_B","$6551604847fd2088$export$25b3e1e24e1ba229","b","area","intersection","x1","x2","min","y1","y2","$a91d17aaf97bddf1$export$4b834cebd9e5cebe","args","$f293b2d920f66b53$export$5a096129d439f843","$1d5c880696869e94$export$31d37ff78a483ce2","$8e79f2bef02bf7a3$export$1389d168952b34b5","scrollLeft","$6a48622145310dd6$export$c16047c7a398106d","$b796ea00009cfb0f$export$c4a223a8ba9e4ea5","scrollTop","$6ba3127b64f1801b$export$39d53b245a98193e","$dce4f2a3d0d356ef$export$8d3dd0be5eb9f11f","$292e4d9baf691c8b$var$TEMP_RECT","$292e4d9baf691c8b$var$SPEED_DATA","direction","threshold","distance","maxValue","duration","speed","isEnding","$292e4d9baf691c8b$export$5bbd74ab6c855dff","$292e4d9baf691c8b$export$3eeb7a7b68c92567","forward","reverse","$292e4d9baf691c8b$var$AUTO_SCROLL_DIRECTION_X","none","$292e4d9baf691c8b$var$AUTO_SCROLL_DIRECTION_Y","up","down","$292e4d9baf691c8b$export$c9fbd1f9176bc8ed","$292e4d9baf691c8b$var$getDirectionAsString","$292e4d9baf691c8b$var$getPaddedRect","rect","$292e4d9baf691c8b$var$isScrolledToMax","scrollValue","maxScrollValue","ceil","floor","$292e4d9baf691c8b$var$computeThreshold","idealThreshold","targetSize","$292e4d9baf691c8b$var$computeEdgeOffset","inertAreaSize","itemSize","$292e4d9baf691c8b$var$AutoScrollItemData","positionX","positionY","directionX","directionY","overlapCheckRequestTime","$292e4d9baf691c8b$var$AutoScrollAction","requestX","requestY","action","addRequest","request","removeRequest","computeScrollValues","scroll","scrollTo","$292e4d9baf691c8b$var$AutoScrollRequest","isActive","NaN","onStop","hasReachedEnd","computeCurrentScrollValue","computeNextScrollValue","delta","computeSpeed","onStart","$b7221aa668f0d343$export$d976747ecb966cea","overlapCheckInterval","_actions","_isDestroyed","_isTicking","_tickTime","_tickDeltaTime","_requests","_itemData","_requestPool","_actionPool","_frameRead","_frameWrite","_updateItems","_updateRequests","_updateActions","_applyActions","_startTicking","_stopTicking","_requestItemScroll","axis","reqMap","_cancelItemScroll","_checkItemOverlap","checkX","checkY","targets","itemData","moveDirectionX","moveDirectionY","xElement","xPriority","xThreshold","xScore","xDirection","xDistance","xMaxScroll","yElement","yPriority","yThreshold","yScore","yDirection","yDistance","yMaxScroll","targetThreshold","testAxisX","testAxisY","testPriority","priority","testElement","testMaxScrollX","testMaxScrollY","testRect","testScore","testDistance","testDirection","testThreshold","testEdgeOffset","_updateScrollRequest","scrollRequest","smoothStop","testIsAxisX","testMaxScroll","scrollPadding","testScroll","prevX","prevY","requestsX","requestsY","checkTime","needsCheck","reqX","reqY","_requestAction","isAxisX","addItem","removeItem","index","splice","isItemScrollingX","isItemScrollingY","isItemScrolling","slice","$6f9254451c60a12c$var$AUTOSCROLL_POSITION","$6f9254451c60a12c$var$AUTOSCROLL_CLIENT_RECT","$6f9254451c60a12c$var$getDefaultSettings","maxSpeed","accelerationFactor","decelerationFactor","acceleration","deceleration","_element","targetSpeed","factor","currentSpeed","getPosition","primaryItem","getClientRect","$6f9254451c60a12c$var$DraggableAutoScrollProxy","draggableAutoScroll","_draggableAutoScroll","_draggable","_position","_clientRect","_getSettings","$6f9254451c60a12c$export$5059276ad4233de3","name","version","_parseSettings","_autoScrollProxy","defaults","$a4c0af497ada6b6c$var$SCROLLABLE_OVERFLOWS","$a4c0af497ada6b6c$export$2bb74740c4e19def","$ba879827a05774f5$var$element","querySelector","$ba879827a05774f5$var$dragContainer","$ba879827a05774f5$var$pointerSensor","$ba879827a05774f5$var$keyboardSensor","cancelOnVisibilityChange","cancelOnBlur","startKeys","moveLeftKeys","moveRightKeys","moveUpKeys","moveDownKeys","cancelKeys","endKeys","_startKeys","_cancelKeys","_endKeys","_moveLeftKeys","_moveRightKeys","_moveUpKeys","_moveDownKeys","_moveKeys","_moveKeyTimestamps","_cancelOnBlur","_cancelOnVisibilityChange","_computeSpeed","_onKeyDown","_onKeyUp","_onTick","_internalCancel","_blurCancelHandler","queueMicrotask","_updateDirection","leftTime","rightTime","upTime","downTime","normFactor","startPosition","preventDefault","moveKeysMayNeedUpdate","keyType","nextMoveKeys","every","$ba879827a05774f5$var$draggable","sensors","plugins","_sensorData","_startPhase","_startId","_moveId","_alignId","_onScroll","_prepareStart","_applyStart","_prepareMove","_applyMove","_prepareAlign","_applyAlign","predicateState","predicateEvent","onMove","onEnd","_emit","sensorData","shouldStart","resolveStartPredicate","rejectStartPredicate","align","stop","elements","dragContainerMatrix","m1","m2","is2D","changeX","changeY","alignDiffX","alignDiffY","startX","startY","endX","endY","remove","instant","use","plugin","dragAllowed","timer","startTimeStamp","targetElement","timeout","fallback","onContextMenu","onTouchMove","cancelable","timeStamp","scrollables","$27dd69ed29855bb5$var$getScrollables","parent","parentNode","Element","ShadowRoot","host","scrollable","dragEndListener","p"],"version":3,"file":"index.46978fe1.js.map"}