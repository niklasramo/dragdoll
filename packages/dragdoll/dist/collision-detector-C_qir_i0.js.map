{"version":3,"file":"collision-detector-C_qir_i0.js","names":["collisionData: T | null"],"sources":["../src/utils/create-rect.ts","../src/utils/fast-object-pool.ts","../src/dnd-context/collision-detector.ts"],"sourcesContent":["import { Rect } from '../types.js';\n\nexport function createRect(sourceRect?: Rect, result: Rect = { width: 0, height: 0, x: 0, y: 0 }) {\n  if (sourceRect) {\n    result.width = sourceRect.width;\n    result.height = sourceRect.height;\n    result.x = sourceRect.x;\n    result.y = sourceRect.y;\n  }\n  return result;\n}\n","export class FastObjectPool<Item extends NonNullable<any>, ItemArgs extends any[]> {\n  protected _items: Item[];\n  protected _index: number;\n  protected _getItem: (item?: Item, ...args: ItemArgs) => Item;\n\n  constructor(getItem: (item?: Item, ...args: ItemArgs) => Item) {\n    this._items = [];\n    this._index = 0;\n    this._getItem = getItem;\n  }\n\n  get(...args: ItemArgs): Item {\n    if (this._index >= this._items.length) {\n      return (this._items[this._index++] = this._getItem(undefined, ...args));\n    }\n    return this._getItem(this._items[this._index++], ...args);\n  }\n\n  resetPointer(): void {\n    this._index = 0;\n  }\n\n  resetItems(maxLength = 0): void {\n    const newItemCount = Math.max(0, Math.min(maxLength, this._items.length));\n    this._index = Math.min(this._index, newItemCount);\n    this._items.length = newItemCount;\n  }\n}\n","import type { Draggable } from '../draggable/draggable.js';\nimport type { Droppable, DroppableId } from '../droppable/droppable.js';\nimport { Rect } from '../types.js';\nimport { createRect } from '../utils/create-rect.js';\nimport { FastObjectPool } from '../utils/fast-object-pool.js';\nimport { getIntersectionRect } from '../utils/get-intersection-rect.js';\nimport { getIntersectionScore } from '../utils/get-intersection-score.js';\nimport type { DndContext } from './dnd-context.js';\n\n// The max amount of collisions we keep in collision pool when we return it\n// to the pool cache.\nconst MAX_CACHED_COLLISIONS = 20;\n\n// We use a symbol to represent an empty droppable id.\nconst EMPTY_SYMBOL = Symbol();\n\n// TODO: Should we use droppable references instead of id? Using the reference\n// is a bit more work, but not much, as we'd need to clean up the old references\n// on each collision detection cycle. However, it would improve DX quite a bit\n// if we could provide the droppable reference instead of id.\nexport interface CollisionData {\n  droppableId: DroppableId;\n  droppableRect: Rect;\n  draggableRect: Rect;\n  intersectionRect: Rect;\n  intersectionScore: number;\n}\n\nexport class CollisionDetector<T extends CollisionData = CollisionData> {\n  protected _listenerId: symbol;\n  protected _dndContext: DndContext<T>;\n  protected _collisionDataPoolCache: FastObjectPool<T, []>[];\n  protected _collisionDataPoolMap: Map<Draggable<any>, FastObjectPool<T, []>>;\n\n  constructor(dndContext: DndContext<T>) {\n    this._listenerId = Symbol();\n    this._dndContext = dndContext;\n    this._collisionDataPoolCache = [];\n    this._collisionDataPoolMap = new Map();\n  }\n\n  protected _checkCollision(\n    draggable: Draggable<any>,\n    droppable: Droppable,\n    collisionData: T,\n  ): T | null {\n    const draggableRect = draggable.getClientRect();\n    const droppableRect = droppable.getClientRect();\n    if (!draggableRect) return null;\n\n    const intersectionRect = getIntersectionRect(\n      draggableRect,\n      droppableRect,\n      collisionData.intersectionRect,\n    );\n    if (intersectionRect === null) return null;\n\n    const intersectionScore = getIntersectionScore(draggableRect, droppableRect, intersectionRect);\n    if (intersectionScore <= 0) return null;\n\n    collisionData.droppableId = droppable.id;\n    createRect(droppableRect, collisionData.droppableRect);\n    createRect(draggableRect, collisionData.draggableRect);\n    collisionData.intersectionScore = intersectionScore;\n    return collisionData;\n  }\n\n  protected _sortCollisions(_draggable: Draggable<any>, collisions: T[]): T[] {\n    return collisions.sort((a, b) => {\n      const diff = b.intersectionScore - a.intersectionScore;\n      if (diff !== 0) return diff;\n\n      return (\n        a.droppableRect.width * a.droppableRect.height -\n        b.droppableRect.width * b.droppableRect.height\n      );\n    });\n  }\n\n  protected _createCollisionData(): T {\n    return {\n      droppableId: EMPTY_SYMBOL,\n      droppableRect: createRect(),\n      draggableRect: createRect(),\n      intersectionRect: createRect(),\n      intersectionScore: 0,\n    } as T;\n  }\n\n  getCollisionDataPool(draggable: Draggable<any>): FastObjectPool<T, []> {\n    let pool = this._collisionDataPoolMap.get(draggable);\n    if (!pool) {\n      pool =\n        this._collisionDataPoolCache.pop() ||\n        new FastObjectPool((item) => {\n          return item || this._createCollisionData();\n        });\n      this._collisionDataPoolMap.set(draggable, pool);\n    }\n    return pool;\n  }\n\n  removeCollisionDataPool(draggable: Draggable<any>) {\n    const pool = this._collisionDataPoolMap.get(draggable);\n    if (pool) {\n      pool.resetItems(MAX_CACHED_COLLISIONS);\n      pool.resetPointer();\n      this._collisionDataPoolCache.push(pool);\n      this._collisionDataPoolMap.delete(draggable);\n    }\n  }\n\n  detectCollisions(\n    draggable: Draggable<any>,\n    targets: Map<DroppableId, Droppable>,\n    collisions: T[],\n  ) {\n    // Reset the collisions array and colliding droppables set.\n    collisions.length = 0;\n\n    // If we don't have any targets, we can bail early.\n    if (!targets.size) {\n      return;\n    }\n\n    // Get or create the collision data pool for the draggable.\n    const collisionDataPool = this.getCollisionDataPool(draggable);\n\n    // Detect collisions between the draggable and all targets.\n    let collisionData: T | null = null;\n    const droppables = targets.values();\n    for (const droppable of droppables) {\n      collisionData = collisionData || collisionDataPool.get();\n      if (this._checkCollision(draggable, droppable, collisionData)) {\n        collisions.push(collisionData);\n        collisionData = null;\n      }\n    }\n\n    // Sort the collisions.\n    if (collisions.length > 1) {\n      this._sortCollisions(draggable, collisions);\n    }\n\n    // Reset collision data pool pointer.\n    collisionDataPool.resetPointer();\n  }\n\n  destroy() {\n    this._collisionDataPoolMap.forEach((pool) => {\n      pool.resetItems();\n    });\n  }\n}\n"],"mappings":"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"}