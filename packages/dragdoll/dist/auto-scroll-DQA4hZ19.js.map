{"version":3,"file":"auto-scroll-DQA4hZ19.js","names":["getDistance","_getDistance","TEMP_RECT: Rect","SPEED_DATA: AutoScrollSpeedData","xElement: Window | Element | null","xDirection: AutoScrollDirectionX","yElement: Window | Element | null","yDirection: AutoScrollDirectionY","getDistance","testDirection: AutoScrollDirectionX","testDirection: AutoScrollDirectionY","action: AutoScrollAction | null"],"sources":["../src/utils/classic-object-pool.ts","../src/utils/get-distance.ts","../src/utils/is-window.ts","../src/utils/get-scroll-element.ts","../src/utils/get-scroll-left.ts","../src/utils/get-scroll-left-max.ts","../src/utils/get-scroll-top.ts","../src/utils/get-scroll-top-max.ts","../src/utils/is-intersecting.ts","../src/auto-scroll/auto-scroll.ts"],"sourcesContent":["export class ClassicObjectPool<Item extends NonNullable<any>, ItemArgs extends any[] = []> {\n  protected _batchSize: number;\n  protected _maxSize: number;\n  protected _minSize: number;\n  protected _shrinkThreshold: number;\n  protected _data: Item[];\n  protected _index: number;\n  protected _getItem: (item?: Item, ...args: ItemArgs) => Item;\n  protected _onRelease: ((item: Item) => void) | undefined;\n\n  constructor(\n    getItem: (item?: Item, ...args: ItemArgs) => Item,\n    {\n      batchSize = 100,\n      minBatchCount = 0,\n      maxBatchCount = Number.MAX_SAFE_INTEGER,\n      initialBatchCount = 0,\n      shrinkThreshold = 2,\n      onRelease,\n    }: {\n      batchSize?: number;\n      minBatchCount?: number;\n      maxBatchCount?: number;\n      initialBatchCount?: number;\n      shrinkThreshold?: number;\n      onRelease?: (object: Item) => void;\n    } = {},\n  ) {\n    this._batchSize = Math.floor(Math.max(batchSize, 1));\n    this._minSize = Math.floor(Math.max(minBatchCount, 0)) * this._batchSize;\n    this._maxSize = Math.floor(\n      Math.min(Math.max(maxBatchCount * this._batchSize, this._batchSize), Number.MAX_SAFE_INTEGER),\n    );\n    this._shrinkThreshold = Math.floor(Math.max(shrinkThreshold, 1) * this._batchSize);\n    this._data = new Array(\n      Math.floor(Math.max(Math.max(initialBatchCount, minBatchCount) * this._batchSize, 0)),\n    );\n    this._index = 0;\n    this._getItem = getItem;\n    this._onRelease = onRelease;\n  }\n\n  get(...args: ItemArgs): Item {\n    // Return existing object from the pool, if available.\n    if (this._index > 0) {\n      return this._getItem(this._data[--this._index], ...args);\n    }\n\n    // Check if we need to grow the array because we're out of objects. Grow by\n    // batchSize (capped at maxSize).\n    if (this._index === 0) {\n      const currentCapacity = this._data.length;\n      const growBy = Math.min(this._batchSize, this._maxSize - currentCapacity);\n      if (growBy > 0) {\n        this._data.length = currentCapacity + growBy;\n      }\n    }\n\n    // Create a new object when pool is empty.\n    return this._getItem(undefined, ...args);\n  }\n\n  release(object: Item): void {\n    // Only add to pool if below max size.\n    if (this._index < this._maxSize) {\n      if (this._onRelease) {\n        this._onRelease(object);\n      }\n\n      // Store at current index, then increment.\n      this._data[this._index++] = object;\n\n      // Check if we should shrink after adding object.\n      if (this._index >= this._shrinkThreshold) {\n        // Only shrink if it wouldn't bring us below the minimum capacity\n        const newCapacity = this._data.length - this._batchSize;\n        if (newCapacity >= this._minSize) {\n          this._data.length = newCapacity;\n          this._index -= this._batchSize;\n        }\n      }\n    }\n  }\n\n  destroy(): void {\n    this._data.length = 0;\n    this._index = 0;\n  }\n}\n","import { getDistance as _getDistance } from 'mezr/getDistance';\nimport type { Rect } from '../types.js';\nimport { createFullRect } from './create-full-rect.js';\n\nconst RECT_A = createFullRect();\nconst RECT_B = createFullRect();\n\n/**\n * Calculate distance between two rectangles.\n */\nexport function getDistance(a: Rect, b: Rect) {\n  return _getDistance(createFullRect(a, RECT_A), createFullRect(b, RECT_B));\n}\n","/**\n * Check if the current value is a window.\n */\nexport function isWindow(value: any): value is Window {\n  return value instanceof Window;\n}\n","import { isWindow } from './is-window.js';\n\nexport function getScrollElement(element: Element | Window) {\n  if (isWindow(element) || element === document.documentElement || element === document.body) {\n    return window;\n  } else {\n    return element;\n  }\n}\n","import { isWindow } from './is-window.js';\n\nexport function getScrollLeft(element: Element | Window) {\n  return isWindow(element) ? element.scrollX : element.scrollLeft;\n}\n","import { isWindow } from './is-window.js';\n\nexport function getScrollLeftMax(element: Element | Window) {\n  if (isWindow(element)) element = document.documentElement;\n  return element.scrollWidth - element.clientWidth;\n}\n","import { isWindow } from './is-window.js';\n\nexport function getScrollTop(element: Element | Window) {\n  return isWindow(element) ? element.scrollY : element.scrollTop;\n}\n","import { isWindow } from './is-window.js';\n\nexport function getScrollTopMax(element: Element | Window) {\n  if (isWindow(element)) element = document.documentElement;\n  return element.scrollHeight - element.clientHeight;\n}\n","import type { Rect } from '../types.js';\n\n/**\n * Check if two rectangles intersect.\n */\nexport function isIntersecting(a: Rect, b: Rect) {\n  return !(\n    a.x + a.width <= b.x ||\n    b.x + b.width <= a.x ||\n    a.y + a.height <= b.y ||\n    b.y + b.height <= a.y\n  );\n}\n","import { ticker, tickerPhases } from '../singletons/ticker.js';\nimport type { Point, Rect } from '../types.js';\nimport { ClassicObjectPool } from '../utils/classic-object-pool.js';\nimport { getDistance } from '../utils/get-distance.js';\nimport { getIntersectionScore } from '../utils/get-intersection-score.js';\nimport { getRect } from '../utils/get-rect.js';\nimport { getScrollElement } from '../utils/get-scroll-element.js';\nimport { getScrollLeft } from '../utils/get-scroll-left.js';\nimport { getScrollLeftMax } from '../utils/get-scroll-left-max.js';\nimport { getScrollTop } from '../utils/get-scroll-top.js';\nimport { getScrollTopMax } from '../utils/get-scroll-top-max.js';\nimport { isIntersecting } from '../utils/is-intersecting.js';\n\n//\n// CONSTANTS\n//\n\nconst TEMP_RECT: Rect = {\n  width: 0,\n  height: 0,\n  x: 0,\n  y: 0,\n};\n\nconst DEFAULT_THRESHOLD = 50;\n\nconst SPEED_DATA: AutoScrollSpeedData = {\n  direction: 'none',\n  threshold: 0,\n  distance: 0,\n  value: 0,\n  maxValue: 0,\n  duration: 0,\n  speed: 0,\n  deltaTime: 0,\n  isEnding: false,\n};\n\nexport const AUTO_SCROLL_AXIS = {\n  x: 1,\n  y: 2,\n} as const;\n\nexport const AUTO_SCROLL_AXIS_DIRECTION = {\n  forward: 4,\n  reverse: 8,\n} as const;\n\nconst AUTO_SCROLL_DIRECTION_X = {\n  none: 0,\n  left: (AUTO_SCROLL_AXIS.x | AUTO_SCROLL_AXIS_DIRECTION.reverse) as 9,\n  right: (AUTO_SCROLL_AXIS.x | AUTO_SCROLL_AXIS_DIRECTION.forward) as 5,\n} as const;\n\nconst AUTO_SCROLL_DIRECTION_Y = {\n  none: 0,\n  up: (AUTO_SCROLL_AXIS.y | AUTO_SCROLL_AXIS_DIRECTION.reverse) as 10,\n  down: (AUTO_SCROLL_AXIS.y | AUTO_SCROLL_AXIS_DIRECTION.forward) as 6,\n} as const;\n\nexport const AUTO_SCROLL_DIRECTION = {\n  ...AUTO_SCROLL_DIRECTION_X,\n  ...AUTO_SCROLL_DIRECTION_Y,\n} as const;\n\nfunction getDirectionAsString(direction: number) {\n  switch (direction) {\n    case AUTO_SCROLL_DIRECTION_X.none:\n    case AUTO_SCROLL_DIRECTION_Y.none:\n      return 'none';\n    case AUTO_SCROLL_DIRECTION_X.left:\n      return 'left';\n    case AUTO_SCROLL_DIRECTION_X.right:\n      return 'right';\n    case AUTO_SCROLL_DIRECTION_Y.up:\n      return 'up';\n    case AUTO_SCROLL_DIRECTION_Y.down:\n      return 'down';\n    default:\n      throw new Error(`Unknown direction value: ${direction}`);\n  }\n}\n\nfunction getPaddedRect(rect: Rect, padding: AutoScrollTargetPadding, result: Rect) {\n  let { left = 0, right = 0, top = 0, bottom = 0 } = padding;\n\n  // Don't allow negative padding.\n  left = Math.max(0, left);\n  right = Math.max(0, right);\n  top = Math.max(0, top);\n  bottom = Math.max(0, bottom);\n\n  result.width = rect.width + left + right;\n  result.height = rect.height + top + bottom;\n  result.x = rect.x - left;\n  result.y = rect.y - top;\n\n  return result;\n}\n\nfunction isScrolledToMax(scrollValue: number, maxScrollValue: number) {\n  // In some scenarios the scrollValue and/or maxScrollValue can be a float\n  // with subpixel values which might cause some funky scenarios where the\n  // element tries to scroll to the end but never actually reaches it. In such\n  // cases we want to do some rounding to detect that the element has actually\n  // reached the end of the scroll.\n  return Math.ceil(scrollValue) >= Math.floor(maxScrollValue);\n}\n\n//\n// PRIVATE TYPES\n//\n\ntype AutoScrollAxis = (typeof AUTO_SCROLL_AXIS)[keyof typeof AUTO_SCROLL_AXIS];\n\ntype AutoScrollDirectionX = (typeof AUTO_SCROLL_DIRECTION_X)[keyof typeof AUTO_SCROLL_DIRECTION_X];\n\ntype AutoScrollDirectionY = (typeof AUTO_SCROLL_DIRECTION_Y)[keyof typeof AUTO_SCROLL_DIRECTION_Y];\n\ntype AutoScrollDirection = (typeof AUTO_SCROLL_DIRECTION)[keyof typeof AUTO_SCROLL_DIRECTION];\n\ninterface AutoScrollSpeedData {\n  direction: ReturnType<typeof getDirectionAsString>;\n  threshold: number;\n  distance: number;\n  value: number;\n  maxValue: number;\n  duration: number;\n  speed: number;\n  deltaTime: number;\n  isEnding: boolean;\n}\n\ntype AutoScrollTargetPadding = {\n  left?: number;\n  right?: number;\n  top?: number;\n  bottom?: number;\n};\n\n//\n// PUBLIC TYPES\n//\n\nexport interface AutoScrollItem {\n  readonly targets: AutoScrollItemTarget[];\n  readonly clientRect: Rect;\n  readonly position: Point;\n  readonly inertAreaSize: number;\n  readonly smoothStop: boolean;\n  readonly speed: number | AutoScrollItemSpeedCallback;\n  readonly onStart?: AutoScrollItemEventCallback | null;\n  readonly onStop?: AutoScrollItemEventCallback | null;\n}\n\nexport interface AutoScrollSettings {\n  overlapCheckInterval: number;\n}\n\nexport interface AutoScrollOptions extends Partial<AutoScrollSettings> {}\n\nexport interface AutoScrollItemTarget {\n  element: Window | Element;\n  axis?: 'x' | 'y' | 'xy';\n  priority?: number;\n  threshold?: number;\n  padding?: AutoScrollTargetPadding;\n  scrollPadding?: AutoScrollTargetPadding;\n}\n\nexport type AutoScrollItemEventCallback = (\n  scrollElement: Window | Element,\n  scrollDirection: ReturnType<typeof getDirectionAsString>,\n) => void;\n\nexport type AutoScrollItemEffectCallback = () => void;\n\nexport type AutoScrollItemSpeedCallback = (\n  scrollElement: Window | Element,\n  scrollData: AutoScrollSpeedData,\n) => number;\n\n//\n// PRIVATE UTILS\n//\n\nfunction computeThreshold(idealThreshold: number, targetSize: number) {\n  return Math.min(targetSize / 2, idealThreshold);\n}\n\nfunction computeEdgeOffset(\n  threshold: number,\n  inertAreaSize: number,\n  itemSize: number,\n  targetSize: number,\n) {\n  return Math.max(0, itemSize + threshold * 2 + targetSize * inertAreaSize - targetSize) / 2;\n}\n\nclass AutoScrollItemData {\n  positionX: number;\n  positionY: number;\n  directionX: AutoScrollDirectionX;\n  directionY: AutoScrollDirectionY;\n  overlapCheckRequestTime: number;\n\n  constructor() {\n    this.positionX = 0;\n    this.positionY = 0;\n    this.directionX = AUTO_SCROLL_DIRECTION.none;\n    this.directionY = AUTO_SCROLL_DIRECTION.none;\n    this.overlapCheckRequestTime = 0;\n  }\n}\n\nclass AutoScrollAction {\n  element: Element | Window | null;\n  requestX: AutoScrollRequest | null;\n  requestY: AutoScrollRequest | null;\n  scrollLeft: number;\n  scrollTop: number;\n\n  constructor() {\n    this.element = null;\n    this.requestX = null;\n    this.requestY = null;\n    this.scrollLeft = 0;\n    this.scrollTop = 0;\n  }\n\n  reset() {\n    if (this.requestX) this.requestX.action = null;\n    if (this.requestY) this.requestY.action = null;\n    this.element = null;\n    this.requestX = null;\n    this.requestY = null;\n    this.scrollLeft = 0;\n    this.scrollTop = 0;\n  }\n\n  addRequest(request: AutoScrollRequest) {\n    if (AUTO_SCROLL_AXIS.x & request.direction) {\n      this.requestX && this.removeRequest(this.requestX);\n      this.requestX = request;\n    } else {\n      this.requestY && this.removeRequest(this.requestY);\n      this.requestY = request;\n    }\n    request.action = this;\n  }\n\n  removeRequest(request: AutoScrollRequest) {\n    if (this.requestX === request) {\n      this.requestX = null;\n      request.action = null;\n    } else if (this.requestY === request) {\n      this.requestY = null;\n      request.action = null;\n    }\n  }\n\n  computeScrollValues() {\n    if (!this.element) return;\n    this.scrollLeft = this.requestX ? this.requestX.value : getScrollLeft(this.element);\n    this.scrollTop = this.requestY ? this.requestY.value : getScrollTop(this.element);\n  }\n\n  scroll() {\n    if (!this.element) return;\n\n    if (this.element.scrollTo) {\n      this.element.scrollTo(this.scrollLeft, this.scrollTop);\n    } else {\n      (this.element as Element).scrollLeft = this.scrollLeft;\n      (this.element as Element).scrollTop = this.scrollTop;\n    }\n  }\n}\n\nclass AutoScrollRequest {\n  item: AutoScrollItem | null;\n  element: Element | Window | null;\n  isActive: boolean;\n  isEnding: boolean;\n  direction: AutoScrollDirection;\n  value: number;\n  maxValue: number;\n  threshold: number;\n  distance: number;\n  deltaTime: number;\n  speed: number;\n  duration: number;\n  action: AutoScrollAction | null;\n\n  constructor() {\n    this.item = null;\n    this.element = null;\n    this.isActive = false;\n    this.isEnding = false;\n    this.direction = 0;\n    this.value = NaN;\n    this.maxValue = 0;\n    this.threshold = 0;\n    this.distance = 0;\n    this.deltaTime = 0;\n    this.speed = 0;\n    this.duration = 0;\n    this.action = null;\n  }\n\n  reset() {\n    if (this.isActive) this.onStop();\n    this.item = null;\n    this.element = null;\n    this.isActive = false;\n    this.isEnding = false;\n    this.direction = 0;\n    this.value = NaN;\n    this.maxValue = 0;\n    this.threshold = 0;\n    this.distance = 0;\n    this.deltaTime = 0;\n    this.speed = 0;\n    this.duration = 0;\n    this.action = null;\n  }\n\n  hasReachedEnd() {\n    return AUTO_SCROLL_AXIS_DIRECTION.forward & this.direction\n      ? isScrolledToMax(this.value, this.maxValue)\n      : this.value <= 0;\n  }\n\n  computeCurrentScrollValue() {\n    if (!this.element) return 0;\n\n    if (this.value !== this.value) {\n      return AUTO_SCROLL_AXIS.x & this.direction\n        ? getScrollLeft(this.element)\n        : getScrollTop(this.element);\n    }\n\n    return Math.max(0, Math.min(this.value, this.maxValue));\n  }\n\n  computeNextScrollValue() {\n    const delta = this.speed * (this.deltaTime / 1000);\n    const nextValue =\n      AUTO_SCROLL_AXIS_DIRECTION.forward & this.direction ? this.value + delta : this.value - delta;\n    return Math.max(0, Math.min(nextValue, this.maxValue));\n  }\n\n  computeSpeed() {\n    if (!this.item || !this.element) return 0;\n    const { speed } = this.item;\n    if (typeof speed === 'function') {\n      SPEED_DATA.direction = getDirectionAsString(this.direction);\n      SPEED_DATA.threshold = this.threshold;\n      SPEED_DATA.distance = this.distance;\n      SPEED_DATA.value = this.value;\n      SPEED_DATA.maxValue = this.maxValue;\n      SPEED_DATA.duration = this.duration;\n      SPEED_DATA.speed = this.speed;\n      SPEED_DATA.deltaTime = this.deltaTime;\n      SPEED_DATA.isEnding = this.isEnding;\n      return speed(this.element, SPEED_DATA);\n    } else {\n      return speed;\n    }\n  }\n\n  tick(deltaTime: number) {\n    if (!this.isActive) {\n      this.isActive = true;\n      this.onStart();\n    }\n    this.deltaTime = deltaTime;\n    this.value = this.computeCurrentScrollValue();\n    this.speed = this.computeSpeed();\n    this.value = this.computeNextScrollValue();\n    this.duration += deltaTime;\n    return this.value;\n  }\n\n  onStart() {\n    if (!this.item || !this.element) return;\n    const { onStart } = this.item;\n    if (typeof onStart === 'function') {\n      onStart(this.element, getDirectionAsString(this.direction));\n    }\n  }\n\n  onStop() {\n    if (!this.item || !this.element) return;\n    const { onStop } = this.item;\n    if (typeof onStop === 'function') {\n      onStop(this.element, getDirectionAsString(this.direction));\n    }\n  }\n}\n\n//\n// PUBLIC UTILS\n//\n\nexport function autoScrollSmoothSpeed(\n  // Pixels per second.\n  maxSpeed = 500,\n  // Time in seconds, how long it will take to accelerate from 0 to maxSpeed.\n  accelerationFactor = 0.5,\n  // Time in seconds, how long it will take to decelerate maxSpeed to 0.\n  decelerationFactor = 0.25,\n): AutoScrollItemSpeedCallback {\n  const acceleration = maxSpeed * (accelerationFactor > 0 ? 1 / accelerationFactor : Infinity);\n  const deceleration = maxSpeed * (decelerationFactor > 0 ? 1 / decelerationFactor : Infinity);\n  return function (_element, data) {\n    let targetSpeed = 0;\n    if (!data.isEnding) {\n      if (data.threshold > 0) {\n        const factor = data.threshold - Math.max(0, data.distance);\n        targetSpeed = (maxSpeed / data.threshold) * factor;\n      } else {\n        targetSpeed = maxSpeed;\n      }\n    }\n\n    const currentSpeed = data.speed;\n    if (currentSpeed === targetSpeed) return targetSpeed;\n\n    let nextSpeed = targetSpeed;\n    if (currentSpeed < targetSpeed) {\n      nextSpeed = currentSpeed + acceleration * (data.deltaTime / 1000);\n      return Math.min(targetSpeed, nextSpeed);\n    } else {\n      nextSpeed = currentSpeed - deceleration * (data.deltaTime / 1000);\n      return Math.max(targetSpeed, nextSpeed);\n    }\n  };\n}\n\n//\n// AUTOSCROLL MAIN CLASS\n//\n\nexport class AutoScroll {\n  readonly items: AutoScrollItem[];\n  readonly settings: AutoScrollSettings;\n  protected _isDestroyed: boolean;\n  protected _isTicking: boolean;\n  protected _tickTime: number;\n  protected _tickDeltaTime: number;\n  protected _itemData: Map<AutoScrollItem, AutoScrollItemData>;\n  protected _actions: AutoScrollAction[];\n  protected _requests: {\n    [AUTO_SCROLL_AXIS.x]: Map<AutoScrollItem, AutoScrollRequest>;\n    [AUTO_SCROLL_AXIS.y]: Map<AutoScrollItem, AutoScrollRequest>;\n  };\n  protected _requestPool: ClassicObjectPool<AutoScrollRequest>;\n  protected _actionPool: ClassicObjectPool<AutoScrollAction>;\n\n  constructor(options: AutoScrollOptions = {}) {\n    const { overlapCheckInterval = 150 } = options;\n\n    this.items = [];\n    this.settings = {\n      overlapCheckInterval,\n    };\n\n    this._actions = [];\n    this._isDestroyed = false;\n    this._isTicking = false;\n    this._tickTime = 0;\n    this._tickDeltaTime = 0;\n    this._requests = {\n      [AUTO_SCROLL_AXIS.x]: new Map(),\n      [AUTO_SCROLL_AXIS.y]: new Map(),\n    };\n    this._itemData = new Map();\n    this._requestPool = new ClassicObjectPool<AutoScrollRequest>(\n      (request) => request || new AutoScrollRequest(),\n      {\n        initialBatchCount: 1,\n        minBatchCount: 1,\n        onRelease: (request) => request.reset(),\n      },\n    );\n    this._actionPool = new ClassicObjectPool<AutoScrollAction>(\n      (action) => action || new AutoScrollAction(),\n      {\n        batchSize: 10,\n        initialBatchCount: 1,\n        minBatchCount: 1,\n        onRelease: (action) => action.reset(),\n      },\n    );\n\n    this._frameRead = this._frameRead.bind(this);\n    this._frameWrite = this._frameWrite.bind(this);\n  }\n\n  protected _frameRead(time: number) {\n    if (this._isDestroyed) return;\n    if (time && this._tickTime) {\n      this._tickDeltaTime = time - this._tickTime;\n      this._tickTime = time;\n      this._updateItems();\n      this._updateRequests();\n      this._updateActions();\n    } else {\n      this._tickTime = time;\n      this._tickDeltaTime = 0;\n    }\n  }\n\n  protected _frameWrite() {\n    if (this._isDestroyed) return;\n    this._applyActions();\n  }\n\n  protected _startTicking() {\n    if (this._isTicking) return;\n    this._isTicking = true;\n    ticker.on(tickerPhases.read, this._frameRead, this._frameRead);\n    ticker.on(tickerPhases.write, this._frameWrite, this._frameWrite);\n  }\n\n  protected _stopTicking() {\n    if (!this._isTicking) return;\n    this._isTicking = false;\n    this._tickTime = 0;\n    this._tickDeltaTime = 0;\n    ticker.off(tickerPhases.read, this._frameRead);\n    ticker.off(tickerPhases.write, this._frameWrite);\n  }\n\n  protected _requestItemScroll(\n    item: AutoScrollItem,\n    axis: AutoScrollAxis,\n    element: Window | Element,\n    direction: AutoScrollDirection,\n    threshold: number,\n    distance: number,\n    maxValue: number,\n  ) {\n    const reqMap = this._requests[axis];\n    let request = reqMap.get(item);\n\n    if (request) {\n      if (request.element !== element || request.direction !== direction) {\n        request.reset();\n      }\n    } else {\n      request = this._requestPool.get();\n      reqMap.set(item, request);\n    }\n\n    request.item = item;\n    request.element = element;\n    request.direction = direction;\n    request.threshold = threshold;\n    request.distance = distance;\n    request.maxValue = maxValue;\n  }\n\n  protected _cancelItemScroll(item: AutoScrollItem, axis: AutoScrollAxis) {\n    const reqMap = this._requests[axis];\n    const request = reqMap.get(item);\n    if (!request) return;\n\n    if (request.action) request.action.removeRequest(request);\n    this._requestPool.release(request);\n    reqMap.delete(item);\n  }\n\n  protected _checkItemOverlap(item: AutoScrollItem, checkX: boolean, checkY: boolean) {\n    const { inertAreaSize, targets, clientRect } = item;\n    if (!targets.length) {\n      checkX && this._cancelItemScroll(item, AUTO_SCROLL_AXIS.x);\n      checkY && this._cancelItemScroll(item, AUTO_SCROLL_AXIS.y);\n      return;\n    }\n\n    const itemData = this._itemData.get(item);\n    const moveDirectionX = itemData?.directionX;\n    const moveDirectionY = itemData?.directionY;\n    if (!moveDirectionX && !moveDirectionY) {\n      checkX && this._cancelItemScroll(item, AUTO_SCROLL_AXIS.x);\n      checkY && this._cancelItemScroll(item, AUTO_SCROLL_AXIS.y);\n      return;\n    }\n\n    let xElement: Window | Element | null = null;\n    let xPriority = -Infinity;\n    let xThreshold = 0;\n    let xScore = -Infinity;\n    let xDirection: AutoScrollDirectionX = AUTO_SCROLL_DIRECTION.none;\n    let xDistance = 0;\n    let xMaxScroll = 0;\n\n    let yElement: Window | Element | null = null;\n    let yPriority = -Infinity;\n    let yThreshold = 0;\n    let yScore = -Infinity;\n    let yDirection: AutoScrollDirectionY = AUTO_SCROLL_DIRECTION.none;\n    let yDistance = 0;\n    let yMaxScroll = 0;\n\n    let i = 0;\n    for (; i < targets.length; i++) {\n      const target = targets[i];\n      const targetThreshold =\n        typeof target.threshold === 'number' ? target.threshold : DEFAULT_THRESHOLD;\n      const testAxisX = !!(checkX && moveDirectionX && target.axis !== 'y');\n      const testAxisY = !!(checkY && moveDirectionY && target.axis !== 'x');\n      const testPriority = target.priority || 0;\n\n      // Ignore this item if it's x-axis and y-axis priority is lower than\n      // the currently matching item's.\n      if ((!testAxisX || testPriority < xPriority) && (!testAxisY || testPriority < yPriority)) {\n        continue;\n      }\n\n      const testElement = getScrollElement(target.element || target);\n      const testMaxScrollX = testAxisX ? getScrollLeftMax(testElement) : -1;\n      const testMaxScrollY = testAxisY ? getScrollTopMax(testElement) : -1;\n\n      // Ignore this item if there is no possibility to scroll.\n      if (testMaxScrollX <= 0 && testMaxScrollY <= 0) continue;\n\n      const testRect = getRect([testElement, 'padding'], window);\n      let testScore = getIntersectionScore(clientRect, testRect) || -Infinity;\n\n      // If the item has no overlap with the target.\n      if (testScore === -Infinity) {\n        // If the target has virtual extra padding defined and it's padded\n        // version overlaps with item then let's compute the shortest distance\n        // between item and target and use that value (negated) as testScore.\n        if (\n          target.padding &&\n          isIntersecting(clientRect, getPaddedRect(testRect, target.padding, TEMP_RECT))\n        ) {\n          testScore = -(getDistance(clientRect, testRect) || 0);\n        }\n        // Otherwise let's ignore this target.\n        else {\n          continue;\n        }\n      }\n\n      // Test x-axis.\n      if (\n        testAxisX &&\n        testPriority >= xPriority &&\n        testMaxScrollX > 0 &&\n        (testPriority > xPriority || testScore > xScore)\n      ) {\n        let testDistance = 0;\n        let testDirection: AutoScrollDirectionX = AUTO_SCROLL_DIRECTION.none;\n        const testThreshold = computeThreshold(targetThreshold, testRect.width);\n        const testEdgeOffset = computeEdgeOffset(\n          testThreshold,\n          inertAreaSize,\n          clientRect.width,\n          testRect.width,\n        );\n\n        if (moveDirectionX === AUTO_SCROLL_DIRECTION.right) {\n          testDistance =\n            testRect.x + testRect.width + testEdgeOffset - (clientRect.x + clientRect.width);\n          if (\n            testDistance <= testThreshold &&\n            !isScrolledToMax(getScrollLeft(testElement), testMaxScrollX)\n          ) {\n            testDirection = AUTO_SCROLL_DIRECTION.right;\n          }\n        } else if (moveDirectionX === AUTO_SCROLL_DIRECTION.left) {\n          testDistance = clientRect.x - (testRect.x - testEdgeOffset);\n          if (testDistance <= testThreshold && getScrollLeft(testElement) > 0) {\n            testDirection = AUTO_SCROLL_DIRECTION.left;\n          }\n        }\n\n        if (testDirection) {\n          xElement = testElement;\n          xPriority = testPriority;\n          xThreshold = testThreshold;\n          xScore = testScore;\n          xDirection = testDirection;\n          xDistance = testDistance;\n          xMaxScroll = testMaxScrollX;\n        }\n      }\n\n      // Test y-axis.\n      if (\n        testAxisY &&\n        testPriority >= yPriority &&\n        testMaxScrollY > 0 &&\n        (testPriority > yPriority || testScore > yScore)\n      ) {\n        let testDistance = 0;\n        let testDirection: AutoScrollDirectionY = AUTO_SCROLL_DIRECTION_Y.none;\n        const testThreshold = computeThreshold(targetThreshold, testRect.height);\n        const testEdgeOffset = computeEdgeOffset(\n          testThreshold,\n          inertAreaSize,\n          clientRect.height,\n          testRect.height,\n        );\n\n        if (moveDirectionY === AUTO_SCROLL_DIRECTION.down) {\n          testDistance =\n            testRect.y + testRect.height + testEdgeOffset - (clientRect.y + clientRect.height);\n          if (\n            testDistance <= testThreshold &&\n            !isScrolledToMax(getScrollTop(testElement), testMaxScrollY)\n          ) {\n            testDirection = AUTO_SCROLL_DIRECTION.down;\n          }\n        } else if (moveDirectionY === AUTO_SCROLL_DIRECTION.up) {\n          testDistance = clientRect.y - (testRect.y - testEdgeOffset);\n          if (testDistance <= testThreshold && getScrollTop(testElement) > 0) {\n            testDirection = AUTO_SCROLL_DIRECTION.up;\n          }\n        }\n\n        if (testDirection) {\n          yElement = testElement;\n          yPriority = testPriority;\n          yThreshold = testThreshold;\n          yScore = testScore;\n          yDirection = testDirection;\n          yDistance = testDistance;\n          yMaxScroll = testMaxScrollY;\n        }\n      }\n    }\n\n    // Request or cancel x-axis scroll.\n    if (checkX) {\n      if (xElement && xDirection) {\n        this._requestItemScroll(\n          item,\n          AUTO_SCROLL_AXIS.x,\n          xElement,\n          xDirection,\n          xThreshold,\n          xDistance,\n          xMaxScroll,\n        );\n      } else {\n        this._cancelItemScroll(item, AUTO_SCROLL_AXIS.x);\n      }\n    }\n\n    // Request or cancel y-axis scroll.\n    if (checkY) {\n      if (yElement && yDirection) {\n        this._requestItemScroll(\n          item,\n          AUTO_SCROLL_AXIS.y,\n          yElement,\n          yDirection,\n          yThreshold,\n          yDistance,\n          yMaxScroll,\n        );\n      } else {\n        this._cancelItemScroll(item, AUTO_SCROLL_AXIS.y);\n      }\n    }\n  }\n\n  protected _updateScrollRequest(scrollRequest: AutoScrollRequest) {\n    const item = scrollRequest.item!;\n    const { inertAreaSize, smoothStop, targets, clientRect } = item;\n    let hasReachedEnd = null;\n\n    let i = 0;\n    for (; i < targets.length; i++) {\n      const target = targets[i];\n\n      // Make sure we have a matching element.\n      const testElement = getScrollElement(target.element || target);\n      if (testElement !== scrollRequest.element) continue;\n\n      // Make sure we have a matching axis.\n      const testIsAxisX = !!(AUTO_SCROLL_AXIS.x & scrollRequest.direction);\n      if (testIsAxisX) {\n        if (target.axis === 'y') continue;\n      } else {\n        if (target.axis === 'x') continue;\n      }\n\n      // Make sure the element is still scrollable.\n      const testMaxScroll = testIsAxisX\n        ? getScrollLeftMax(testElement)\n        : getScrollTopMax(testElement);\n      if (testMaxScroll <= 0) {\n        break;\n      }\n\n      const testRect = getRect([testElement, 'padding'], window);\n      const testScore = getIntersectionScore(clientRect, testRect) || -Infinity;\n\n      // If the item has no overlap with the target nor the padded target rect\n      // let's stop scrolling.\n      if (testScore === -Infinity) {\n        const padding = target.scrollPadding || target.padding;\n        if (!(padding && isIntersecting(clientRect, getPaddedRect(testRect, padding, TEMP_RECT)))) {\n          break;\n        }\n      }\n\n      // Compute threshold.\n      const targetThreshold =\n        typeof target.threshold === 'number' ? target.threshold : DEFAULT_THRESHOLD;\n      const testThreshold = computeThreshold(\n        targetThreshold,\n        testIsAxisX ? testRect.width : testRect.height,\n      );\n\n      // Compute edge offset.\n      const testEdgeOffset = computeEdgeOffset(\n        testThreshold,\n        inertAreaSize,\n        testIsAxisX ? clientRect.width : clientRect.height,\n        testIsAxisX ? testRect.width : testRect.height,\n      );\n\n      // Compute distance (based on current direction).\n      let testDistance = 0;\n      if (scrollRequest.direction === AUTO_SCROLL_DIRECTION.left) {\n        testDistance = clientRect.x - (testRect.x - testEdgeOffset);\n      } else if (scrollRequest.direction === AUTO_SCROLL_DIRECTION.right) {\n        testDistance =\n          testRect.x + testRect.width + testEdgeOffset - (clientRect.x + clientRect.width);\n      } else if (scrollRequest.direction === AUTO_SCROLL_DIRECTION.up) {\n        testDistance = clientRect.y - (testRect.y - testEdgeOffset);\n      } else {\n        testDistance =\n          testRect.y + testRect.height + testEdgeOffset - (clientRect.y + clientRect.height);\n      }\n\n      // Stop scrolling if threshold is not exceeded.\n      if (testDistance > testThreshold) {\n        break;\n      }\n\n      // Stop scrolling if we have reached max scroll value.\n      const testScroll = testIsAxisX ? getScrollLeft(testElement) : getScrollTop(testElement);\n      hasReachedEnd =\n        AUTO_SCROLL_AXIS_DIRECTION.forward & scrollRequest.direction\n          ? isScrolledToMax(testScroll, testMaxScroll)\n          : testScroll <= 0;\n      if (hasReachedEnd) break;\n\n      // Scrolling can continue, let's update the values.\n      scrollRequest.maxValue = testMaxScroll;\n      scrollRequest.threshold = testThreshold;\n      scrollRequest.distance = testDistance;\n      scrollRequest.isEnding = false;\n      return true;\n    }\n\n    // Before we end the request, let's see if we need to stop the scrolling\n    // smoothly or immediately.\n    if (smoothStop === true && scrollRequest.speed > 0) {\n      if (hasReachedEnd === null) hasReachedEnd = scrollRequest.hasReachedEnd();\n      scrollRequest.isEnding = hasReachedEnd ? false : true;\n    } else {\n      scrollRequest.isEnding = false;\n    }\n\n    return scrollRequest.isEnding;\n  }\n\n  protected _updateItems() {\n    for (let i = 0; i < this.items.length; i++) {\n      const item = this.items[i];\n      const itemData = this._itemData.get(item)!;\n      const { x, y } = item.position;\n      const prevX = itemData.positionX;\n      const prevY = itemData.positionY;\n\n      // If there is no change in position -> skip.\n      if (x === prevX && y === prevY) {\n        continue;\n      }\n\n      // Update direction x.\n      itemData.directionX =\n        x > prevX\n          ? AUTO_SCROLL_DIRECTION.right\n          : x < prevX\n            ? AUTO_SCROLL_DIRECTION.left\n            : itemData.directionX;\n\n      // Update direction y.\n      itemData.directionY =\n        y > prevY\n          ? AUTO_SCROLL_DIRECTION.down\n          : y < prevY\n            ? AUTO_SCROLL_DIRECTION.up\n            : itemData.directionY;\n\n      // Update positions.\n      itemData.positionX = x;\n      itemData.positionY = y;\n\n      // Request overlap check (if not already requested).\n      if (itemData.overlapCheckRequestTime === 0) {\n        itemData.overlapCheckRequestTime = this._tickTime;\n      }\n    }\n  }\n\n  protected _updateRequests() {\n    const items = this.items;\n    const requestsX = this._requests[AUTO_SCROLL_AXIS.x];\n    const requestsY = this._requests[AUTO_SCROLL_AXIS.y];\n\n    let i = 0;\n    for (; i < items.length; i++) {\n      const item = items[i];\n      const itemData = this._itemData.get(item)!;\n      const checkTime = itemData.overlapCheckRequestTime;\n      let needsCheck =\n        checkTime > 0 && this._tickTime - checkTime > this.settings.overlapCheckInterval;\n\n      let checkX = true;\n      const reqX = requestsX.get(item);\n      if (reqX && reqX.isActive) {\n        checkX = !this._updateScrollRequest(reqX);\n        if (checkX) {\n          needsCheck = true;\n          this._cancelItemScroll(item, AUTO_SCROLL_AXIS.x);\n        }\n      }\n\n      let checkY = true;\n      const reqY = requestsY.get(item);\n      if (reqY && reqY.isActive) {\n        checkY = !this._updateScrollRequest(reqY);\n        if (checkY) {\n          needsCheck = true;\n          this._cancelItemScroll(item, AUTO_SCROLL_AXIS.y);\n        }\n      }\n\n      if (needsCheck) {\n        itemData.overlapCheckRequestTime = 0;\n        this._checkItemOverlap(item, checkX, checkY);\n      }\n    }\n  }\n\n  protected _requestAction(request: AutoScrollRequest, axis: AutoScrollAxis) {\n    const isAxisX = axis === AUTO_SCROLL_AXIS.x;\n    let action: AutoScrollAction | null = null;\n\n    let i = 0;\n    for (; i < this._actions.length; i++) {\n      action = this._actions[i];\n\n      // If the action's request does not match the request's -> skip.\n      if (request.element !== action.element) {\n        action = null;\n        continue;\n      }\n\n      // If the request and action share the same element, but the request slot\n      // for the requested axis is already reserved let's ignore and cancel this\n      // request.\n      if (isAxisX ? action.requestX : action.requestY) {\n        this._cancelItemScroll(request.item!, axis);\n        return;\n      }\n\n      // Seems like we have found our action, let's break the loop.\n      break;\n    }\n\n    if (!action) action = this._actionPool.get();\n    action.element = request.element;\n    action.addRequest(request);\n\n    request.tick(this._tickDeltaTime);\n    this._actions.push(action);\n  }\n\n  protected _updateActions() {\n    let i = 0;\n\n    // Generate actions.\n    for (i = 0; i < this.items.length; i++) {\n      const item = this.items[i];\n      const reqX = this._requests[AUTO_SCROLL_AXIS.x].get(item);\n      const reqY = this._requests[AUTO_SCROLL_AXIS.y].get(item);\n      if (reqX) this._requestAction(reqX, AUTO_SCROLL_AXIS.x);\n      if (reqY) this._requestAction(reqY, AUTO_SCROLL_AXIS.y);\n    }\n\n    // Compute scroll values.\n    for (i = 0; i < this._actions.length; i++) {\n      this._actions[i].computeScrollValues();\n    }\n  }\n\n  protected _applyActions() {\n    // No actions -> no scrolling.\n    if (!this._actions.length) return;\n\n    // Scroll all the required elements.\n    let i = 0;\n    for (i = 0; i < this._actions.length; i++) {\n      this._actions[i].scroll();\n      this._actionPool.release(this._actions[i]);\n    }\n\n    // Reset actions.\n    this._actions.length = 0;\n  }\n\n  addItem(item: AutoScrollItem) {\n    if (this._isDestroyed || this._itemData.has(item)) return;\n\n    const { x, y } = item.position;\n    const itemData = new AutoScrollItemData();\n\n    itemData.positionX = x;\n    itemData.positionY = y;\n    itemData.directionX = AUTO_SCROLL_DIRECTION.none;\n    itemData.directionY = AUTO_SCROLL_DIRECTION.none;\n    itemData.overlapCheckRequestTime = this._tickTime;\n\n    this._itemData.set(item, itemData);\n    this.items.push(item);\n    if (!this._isTicking) this._startTicking();\n  }\n\n  removeItem(item: AutoScrollItem) {\n    if (this._isDestroyed) return;\n\n    const index = this.items.indexOf(item);\n    if (index === -1) return;\n\n    if (this._requests[AUTO_SCROLL_AXIS.x].get(item)) {\n      this._cancelItemScroll(item, AUTO_SCROLL_AXIS.x);\n      this._requests[AUTO_SCROLL_AXIS.x].delete(item);\n    }\n\n    if (this._requests[AUTO_SCROLL_AXIS.y].get(item)) {\n      this._cancelItemScroll(item, AUTO_SCROLL_AXIS.y);\n      this._requests[AUTO_SCROLL_AXIS.y].delete(item);\n    }\n\n    this._itemData.delete(item);\n    this.items.splice(index, 1);\n\n    if (this._isTicking && !this.items.length) {\n      this._stopTicking();\n    }\n  }\n\n  isDestroyed() {\n    return this._isDestroyed;\n  }\n\n  isItemScrollingX(item: AutoScrollItem) {\n    return !!this._requests[AUTO_SCROLL_AXIS.x].get(item)?.isActive;\n  }\n\n  isItemScrollingY(item: AutoScrollItem) {\n    return !!this._requests[AUTO_SCROLL_AXIS.y].get(item)?.isActive;\n  }\n\n  isItemScrolling(item: AutoScrollItem) {\n    return this.isItemScrollingX(item) || this.isItemScrollingY(item);\n  }\n\n  updateSettings(options: AutoScrollOptions = {}) {\n    const { overlapCheckInterval = this.settings.overlapCheckInterval } = options;\n    this.settings.overlapCheckInterval = overlapCheckInterval;\n  }\n\n  destroy() {\n    if (this._isDestroyed) return;\n    this.items.forEach((item) => this.removeItem(item));\n    this._requestPool.destroy();\n    this._actionPool.destroy();\n    this._actions.length = 0;\n    this._isDestroyed = true;\n  }\n}\n"],"mappings":"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"}