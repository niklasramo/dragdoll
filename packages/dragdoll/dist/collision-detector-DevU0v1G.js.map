{"version":3,"file":"collision-detector-DevU0v1G.js","names":["collisionData: T | null"],"sources":["../src/utils/create-rect.ts","../src/utils/object-arena.ts","../src/dnd-observer/collision-detector.ts"],"sourcesContent":["import type { Rect } from '../types.js';\n\nexport function createRect(sourceRect?: Rect, result: Rect = { width: 0, height: 0, x: 0, y: 0 }) {\n  if (sourceRect) {\n    result.width = sourceRect.width;\n    result.height = sourceRect.height;\n    result.x = sourceRect.x;\n    result.y = sourceRect.y;\n  }\n  return result;\n}\n","// A bump allocation arena implementation.\nexport class ObjectArena<Item extends object, ItemArgs extends unknown[] = []> {\n  protected _items: Item[];\n  protected _index: number;\n  protected _initItem: (item?: Item, ...args: ItemArgs) => Item;\n\n  // The initItem function is used to initialize a new item or an existing item.\n  // If the item is undefined it means that a new item needs to be created and\n  // returned. If the item is not undefined it means that an existing item needs\n  // to be initialized (e.g. reset the object keys to initial values) and\n  // returned.\n  constructor(initItem: (item?: Item, ...args: ItemArgs) => Item) {\n    this._items = [];\n    this._index = 0;\n    this._initItem = initItem;\n  }\n\n  allocate(...args: ItemArgs): Item {\n    const index = this._index;\n    const items = this._items;\n    const nextItem = this._initItem(items[index], ...args);\n    items[index] = nextItem;\n    ++this._index;\n    return nextItem;\n  }\n\n  reset(): void {\n    this._index = 0;\n  }\n\n  truncate(maxLength = 0): void {\n    const newItemCount = Math.max(0, Math.min(maxLength, this._items.length));\n    this._index = Math.min(this._index, newItemCount);\n    this._items.length = newItemCount;\n  }\n}\n","import type { AnyDraggable } from '../draggable/draggable.js';\nimport type { Droppable, DroppableId } from '../droppable/droppable.js';\nimport type { Rect } from '../types.js';\nimport { createRect } from '../utils/create-rect.js';\nimport { getIntersectionRect } from '../utils/get-intersection-rect.js';\nimport { getIntersectionScore } from '../utils/get-intersection-score.js';\nimport { ObjectArena } from '../utils/object-arena.js';\nimport type { DndObserver } from './dnd-observer.js';\n\n// The max amount of collisions we keep in collision pool when we return it\n// to the pool cache.\nconst MAX_CACHED_COLLISIONS = 20;\n\n// We use a symbol to represent an empty droppable id.\nconst EMPTY_SYMBOL = Symbol();\n\nexport interface CollisionData {\n  droppableId: DroppableId;\n  droppableRect: Rect;\n  draggableRect: Rect;\n  intersectionRect: Rect;\n  intersectionScore: number;\n}\n\nexport class CollisionDetector<T extends CollisionData = CollisionData> {\n  protected _listenerId: symbol;\n  protected _dndObserver: DndObserver<T>;\n  protected _cdArenaPool: ObjectArena<T>[];\n  protected _cdArenaMap: Map<AnyDraggable, ObjectArena<T>>;\n\n  constructor(dndObserver: DndObserver<T>) {\n    this._listenerId = Symbol();\n    this._dndObserver = dndObserver;\n    this._cdArenaPool = [];\n    this._cdArenaMap = new Map();\n  }\n\n  protected _checkCollision(\n    draggable: AnyDraggable,\n    droppable: Droppable,\n    collisionData: T,\n  ): T | null {\n    const draggableRect = draggable.getClientRect();\n    const droppableRect = droppable.getClientRect();\n    if (!draggableRect) return null;\n\n    const intersectionRect = getIntersectionRect(\n      draggableRect,\n      droppableRect,\n      collisionData.intersectionRect,\n    );\n    if (intersectionRect === null) return null;\n\n    const intersectionScore = getIntersectionScore(draggableRect, droppableRect, intersectionRect);\n    if (intersectionScore <= 0) return null;\n\n    collisionData.droppableId = droppable.id;\n    createRect(droppableRect, collisionData.droppableRect);\n    createRect(draggableRect, collisionData.draggableRect);\n    collisionData.intersectionScore = intersectionScore;\n    return collisionData;\n  }\n\n  protected _sortCollisions(_draggable: AnyDraggable, collisions: T[]): T[] {\n    return collisions.sort((a, b) => {\n      const diff = b.intersectionScore - a.intersectionScore;\n      if (diff !== 0) return diff;\n\n      return (\n        a.droppableRect.width * a.droppableRect.height -\n        b.droppableRect.width * b.droppableRect.height\n      );\n    });\n  }\n\n  protected _createCollisionData(): T {\n    return {\n      droppableId: EMPTY_SYMBOL,\n      droppableRect: createRect(),\n      draggableRect: createRect(),\n      intersectionRect: createRect(),\n      intersectionScore: 0,\n    } as T;\n  }\n\n  protected _getCollisionDataArena(draggable: AnyDraggable): ObjectArena<T> {\n    let cdArena = this._cdArenaMap.get(draggable);\n    if (!cdArena) {\n      cdArena =\n        this._cdArenaPool.pop() ||\n        new ObjectArena((item) => {\n          return item || this._createCollisionData();\n        });\n      this._cdArenaMap.set(draggable, cdArena);\n    }\n    return cdArena;\n  }\n\n  protected _removeCollisionDataArena(draggable: AnyDraggable) {\n    const cdArena = this._cdArenaMap.get(draggable);\n    if (cdArena) {\n      cdArena.truncate(MAX_CACHED_COLLISIONS);\n      cdArena.reset();\n      this._cdArenaPool.push(cdArena);\n      this._cdArenaMap.delete(draggable);\n    }\n  }\n\n  detectCollisions(draggable: AnyDraggable, targets: Map<DroppableId, Droppable>, collisions: T[]) {\n    // Reset the collisions array and colliding droppables set.\n    collisions.length = 0;\n\n    // If we don't have any targets, we can bail early.\n    if (!targets.size) {\n      return;\n    }\n\n    // Get or create the collision data pool for the draggable.\n    const cdArena = this._getCollisionDataArena(draggable);\n\n    // Detect collisions between the draggable and all targets.\n    let collisionData: T | null = null;\n    const droppables = targets.values();\n    for (const droppable of droppables) {\n      collisionData = collisionData || cdArena.allocate();\n      if (this._checkCollision(draggable, droppable, collisionData)) {\n        collisions.push(collisionData);\n        collisionData = null;\n      }\n    }\n\n    // Sort the collisions.\n    if (collisions.length > 1) {\n      this._sortCollisions(draggable, collisions);\n    }\n\n    // Reset collision data pool pointer.\n    cdArena.reset();\n  }\n\n  destroy() {\n    this._cdArenaMap.forEach((cdArena) => {\n      cdArena.truncate();\n    });\n  }\n}\n"],"mappings":"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"}