{"version":3,"file":"draggable-b_bwyIic.js","names":["currentElement: HTMLElement | SVGSVGElement | null","props: CSSProperties","unfrozenStyles: CSSProperties","DraggableDefaultSettings: DraggableSettings<any>"],"sources":["../src/utils/are-matrices-equal.ts","../src/utils/is-matrix-warped.ts","../src/utils/move-before.ts","../src/utils/reset-matrix.ts","../src/utils/round-number.ts","../src/utils/object-cache.ts","../src/draggable/draggable-drag.ts","../src/utils/set-styles.ts","../src/utils/create-measure-element.ts","../src/utils/get-client-offset.ts","../src/utils/get-intrinsic-height.ts","../src/utils/get-intrinsic-width.ts","../src/utils/get-element-transform-string.ts","../src/utils/is-point.ts","../src/utils/get-offset-diff.ts","../src/utils/parse-transform-origin.ts","../src/utils/get-world-transform-matrix.ts","../src/draggable/draggable-drag-item.ts","../src/draggable/draggable.ts"],"sourcesContent":["export function areMatricesEqual(m1: DOMMatrix, m2: DOMMatrix) {\n  if (m1.isIdentity && m2.isIdentity) return true;\n\n  if (m1.is2D && m2.is2D) {\n    return (\n      m1.a === m2.a &&\n      m1.b === m2.b &&\n      m1.c === m2.c &&\n      m1.d === m2.d &&\n      m1.e === m2.e &&\n      m1.f === m2.f\n    );\n  }\n\n  return (\n    m1.m11 === m2.m11 &&\n    m1.m12 === m2.m12 &&\n    m1.m13 === m2.m13 &&\n    m1.m14 === m2.m14 &&\n    m1.m21 === m2.m21 &&\n    m1.m22 === m2.m22 &&\n    m1.m23 === m2.m23 &&\n    m1.m24 === m2.m24 &&\n    m1.m31 === m2.m31 &&\n    m1.m32 === m2.m32 &&\n    m1.m33 === m2.m33 &&\n    m1.m34 === m2.m34 &&\n    m1.m41 === m2.m41 &&\n    m1.m42 === m2.m42 &&\n    m1.m43 === m2.m43 &&\n    m1.m44 === m2.m44\n  );\n}\n","// The naming is a bit misleading here, but this function in essence checks if a\n// matrix contains any transformation other than a 2d translation.\nexport function isMatrixWarped(m: DOMMatrix) {\n  return (\n    m.m11 !== 1 ||\n    m.m12 !== 0 ||\n    m.m13 !== 0 ||\n    m.m14 !== 0 ||\n    m.m21 !== 0 ||\n    m.m22 !== 1 ||\n    m.m23 !== 0 ||\n    m.m24 !== 0 ||\n    m.m31 !== 0 ||\n    m.m32 !== 0 ||\n    m.m33 !== 1 ||\n    m.m34 !== 0 ||\n    m.m43 !== 0 ||\n    m.m44 !== 1\n  );\n}\n","// A special append method which doesn't lose focus when appending an element.\nexport function moveBefore(container: Node, node: Node, refNode: Node | null = null) {\n  // Use experimental moveBefore method if it's available.\n  if ('moveBefore' in container && container.isConnected === node.isConnected) {\n    try {\n      // @ts-expect-error - moveBefore method is experimental.\n      container.moveBefore(node, refNode);\n      return;\n    } catch {\n      // Ignore the error. This is an optimization, not a critical path.\n    }\n  }\n\n  // Get the focused element and check if the node contains the focused element.\n  const focusedElement = document.activeElement;\n  const containsFocus = node.contains(focusedElement);\n\n  // Insert the node before the reference node.\n  container.insertBefore(node, refNode);\n\n  // Restore focus if needed.\n  if (\n    containsFocus &&\n    document.activeElement !== focusedElement &&\n    focusedElement instanceof HTMLElement\n  ) {\n    focusedElement.focus({ preventScroll: true });\n  }\n}\n","const RESET_TRANSFORM = 'scale(1, 1)';\n\nexport function resetMatrix(m: DOMMatrix) {\n  return m.setMatrixValue(RESET_TRANSFORM);\n}\n","export function roundNumber(value: number, decimals = 0): number {\n  const multiplier = Math.pow(10, decimals);\n  return Math.round((value + Number.EPSILON) * multiplier) / multiplier;\n}\n","export class ObjectCache<Key, Value> {\n  protected _cache: Map<Key, Value>;\n  protected _validation: Set<Key>;\n\n  constructor() {\n    this._cache = new Map();\n    this._validation = new Set();\n  }\n\n  set(key: Key, value: Value) {\n    this._cache.set(key, value);\n    this._validation.add(key);\n  }\n\n  get(key: Key): Value | undefined {\n    return this._cache.get(key);\n  }\n\n  has(key: Key): boolean {\n    return this._cache.has(key);\n  }\n\n  delete(key: Key) {\n    this._cache.delete(key);\n    this._validation.delete(key);\n  }\n\n  isValid(key: Key): boolean {\n    return this._validation.has(key);\n  }\n\n  invalidate(key?: Key) {\n    if (key === undefined) {\n      this._validation.clear();\n    } else {\n      this._validation.delete(key);\n    }\n  }\n\n  clear() {\n    this._cache.clear();\n    this._validation.clear();\n  }\n}\n","import type { Sensor } from '../sensors/sensor.js';\nimport type { Point } from '../types.js';\nimport { ObjectCache } from '../utils/object-cache.js';\nimport type { DraggableDragItem } from './draggable-drag-item.js';\n\n// Internal type for inferring the events type from the sensor type.\ntype E<S extends Sensor[]> = S[number]['_events_type'];\n\nexport class DraggableDrag<S extends Sensor[]> {\n  readonly sensor: S[number];\n  readonly startEvent: E<S>['start'] | E<S>['move'];\n  readonly prevMoveEvent: E<S>['start'] | E<S>['move'];\n  readonly moveEvent: E<S>['start'] | E<S>['move'];\n  readonly endEvent: E<S>['end'] | E<S>['cancel'] | E<S>['destroy'] | null;\n  readonly items: DraggableDragItem[];\n  readonly isEnded: boolean;\n  protected _matrixCache: ObjectCache<HTMLElement | SVGSVGElement, [DOMMatrix, DOMMatrix]>;\n  protected _clientOffsetCache: ObjectCache<HTMLElement | SVGSVGElement | Window | Document, Point>;\n\n  constructor(sensor: S[number], startEvent: E<S>['start'] | E<S>['move']) {\n    this.sensor = sensor;\n    this.startEvent = startEvent;\n    this.prevMoveEvent = startEvent;\n    this.moveEvent = startEvent;\n    this.endEvent = null;\n    this.items = [];\n    this.isEnded = false;\n    this._matrixCache = new ObjectCache();\n    this._clientOffsetCache = new ObjectCache();\n  }\n}\n","export function setStyles(el: HTMLElement, styles: Record<string, string>, important = false) {\n  const { style } = el;\n  for (const key in styles) {\n    style.setProperty(key, styles[key], important ? 'important' : '');\n  }\n}\n","import { setStyles } from './set-styles.js';\n\nexport function createMeasureElement() {\n  const el = document.createElement('div');\n  el.classList.add('dragdoll-measure');\n  setStyles(\n    el,\n    {\n      display: 'block',\n      position: 'absolute',\n      inset: '0px',\n      padding: '0px',\n      margin: '0px',\n      border: 'none',\n      opacity: '0',\n      transform: 'none',\n      'transform-origin': '0 0',\n      transition: 'none',\n      animation: 'none',\n      'pointer-events': 'none',\n    },\n    true,\n  );\n  return el;\n}\n","import type { Point } from '../types.js';\nimport { getStyle } from './get-style.js';\n\n// Computes element's (padding box) offset from the window's top-left corner.\nexport function getClientOffset(\n  element: HTMLElement | SVGSVGElement | Window | Document,\n  result: Point = { x: 0, y: 0 },\n): Point {\n  result.x = 0;\n  result.y = 0;\n\n  // If window, return 0, 0.\n  if (element instanceof Window) {\n    return result;\n  }\n\n  // If document, return the offset from Window.\n  if (element instanceof Document) {\n    result.x = window.scrollX * -1;\n    result.y = window.scrollY * -1;\n    return result;\n  }\n\n  // If element, calculate the offset from the element's padding box to the\n  // window's top-left corner.\n  const { x, y } = element.getBoundingClientRect();\n  const style = getStyle(element);\n  result.x = x + (parseFloat(style.borderLeftWidth) || 0);\n  result.y = y + (parseFloat(style.borderTopWidth) || 0);\n  return result;\n}\n","import { getStyle } from './get-style.js';\n\nexport function getIntrinsicHeight(element: HTMLElement | SVGSVGElement) {\n  const style = getStyle(element);\n  let height = parseFloat(style.height) || 0;\n\n  if (style.boxSizing === 'border-box') {\n    return height;\n  }\n\n  // Add border.\n  height += parseFloat(style.borderTopWidth) || 0;\n  height += parseFloat(style.borderBottomWidth) || 0;\n\n  // Add padding.\n  height += parseFloat(style.paddingTop) || 0;\n  height += parseFloat(style.paddingBottom) || 0;\n\n  // Add scrollbar height.\n  if (element instanceof HTMLElement) {\n    height += element.offsetHeight - element.clientHeight;\n  }\n\n  return height;\n}\n","import { getStyle } from './get-style.js';\n\nexport function getIntrinsicWidth(element: HTMLElement | SVGSVGElement) {\n  const style = getStyle(element);\n  let width = parseFloat(style.width) || 0;\n\n  if (style.boxSizing === 'border-box') {\n    return width;\n  }\n\n  // Add border.\n  width += parseFloat(style.borderLeftWidth) || 0;\n  width += parseFloat(style.borderRightWidth) || 0;\n\n  // Add padding.\n  width += parseFloat(style.paddingLeft) || 0;\n  width += parseFloat(style.paddingRight) || 0;\n\n  // Add scrollbar width.\n  if (element instanceof HTMLElement) {\n    width += element.offsetWidth - element.clientWidth;\n  }\n\n  return width;\n}\n","import { getIntrinsicHeight } from './get-intrinsic-height.js';\nimport { getIntrinsicWidth } from './get-intrinsic-width.js';\nimport { getStyle } from './get-style.js';\n\nexport function getElementTransformString(\n  el: HTMLElement | SVGSVGElement,\n  ignoreNormalTransform = false,\n) {\n  const { translate, rotate, scale, transform } = getStyle(el);\n  let transformString = '';\n\n  // Parse translate shorthand.\n  if (translate && translate !== 'none') {\n    let [x = '0px', y = '0px', z] = translate.split(' ');\n\n    // Transform x to pixels if it's a percentage.\n    if (x.includes('%')) {\n      x = `${(parseFloat(x) / 100) * getIntrinsicWidth(el)}px`;\n    }\n\n    // Transform y to pixels if it's a percentage.\n    if (y.includes('%')) {\n      y = `${(parseFloat(y) / 100) * getIntrinsicHeight(el)}px`;\n    }\n\n    // z can never be a percentage, but if it is defined we need to use\n    // translate3d instead of translate.\n    if (z) {\n      transformString += `translate3d(${x},${y},${z})`;\n    } else {\n      transformString += `translate(${x},${y})`;\n    }\n  }\n\n  // Parse rotate shorthand.\n  if (rotate && rotate !== 'none') {\n    const rotateValues = rotate.split(' ');\n    if (rotateValues.length > 1) {\n      transformString += `rotate3d(${rotateValues.join(',')})`;\n    } else {\n      transformString += `rotate(${rotateValues.join(',')})`;\n    }\n  }\n\n  // Parse scale shorthand.\n  if (scale && scale !== 'none') {\n    const scaleValues = scale.split(' ');\n    if (scaleValues.length === 3) {\n      transformString += `scale3d(${scaleValues.join(',')})`;\n    } else {\n      transformString += `scale(${scaleValues.join(',')})`;\n    }\n  }\n\n  // Parse transform.\n  if (!ignoreNormalTransform && transform && transform !== 'none') {\n    transformString += transform;\n  }\n\n  return transformString;\n}\n","import type { Point } from '../types.js';\n\nexport function isPoint(value: any): value is Point {\n  return typeof value === 'object' && value !== null && 'x' in value && 'y' in value;\n}\n","import type { Point } from '../types.js';\nimport { getClientOffset } from './get-client-offset.js';\nimport { isPoint } from './is-point.js';\n\nconst OFFSET_A = { x: 0, y: 0 };\nconst OFFSET_B = { x: 0, y: 0 };\n\n/**\n * Calculate the offset difference two elements.\n */\nexport function getOffsetDiff(\n  elemA: HTMLElement | SVGSVGElement | Window | Document | Point,\n  elemB: HTMLElement | SVGSVGElement | Window | Document | Point,\n  result: Point = { x: 0, y: 0 },\n) {\n  const offsetA = isPoint(elemA) ? elemA : getClientOffset(elemA, OFFSET_A);\n  const offsetB = isPoint(elemB) ? elemB : getClientOffset(elemB, OFFSET_B);\n  result.x = offsetB.x - offsetA.x;\n  result.y = offsetB.y - offsetA.y;\n  return result;\n}\n","export function parseTransformOrigin(transformOrigin: string): { x: number; y: number; z: number } {\n  const values = transformOrigin.split(' ');\n  let originX = '';\n  let originY = '';\n  let originZ = '';\n\n  if (values.length === 1) {\n    originX = originY = values[0];\n  } else if (values.length === 2) {\n    [originX, originY] = values;\n  } else {\n    [originX, originY, originZ] = values;\n  }\n\n  return {\n    x: parseFloat(originX) || 0,\n    y: parseFloat(originY) || 0,\n    z: parseFloat(originZ) || 0,\n  };\n}\n","import { IS_BROWSER } from '../constants.js';\nimport { getElementTransformString } from './get-element-transform-string.js';\nimport { getStyle } from './get-style.js';\nimport { parseTransformOrigin } from './parse-transform-origin.js';\nimport { resetMatrix } from './reset-matrix.js';\n\nconst MATRIX = IS_BROWSER ? new DOMMatrix() : null;\n\nexport function getWorldTransformMatrix(\n  el: HTMLElement | SVGSVGElement,\n  result = new DOMMatrix(),\n): DOMMatrix {\n  let currentElement: HTMLElement | SVGSVGElement | null = el;\n\n  // Reset the result matrix to identity.\n  resetMatrix(result);\n\n  while (currentElement) {\n    const transformString = getElementTransformString(currentElement);\n    if (transformString) {\n      MATRIX!.setMatrixValue(transformString);\n      if (!MATRIX!.isIdentity) {\n        const { transformOrigin } = getStyle(currentElement);\n        const { x, y, z } = parseTransformOrigin(transformOrigin);\n        if (z === 0) {\n          MATRIX!.setMatrixValue(\n            `translate(${x}px,${y}px) ${MATRIX} translate(${x * -1}px,${y * -1}px)`,\n          );\n        } else {\n          MATRIX!.setMatrixValue(\n            `translate3d(${x}px,${y}px,${z}px) ${MATRIX} translate3d(${x * -1}px,${y * -1}px,${z * -1}px)`,\n          );\n        }\n        result.preMultiplySelf(MATRIX!);\n      }\n    }\n    currentElement = currentElement.parentElement;\n  }\n\n  return result;\n}\n","import { getOffsetContainer } from 'mezr/getOffsetContainer';\nimport { IS_BROWSER } from '../constants.js';\nimport type { Sensor } from '../sensors/sensor.js';\nimport type { CSSProperties, Point, Rect } from '../types.js';\nimport { createMeasureElement } from '../utils/create-measure-element.js';\nimport { getClientOffset } from '../utils/get-client-offset.js';\nimport { getElementTransformString } from '../utils/get-element-transform-string.js';\nimport { getOffsetDiff } from '../utils/get-offset-diff.js';\nimport { getStyle } from '../utils/get-style.js';\nimport { getWorldTransformMatrix } from '../utils/get-world-transform-matrix.js';\nimport { isMatrixWarped } from '../utils/is-matrix-warped.js';\nimport type { ObjectCache } from '../utils/object-cache.js';\nimport { parseTransformOrigin } from '../utils/parse-transform-origin.js';\nimport type { Draggable } from './draggable.js';\n\nconst MEASURE_ELEMENT = IS_BROWSER ? createMeasureElement() : null;\n\nexport class DraggableDragItem<S extends Sensor[] = Sensor[]> {\n  data: { [key: string]: any };\n  readonly element: HTMLElement | SVGSVGElement;\n  readonly elementContainer: HTMLElement;\n  readonly elementOffsetContainer: HTMLElement | SVGSVGElement | Window | Document;\n  readonly dragContainer: HTMLElement;\n  readonly dragOffsetContainer: HTMLElement | SVGSVGElement | Window | Document;\n  readonly elementTransformOrigin: { x: number; y: number; z: number };\n  readonly elementTransformMatrix: DOMMatrix;\n  readonly elementOffsetMatrix: DOMMatrix;\n  readonly frozenStyles: CSSProperties | null;\n  readonly unfrozenStyles: CSSProperties | null;\n  readonly clientRect: Rect;\n  readonly position: Point;\n  readonly containerOffset: Point;\n  readonly alignmentOffset: Point;\n  protected _moveDiff: Point;\n  protected _alignDiff: Point;\n  protected _matrixCache: ObjectCache<HTMLElement | SVGSVGElement, [DOMMatrix, DOMMatrix]>;\n  protected _clientOffsetCache: ObjectCache<HTMLElement | SVGSVGElement | Window | Document, Point>;\n\n  constructor(element: HTMLElement | SVGSVGElement, draggable: Draggable<S>) {\n    // Make sure the element is in DOM.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected\n    if (!element.isConnected) {\n      throw new Error('Element is not connected');\n    }\n\n    // Make sure drag is defined.\n    const { drag } = draggable;\n    if (!drag) {\n      throw new Error('Drag is not defined');\n    }\n\n    const style = getStyle(element);\n    const clientRect = element.getBoundingClientRect();\n    const individualTransforms = getElementTransformString(element, true);\n\n    this.data = {};\n    this.element = element;\n    this.elementTransformOrigin = parseTransformOrigin(style.transformOrigin);\n    this.elementTransformMatrix = new DOMMatrix().setMatrixValue(\n      individualTransforms + style.transform,\n    );\n    this.elementOffsetMatrix = new DOMMatrix(individualTransforms).invertSelf();\n    this.frozenStyles = null;\n    this.unfrozenStyles = null;\n    this.position = { x: 0, y: 0 };\n    this.containerOffset = { x: 0, y: 0 };\n    this.alignmentOffset = { x: 0, y: 0 };\n    this._moveDiff = { x: 0, y: 0 };\n    this._alignDiff = { x: 0, y: 0 };\n    this._matrixCache = drag['_matrixCache'];\n    this._clientOffsetCache = drag['_clientOffsetCache'];\n\n    // Use element's parent element as the element container.\n    const elementContainer = element.parentElement;\n    if (!elementContainer) {\n      throw new Error('Dragged element does not have a parent element.');\n    }\n    this.elementContainer = elementContainer;\n\n    // Get element's drag parent, default to element's parent element.\n    const dragContainer = draggable.settings.container || elementContainer;\n    this.dragContainer = dragContainer;\n\n    // Make sure that the element is fixed or absolute positioned if there\n    // is a drag container.\n    if (elementContainer !== dragContainer) {\n      const { position } = style;\n      if (position !== 'fixed' && position !== 'absolute') {\n        throw new Error(\n          `Dragged element has \"${position}\" position, but only \"fixed\" or \"absolute\" are allowed when using a custom drag container.`,\n        );\n      }\n    }\n\n    // Compute element's offset container.\n    const elementOffsetContainer = getOffsetContainer(element) || element;\n    this.elementOffsetContainer = elementOffsetContainer;\n\n    // Get drag container's offset container.\n    const dragOffsetContainer =\n      dragContainer === elementContainer\n        ? elementOffsetContainer\n        : getOffsetContainer(element, { container: dragContainer })!;\n    this.dragOffsetContainer = dragOffsetContainer;\n\n    // Compute element's client rect.\n    {\n      const { width, height, x, y } = clientRect;\n      this.clientRect = { width, height, x, y };\n    }\n\n    // Compute container matrices and offset.\n    this._updateContainerMatrices();\n    this._updateContainerOffset();\n\n    // Get element's frozen props.\n    const frozenStyles = draggable.settings.frozenStyles({\n      draggable,\n      drag,\n      item: this,\n      style,\n    });\n    if (Array.isArray(frozenStyles)) {\n      if (frozenStyles.length) {\n        const props: CSSProperties = {};\n        for (const prop of frozenStyles) {\n          props[prop] = style[prop];\n        }\n        this.frozenStyles = props;\n      } else {\n        this.frozenStyles = null;\n      }\n    } else {\n      this.frozenStyles = frozenStyles;\n    }\n\n    // Lastly, let's compute the unfrozen props. We store the current inline\n    // style values for all frozen props so that we can restore them after the\n    // drag process is over.\n    if (this.frozenStyles) {\n      const unfrozenStyles: CSSProperties = {};\n      for (const key in this.frozenStyles) {\n        unfrozenStyles[key as keyof CSSProperties] = element.style[key as keyof CSSProperties];\n      }\n      this.unfrozenStyles = unfrozenStyles;\n    }\n  }\n\n  protected _updateContainerMatrices() {\n    [this.elementContainer, this.dragContainer].forEach((container) => {\n      if (!this._matrixCache.isValid(container)) {\n        const matrices = this._matrixCache.get(container) || [new DOMMatrix(), new DOMMatrix()];\n        const [matrix, inverseMatrix] = matrices;\n        getWorldTransformMatrix(container, matrix);\n        inverseMatrix.setMatrixValue(matrix.toString()).invertSelf();\n        this._matrixCache.set(container, matrices);\n      }\n    });\n  }\n\n  protected _updateContainerOffset() {\n    const {\n      elementOffsetContainer,\n      elementContainer,\n      dragOffsetContainer,\n      dragContainer,\n      containerOffset,\n      _clientOffsetCache,\n      _matrixCache,\n    } = this;\n\n    // If element's offset container is different than drag container's\n    // offset container let's compute the offset between the offset containers.\n    if (elementOffsetContainer !== dragOffsetContainer) {\n      // Get the client offsets for the element and drag containers.\n      const [dragOffset, elementOffset] = (\n        [\n          [dragContainer, dragOffsetContainer],\n          [elementContainer, elementOffsetContainer],\n        ] as const\n      ).map(([container, offsetContainer]) => {\n        // Get the client offset from the cache or create a new one.\n        const offset = _clientOffsetCache.get(offsetContainer) || { x: 0, y: 0 };\n\n        // If the client offset is not cached let's compute it.\n        if (!_clientOffsetCache.isValid(offsetContainer)) {\n          // Get the world transform matrices.\n          const matrices = _matrixCache.get(container);\n\n          // If the offset container is a valid HTMLElement and the matrix is\n          // not an identity matrix we need to do some extra work.\n          if (offsetContainer instanceof HTMLElement && matrices && !matrices[0].isIdentity) {\n            // If the matrix is scaled, rotated, skewed or 3d translated we\n            // (unfortunately) need to add a temporary measure element to\n            // compute the untransformed offset from the window's top-left\n            // corner. If there was a way to compute the offset without\n            // manipulating the DOM, we would definitely do that, but\n            // unfortunately, there seems to be no way to do that accurately\n            // with subpixel precision.\n            if (isMatrixWarped(matrices[0])) {\n              MEASURE_ELEMENT!.style.setProperty('transform', matrices[1].toString(), 'important');\n              offsetContainer.append(MEASURE_ELEMENT!);\n              getClientOffset(MEASURE_ELEMENT!, offset);\n              MEASURE_ELEMENT!.remove();\n            }\n            // If the matrix only contains a 2d translation we can compute the\n            // client offset normally and subtract the translation values from\n            // the offset.\n            else {\n              getClientOffset(offsetContainer, offset);\n              offset.x -= matrices[0].m41;\n              offset.y -= matrices[0].m42;\n            }\n          }\n          // In all other cases, let's compute the client offset normally.\n          else {\n            getClientOffset(offsetContainer, offset);\n          }\n        }\n\n        // Cache the client offset.\n        _clientOffsetCache.set(offsetContainer, offset);\n\n        return offset;\n      });\n\n      getOffsetDiff(dragOffset, elementOffset, containerOffset);\n    } else {\n      containerOffset.x = 0;\n      containerOffset.y = 0;\n    }\n  }\n\n  getContainerMatrix() {\n    return this._matrixCache.get(this.elementContainer)!;\n  }\n\n  getDragContainerMatrix() {\n    return this._matrixCache.get(this.dragContainer)!;\n  }\n\n  updateSize(dimensions?: { width: number; height: number }) {\n    if (dimensions) {\n      this.clientRect.width = dimensions.width;\n      this.clientRect.height = dimensions.height;\n    } else {\n      const { width, height } = this.element.getBoundingClientRect();\n      this.clientRect.width = width;\n      this.clientRect.height = height;\n    }\n  }\n}\n","import { Emitter } from 'eventti';\nimport { IS_BROWSER } from '../constants.js';\nimport type { Sensor, SensorEventListenerId, SensorEvents } from '../sensors/sensor.js';\nimport { SensorEventType } from '../sensors/sensor.js';\nimport { ticker, tickerPhases } from '../singletons/ticker.js';\nimport type { CSSProperties, Point, Rect, Writeable } from '../types.js';\nimport { areMatricesEqual } from '../utils/are-matrices-equal.js';\nimport { isMatrixWarped } from '../utils/is-matrix-warped.js';\nimport { moveBefore } from '../utils/move-before.js';\nimport { resetMatrix } from '../utils/reset-matrix.js';\nimport { roundNumber } from '../utils/round-number.js';\nimport { DraggableDrag } from './draggable-drag.js';\nimport { DraggableDragItem } from './draggable-drag-item.js';\n\nconst SCROLL_LISTENER_OPTIONS = { capture: true, passive: true };\n\nconst POSITION_CHANGE = { x: 0, y: 0 };\n\nconst ELEMENT_MATRIX = IS_BROWSER ? new DOMMatrix() : null;\n\nconst TEMP_MATRIX = IS_BROWSER ? new DOMMatrix() : null;\n\nenum DragStartPhase {\n  None = 0,\n  Init = 1,\n  Prepare = 2,\n  FinishPrepare = 3,\n  Apply = 4,\n  FinishApply = 5,\n}\n\nenum DraggableStartPredicateState {\n  Pending = 0,\n  Resolved = 1,\n  Rejected = 2,\n}\n\n// Internal type for inferring the events type from the sensor type.\ntype E<S extends Sensor[]> = S[number]['_events_type'];\n\nexport type AnyDraggable = Draggable<any, any>;\n\nexport type DraggableId = string | number | symbol;\n\nexport type DraggableDndGroup = string | number | symbol;\n\nexport const DraggableModifierPhase = {\n  Start: 'start',\n  Move: 'move',\n  End: 'end',\n} as const;\n\nexport type DraggableModifierPhase =\n  (typeof DraggableModifierPhase)[keyof typeof DraggableModifierPhase];\n\nexport const DraggableSensorProcessingMode = {\n  Immediate: 'immediate',\n  Sampled: 'sampled',\n} as const;\n\nexport type DraggableSensorProcessingMode =\n  (typeof DraggableSensorProcessingMode)[keyof typeof DraggableSensorProcessingMode];\n\nexport const DraggableApplyPositionPhase = {\n  Start: 'start',\n  StartAlign: 'start-align',\n  Move: 'move',\n  Align: 'align',\n  End: 'end',\n  EndAlign: 'end-align',\n} as const;\n\nexport type DraggableApplyPositionPhase =\n  (typeof DraggableApplyPositionPhase)[keyof typeof DraggableApplyPositionPhase];\n\nexport type DraggableModifierData<S extends Sensor[]> = {\n  draggable: Draggable<S>;\n  drag: DraggableDrag<S>;\n  item: DraggableDragItem<S>;\n  phase: DraggableModifierPhase;\n};\n\nexport type DraggableModifier<S extends Sensor[]> = (\n  change: Point,\n  data: DraggableModifierData<S>,\n) => Point;\n\nexport interface DraggableSettings<S extends Sensor[]> {\n  container: HTMLElement | null;\n  startPredicate: (data: {\n    draggable: Draggable<S>;\n    sensor: S[number];\n    event: E<S>['start'] | E<S>['move'];\n  }) => boolean | undefined;\n  elements: (data: {\n    draggable: Draggable<S>;\n    drag: DraggableDrag<S>;\n  }) => (HTMLElement | SVGSVGElement)[] | null;\n  frozenStyles: (data: {\n    draggable: Draggable<S>;\n    drag: DraggableDrag<S>;\n    item: DraggableDragItem<S>;\n    style: CSSStyleDeclaration;\n  }) => CSSProperties | (keyof CSSProperties)[] | null;\n  positionModifiers: DraggableModifier<S>[];\n  applyPosition: (data: {\n    draggable: Draggable<S>;\n    drag: DraggableDrag<S>;\n    item: DraggableDragItem<S>;\n    phase: DraggableApplyPositionPhase;\n  }) => void;\n  computeClientRect?: (data: {\n    draggable: Draggable<S>;\n    drag: DraggableDrag<S>;\n  }) => Readonly<Rect> | null;\n  sensorProcessingMode?: DraggableSensorProcessingMode;\n  dndGroups?: Set<DraggableDndGroup>;\n  onPrepareStart?: (drag: DraggableDrag<S>, draggable: Draggable<S>) => void;\n  onStart?: (drag: DraggableDrag<S>, draggable: Draggable<S>) => void;\n  onPrepareMove?: (drag: DraggableDrag<S>, draggable: Draggable<S>) => void;\n  onMove?: (drag: DraggableDrag<S>, draggable: Draggable<S>) => void;\n  onEnd?: (drag: DraggableDrag<S>, draggable: Draggable<S>) => void;\n  onDestroy?: (draggable: Draggable<S>) => void;\n}\n\nexport interface DraggablePlugin {\n  name: string;\n  version: string;\n}\n\nexport type DraggablePluginMap = Record<string, DraggablePlugin | undefined>;\n\nexport const DraggableEventType = {\n  PrepareStart: 'preparestart',\n  Start: 'start',\n  PrepareMove: 'preparemove',\n  Move: 'move',\n  End: 'end',\n  Destroy: 'destroy',\n} as const;\n\nexport type DraggableEventType = (typeof DraggableEventType)[keyof typeof DraggableEventType];\n\nexport interface DraggableEventCallbacks<E extends SensorEvents> {\n  [DraggableEventType.PrepareStart]: (event: E['start'] | E['move']) => void;\n  [DraggableEventType.Start]: (event: E['start'] | E['move']) => void;\n  [DraggableEventType.PrepareMove]: (event: E['move']) => void;\n  [DraggableEventType.Move]: (event: E['move']) => void;\n  [DraggableEventType.End]: (event: E['end'] | E['cancel'] | E['destroy'] | null) => void;\n  [DraggableEventType.Destroy]: () => void;\n}\n\nexport const DraggableDefaultSettings: DraggableSettings<any> = {\n  container: null,\n  startPredicate: () => true,\n  elements: () => null,\n  frozenStyles: () => null,\n  applyPosition: ({ item, phase }) => {\n    const isEndPhase =\n      phase === DraggableApplyPositionPhase.End || phase === DraggableApplyPositionPhase.EndAlign;\n    const [containerMatrix, inverseContainerMatrix] = item.getContainerMatrix();\n    const [_dragContainerMatrix, inverseDragContainerMatrix] = item.getDragContainerMatrix();\n    const {\n      position,\n      alignmentOffset,\n      containerOffset,\n      elementTransformMatrix,\n      elementTransformOrigin,\n      elementOffsetMatrix,\n    } = item;\n    const { x: oX, y: oY, z: oZ } = elementTransformOrigin;\n    const needsOriginOffset =\n      !elementTransformMatrix.isIdentity && (oX !== 0 || oY !== 0 || oZ !== 0);\n    const tX = position.x + alignmentOffset.x + containerOffset.x;\n    const tY = position.y + alignmentOffset.y + containerOffset.y;\n\n    // Reset the matrix to identity.\n    resetMatrix(ELEMENT_MATRIX!);\n\n    // First of all negate the element's transform origin.\n    if (needsOriginOffset) {\n      if (oZ === 0) {\n        ELEMENT_MATRIX!.translateSelf(-oX, -oY);\n      } else {\n        ELEMENT_MATRIX!.translateSelf(-oX, -oY, -oZ);\n      }\n    }\n\n    // Invert the current container's matrix, so we can apply the\n    // translation in world space coordinates. If this is the end phase the\n    // element will have been appended back to the original container if\n    // there was a drag container defined. Otherwise the element will be\n    // appended to the drag container (if defined).\n    if (isEndPhase) {\n      if (!inverseContainerMatrix.isIdentity) {\n        ELEMENT_MATRIX!.multiplySelf(inverseContainerMatrix);\n      }\n    } else {\n      if (!inverseDragContainerMatrix.isIdentity) {\n        ELEMENT_MATRIX!.multiplySelf(inverseDragContainerMatrix);\n      }\n    }\n\n    // Apply the translation (in world space coordinates).\n    resetMatrix(TEMP_MATRIX!).translateSelf(tX, tY);\n    ELEMENT_MATRIX!.multiplySelf(TEMP_MATRIX!);\n\n    // Apply the element's original container's world matrix so we can apply\n    // the element's original transform as if it was in the original\n    // container's local space coordinates.\n    if (!containerMatrix.isIdentity) {\n      ELEMENT_MATRIX!.multiplySelf(containerMatrix);\n    }\n\n    // Undo the transform origin negation.\n    if (needsOriginOffset) {\n      resetMatrix(TEMP_MATRIX!).translateSelf(oX, oY, oZ);\n      ELEMENT_MATRIX!.multiplySelf(TEMP_MATRIX!);\n    }\n\n    // Apply the element's original transform.\n    if (!elementTransformMatrix.isIdentity) {\n      ELEMENT_MATRIX!.multiplySelf(elementTransformMatrix);\n    }\n\n    // Apply the element's offset matrix. The offset matrix is in practice the\n    // inverse transform matrix of the element's individual transforms\n    // (translate, rotate and scale). These individual transforms are applied\n    // before the element's transform matrix, so we need to premultiply the\n    // final matrix with the offset matrix.\n    if (!elementOffsetMatrix.isIdentity) {\n      ELEMENT_MATRIX!.preMultiplySelf(elementOffsetMatrix);\n    }\n\n    // Apply the matrix to the element.\n    item.element.style.transform = `${ELEMENT_MATRIX!}`;\n  },\n  computeClientRect: ({ drag }) => {\n    return drag.items[0].clientRect || null;\n  },\n  positionModifiers: [],\n  sensorProcessingMode: DraggableSensorProcessingMode.Sampled,\n  dndGroups: new Set(),\n} as const;\n\nexport class Draggable<\n  S extends Sensor[] = Sensor[],\n  // eslint-disable-next-line @typescript-eslint/no-empty-object-type\n  P extends DraggablePluginMap = {},\n> {\n  readonly id: DraggableId;\n  readonly sensors: S;\n  readonly settings: DraggableSettings<S>;\n  readonly plugins: P;\n  readonly drag: DraggableDrag<S> | null;\n  readonly isDestroyed: boolean;\n  protected _sensorData: Map<\n    S[number],\n    {\n      predicateState: DraggableStartPredicateState;\n      predicateEvent: E<S>['start'] | E<S>['move'] | null;\n      onMove: (e: Parameters<Draggable<S, P>['_onMove']>[0]) => void;\n      onEnd: (e: Parameters<Draggable<S, P>['_onEnd']>[0]) => void;\n    }\n  >;\n  protected _emitter: Emitter<{\n    [K in keyof DraggableEventCallbacks<E<S>>]: DraggableEventCallbacks<E<S>>[K];\n  }>;\n  protected _startPhase: DragStartPhase;\n  protected _startId: symbol;\n  protected _moveId: symbol;\n  protected _alignId: symbol;\n\n  constructor(sensors: S, options: Partial<DraggableSettings<S>> & { id?: DraggableId } = {}) {\n    const { id = Symbol(), ...restOptions } = options;\n    this.id = id;\n    this.sensors = sensors;\n    this.settings = this._parseSettings(restOptions as Partial<DraggableSettings<S>>);\n    this.plugins = {} as P;\n    this.drag = null;\n    this.isDestroyed = false;\n\n    this._sensorData = new Map();\n    this._emitter = new Emitter();\n    this._startPhase = DragStartPhase.None;\n    this._startId = Symbol();\n    this._moveId = Symbol();\n    this._alignId = Symbol();\n\n    // Bind methods (that need binding).\n    this._onMove = this._onMove.bind(this);\n    this._onScroll = this._onScroll.bind(this);\n    this._onEnd = this._onEnd.bind(this);\n    this._prepareStart = this._prepareStart.bind(this);\n    this._applyStart = this._applyStart.bind(this);\n    this._prepareMove = this._prepareMove.bind(this);\n    this._applyMove = this._applyMove.bind(this);\n    this._prepareAlign = this._prepareAlign.bind(this);\n    this._applyAlign = this._applyAlign.bind(this);\n\n    // Bind drag sensor events.\n    this.sensors.forEach((sensor) => {\n      this._sensorData.set(sensor, {\n        predicateState: DraggableStartPredicateState.Pending,\n        predicateEvent: null,\n        onMove: (e) => this._onMove(e, sensor),\n        onEnd: (e) => this._onEnd(e, sensor),\n      });\n      const { onMove, onEnd } = this._sensorData.get(sensor)!;\n      sensor.on(SensorEventType.Start, onMove, onMove);\n      sensor.on(SensorEventType.Move, onMove, onMove);\n      sensor.on(SensorEventType.Cancel, onEnd, onEnd);\n      sensor.on(SensorEventType.End, onEnd, onEnd);\n      sensor.on(SensorEventType.Destroy, onEnd, onEnd);\n    });\n  }\n\n  protected _parseSettings(\n    options?: Partial<this['settings']>,\n    defaults: this['settings'] = DraggableDefaultSettings,\n  ): this['settings'] {\n    const {\n      container = defaults.container,\n      startPredicate = defaults.startPredicate,\n      elements = defaults.elements,\n      frozenStyles = defaults.frozenStyles,\n      positionModifiers = defaults.positionModifiers,\n      applyPosition = defaults.applyPosition,\n      computeClientRect = defaults.computeClientRect,\n      sensorProcessingMode = defaults.sensorProcessingMode,\n      dndGroups = defaults.dndGroups,\n      onPrepareStart = defaults.onPrepareStart,\n      onStart = defaults.onStart,\n      onPrepareMove = defaults.onPrepareMove,\n      onMove = defaults.onMove,\n      onEnd = defaults.onEnd,\n      onDestroy = defaults.onDestroy,\n    } = options || {};\n\n    return {\n      container,\n      startPredicate,\n      elements,\n      frozenStyles,\n      positionModifiers,\n      applyPosition,\n      computeClientRect,\n      sensorProcessingMode,\n      dndGroups,\n      onPrepareStart,\n      onStart,\n      onPrepareMove,\n      onMove,\n      onEnd,\n      onDestroy,\n    };\n  }\n\n  protected _emit<K extends keyof DraggableEventCallbacks<E<S>>>(\n    type: K,\n    ...e: Parameters<DraggableEventCallbacks<E<S>>[K]>\n  ) {\n    this._emitter.emit(type, ...e);\n  }\n\n  protected _onMove(e: E<S>['start'] | E<S>['move'], sensor: S[number]) {\n    const sensorData = this._sensorData.get(sensor);\n    if (!sensorData) return;\n\n    switch (sensorData.predicateState) {\n      case DraggableStartPredicateState.Pending: {\n        sensorData.predicateEvent = e;\n\n        // Check if drag should start.\n        const shouldStart = this.settings.startPredicate({\n          draggable: this,\n          sensor,\n          event: e,\n        });\n\n        // Resolve procedure (start move process).\n        if (shouldStart === true) {\n          this.resolveStartPredicate(sensor);\n        }\n        // Reject procedure.\n        else if (shouldStart === false) {\n          this.rejectStartPredicate(sensor);\n        }\n        break;\n      }\n      case DraggableStartPredicateState.Resolved: {\n        // Move the element if dragging is active.\n        if (this.drag) {\n          (this.drag as Writeable<typeof this.drag>).moveEvent = e;\n          if (this.settings.sensorProcessingMode === DraggableSensorProcessingMode.Immediate) {\n            this._prepareMove();\n            this._applyMove();\n          } else {\n            ticker.once(tickerPhases.read, this._prepareMove, this._moveId);\n            ticker.once(tickerPhases.write, this._applyMove, this._moveId);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  protected _onScroll() {\n    this.align();\n  }\n\n  protected _onEnd(e: E<S>['end'] | E<S>['cancel'] | E<S>['destroy'], sensor: S[number]) {\n    const sensorData = this._sensorData.get(sensor);\n    if (!sensorData) return;\n\n    // If there is no active drag yet, let's reset the sensor's start predicate\n    // so that it can try starting drag again.\n    if (!this.drag) {\n      sensorData.predicateState = DraggableStartPredicateState.Pending;\n      sensorData.predicateEvent = null;\n    }\n    // Otherwise, if drag is active AND the sensor is the one that triggered the\n    // drag process, let's reset all sensors' start predicate states.\n    else if (sensorData.predicateState === DraggableStartPredicateState.Resolved) {\n      (this.drag as Writeable<typeof this.drag>).endEvent = e;\n      this._sensorData.forEach((data) => {\n        data.predicateState = DraggableStartPredicateState.Pending;\n        data.predicateEvent = null;\n      });\n      this.stop();\n    }\n  }\n\n  protected _prepareStart() {\n    const drag = this.drag;\n    if (!drag || this._startPhase !== DragStartPhase.Init) return;\n\n    // Update start phase.\n    this._startPhase = DragStartPhase.Prepare;\n\n    // Get elements that we'll need to move with the drag.\n    // NB: It is okay if there are no elements and thus no items. The drag\n    // process will process as usual, but no elements will be moved.\n    const elements =\n      this.settings.elements({\n        draggable: this,\n        drag,\n      }) || [];\n\n    // Create drag items.\n    (drag as Writeable<typeof drag>).items = elements.map((element) => {\n      return new DraggableDragItem(element, this);\n    });\n\n    // Apply modifiers for the start phase.\n    this._applyModifiers(DraggableModifierPhase.Start, 0, 0);\n\n    // Emit preparestart event.\n    this._emit(DraggableEventType.PrepareStart, drag.startEvent);\n\n    // Call onPrepareStart callback.\n    this.settings.onPrepareStart?.(drag, this);\n\n    // Update start phase.\n    this._startPhase = DragStartPhase.FinishPrepare;\n  }\n\n  protected _applyStart() {\n    const drag = this.drag;\n    if (!drag || this._startPhase !== DragStartPhase.FinishPrepare) return;\n\n    // Update start phase.\n    this._startPhase = DragStartPhase.Apply;\n\n    for (const item of drag.items) {\n      // Append element within the container element if such is provided.\n      if (item.dragContainer !== item.elementContainer) {\n        moveBefore(item.dragContainer, item.element);\n      }\n\n      // Freeze element's props if such are provided.\n      if (item.frozenStyles) {\n        Object.assign(item.element.style, item.frozenStyles);\n      }\n\n      // Set element's start position.\n      this.settings.applyPosition({\n        phase: DraggableApplyPositionPhase.Start,\n        draggable: this,\n        drag,\n        item,\n      });\n    }\n\n    // Compute the start offset (if needed).\n    for (const item of drag.items) {\n      const containerMatrix = item.getContainerMatrix()[0];\n      const dragContainerMatrix = item.getDragContainerMatrix()[0];\n\n      // If both container matrices are equal, we can skip the computation.\n      if (areMatricesEqual(containerMatrix, dragContainerMatrix)) {\n        continue;\n      }\n\n      // We can also skip computation if both matrices contain only 2D\n      // translations.\n      if (!isMatrixWarped(containerMatrix) && !isMatrixWarped(dragContainerMatrix)) {\n        continue;\n      }\n\n      const rect = item.element.getBoundingClientRect();\n      const { alignmentOffset } = item;\n\n      // Round the align diff to nearest 3rd decimal to avoid applying it if the\n      // value is so small that it's not visible.\n      alignmentOffset.x += roundNumber(item.clientRect.x - rect.x, 3);\n      alignmentOffset.y += roundNumber(item.clientRect.y - rect.y, 3);\n    }\n\n    // Apply start offset (if needed).\n    for (const item of drag.items) {\n      const { alignmentOffset } = item;\n      if (alignmentOffset.x !== 0 || alignmentOffset.y !== 0) {\n        this.settings.applyPosition({\n          phase: DraggableApplyPositionPhase.StartAlign,\n          draggable: this,\n          drag,\n          item,\n        });\n      }\n    }\n\n    // Bind scroll listeners.\n    window.addEventListener('scroll', this._onScroll, SCROLL_LISTENER_OPTIONS);\n\n    // Emit start event.\n    this._emit(DraggableEventType.Start, drag.startEvent);\n\n    // Call onStart callback.\n    this.settings.onStart?.(drag, this);\n\n    // Update start phase.\n    this._startPhase = DragStartPhase.FinishApply;\n  }\n\n  protected _prepareMove() {\n    const drag = this.drag;\n    if (!drag || drag.isEnded) return;\n\n    // Get next event and previous event so we can compute the movement\n    // difference between the clientX/Y values.\n    const { moveEvent, prevMoveEvent } = drag;\n    if (moveEvent === prevMoveEvent) return;\n\n    // Apply modifiers for the move phase.\n    this._applyModifiers(\n      DraggableModifierPhase.Move,\n      moveEvent.x - prevMoveEvent.x,\n      moveEvent.y - prevMoveEvent.y,\n    );\n\n    // Emit preparemove event.\n    this._emit(DraggableEventType.PrepareMove, moveEvent as E<S>['move']);\n\n    // Make sure that the drag is still active.\n    if (drag.isEnded) return;\n\n    // Call onPrepareMove callback.\n    this.settings.onPrepareMove?.(drag, this);\n\n    // Make sure that the drag is still active.\n    if (drag.isEnded) return;\n\n    // Store next move event as previous move event.\n    (drag as Writeable<typeof drag>).prevMoveEvent = moveEvent;\n  }\n\n  protected _applyMove() {\n    const drag = this.drag;\n    if (!drag || drag.isEnded) return;\n\n    // Reset movement diff and move the element.\n    for (const item of drag.items) {\n      item['_moveDiff'].x = 0;\n      item['_moveDiff'].y = 0;\n\n      this.settings.applyPosition({\n        phase: DraggableApplyPositionPhase.Move,\n        draggable: this,\n        drag,\n        item,\n      });\n    }\n\n    // Emit move event.\n    this._emit(DraggableEventType.Move, drag.moveEvent as E<S>['move']);\n\n    // Make sure that the drag is still active.\n    if (drag.isEnded) return;\n\n    // Call onMove callback.\n    this.settings.onMove?.(drag, this);\n  }\n\n  protected _prepareAlign() {\n    const { drag } = this;\n    if (!drag || drag.isEnded) return;\n\n    for (const item of drag.items) {\n      const { x, y } = item.element.getBoundingClientRect();\n\n      // Note that we INTENTIONALLY DO NOT UPDATE THE CLIENT RECT COORDINATES\n      // here. The point of this method is to update the POSITION of the\n      // draggable item based on how much the client rect has drifted so that\n      // the element is visually repositioned to the correct place.\n\n      // Update horizontal position data.\n      const alignDiffX = item.clientRect.x - item['_moveDiff'].x - x;\n      item.alignmentOffset.x = item.alignmentOffset.x - item['_alignDiff'].x + alignDiffX;\n      item['_alignDiff'].x = alignDiffX;\n\n      // Update vertical position data.\n      const alignDiffY = item.clientRect.y - item['_moveDiff'].y - y;\n      item.alignmentOffset.y = item.alignmentOffset.y - item['_alignDiff'].y + alignDiffY;\n      item['_alignDiff'].y = alignDiffY;\n    }\n  }\n\n  protected _applyAlign() {\n    const { drag } = this;\n    if (!drag || drag.isEnded) return;\n\n    for (const item of drag.items) {\n      item['_alignDiff'].x = 0;\n      item['_alignDiff'].y = 0;\n\n      this.settings.applyPosition({\n        phase: DraggableApplyPositionPhase.Align,\n        draggable: this,\n        drag,\n        item,\n      });\n    }\n  }\n\n  protected _applyModifiers(phase: DraggableModifierPhase, changeX: number, changeY: number) {\n    const { drag } = this;\n    if (!drag) return;\n\n    const { positionModifiers } = this.settings;\n    for (const item of drag.items) {\n      let positionChange = POSITION_CHANGE;\n      positionChange.x = changeX;\n      positionChange.y = changeY;\n      for (const modifier of positionModifiers) {\n        positionChange = modifier(positionChange, {\n          draggable: this,\n          drag,\n          item,\n          phase,\n        });\n      }\n      item.position.x += positionChange.x;\n      item.position.y += positionChange.y;\n      item.clientRect.x += positionChange.x;\n      item.clientRect.y += positionChange.y;\n      if (phase === 'move') {\n        item['_moveDiff'].x += positionChange.x;\n        item['_moveDiff'].y += positionChange.y;\n      }\n    }\n  }\n\n  on<T extends keyof DraggableEventCallbacks<E<S>>>(\n    type: T,\n    listener: DraggableEventCallbacks<E<S>>[T],\n    listenerId?: SensorEventListenerId,\n  ): SensorEventListenerId {\n    return this._emitter.on(type, listener, listenerId);\n  }\n\n  off<T extends keyof DraggableEventCallbacks<E<S>>>(\n    type: T,\n    listenerId: SensorEventListenerId,\n  ): void {\n    this._emitter.off(type, listenerId);\n  }\n\n  resolveStartPredicate(sensor: S[number], e?: E<S>['start'] | E<S>['move']) {\n    const sensorData = this._sensorData.get(sensor);\n    if (!sensorData) return;\n\n    const startEvent = e || sensorData.predicateEvent;\n\n    if (sensorData.predicateState === DraggableStartPredicateState.Pending && startEvent) {\n      // Update start phase.\n      this._startPhase = DragStartPhase.Init;\n\n      // Resolve the provided sensor's start predicate.\n      sensorData.predicateState = DraggableStartPredicateState.Resolved;\n      sensorData.predicateEvent = null;\n\n      (this as Writeable<this>).drag = new DraggableDrag(sensor, startEvent);\n\n      // Reject other sensors' start predicates.\n      this._sensorData.forEach((data, s) => {\n        if (s === sensor) return;\n        data.predicateState = DraggableStartPredicateState.Rejected;\n        data.predicateEvent = null;\n      });\n\n      // Queue drag start.\n      if (this.settings.sensorProcessingMode === DraggableSensorProcessingMode.Immediate) {\n        this._prepareStart();\n        this._applyStart();\n      } else {\n        ticker.once(tickerPhases.read, this._prepareStart, this._startId);\n        ticker.once(tickerPhases.write, this._applyStart, this._startId);\n      }\n    }\n  }\n\n  rejectStartPredicate(sensor: S[number]) {\n    const sensorData = this._sensorData.get(sensor);\n    if (sensorData?.predicateState === DraggableStartPredicateState.Pending) {\n      sensorData.predicateState = DraggableStartPredicateState.Rejected;\n      sensorData.predicateEvent = null;\n    }\n  }\n\n  stop() {\n    const drag = this.drag;\n    if (!drag || drag.isEnded) return;\n\n    // Throw an error if drag is being stopped in the middle of the start\n    // prepare or apply process. This is not allowed.\n    if (this._startPhase === DragStartPhase.Prepare || this._startPhase === DragStartPhase.Apply) {\n      throw new Error('Cannot stop drag start process at this point');\n    }\n\n    // Mark drag process as ended.\n    (drag as Writeable<typeof drag>).isEnded = true;\n\n    // Make sure the drag start process is completed.\n    // NB: The methods have guards making sure they are not called if the drag\n    // start process is already completed.\n    this._prepareStart();\n    this._applyStart();\n\n    // Reset drag start phase.\n    this._startPhase = DragStartPhase.None;\n\n    // Cancel all queued ticks.\n    ticker.off(tickerPhases.read, this._startId);\n    ticker.off(tickerPhases.write, this._startId);\n    ticker.off(tickerPhases.read, this._moveId);\n    ticker.off(tickerPhases.write, this._moveId);\n    ticker.off(tickerPhases.read, this._alignId);\n    ticker.off(tickerPhases.write, this._alignId);\n\n    // Unbind scroll listener.\n    window.removeEventListener('scroll', this._onScroll, SCROLL_LISTENER_OPTIONS);\n\n    // Apply modifiers for the end phase.\n    this._applyModifiers(DraggableModifierPhase.End, 0, 0);\n\n    for (const item of drag.items) {\n      // Move elements within the root container if they were moved to a\n      // different container during the drag process. Also reset alignment\n      // and container offsets for those elements.\n      if (item.elementContainer !== item.dragContainer) {\n        moveBefore(item.elementContainer, item.element);\n        item.alignmentOffset.x = 0;\n        item.alignmentOffset.y = 0;\n        item.containerOffset.x = 0;\n        item.containerOffset.y = 0;\n      }\n\n      // Unfreeze element's props if such are provided.\n      if (item.unfrozenStyles) {\n        for (const key in item.unfrozenStyles) {\n          item.element.style[key as keyof CSSProperties] =\n            item.unfrozenStyles[key as keyof CSSProperties] || '';\n        }\n      }\n\n      // Set (maybe) final position after drag.\n      this.settings.applyPosition({\n        phase: DraggableApplyPositionPhase.End,\n        draggable: this,\n        drag,\n        item,\n      });\n    }\n\n    // Make sure that all elements that were reparented during the drag process\n    // are actually aligned with the item's cached client rect data. NB: This\n    // procedure causes a reflow, but it's necessary to ensure that the elements\n    // are visually aligned correctly. We do the DOM reading in a separate loop\n    // to avoid layout thrashing more than necessary.\n    for (const item of drag.items) {\n      if (item.elementContainer !== item.dragContainer) {\n        const itemRect = item.element.getBoundingClientRect();\n        // Round the align diff to nearest 3rd decimal to avoid applying it if\n        // the value is so small that it's not visible.\n        item.alignmentOffset.x = roundNumber(item.clientRect.x - itemRect.x, 3);\n        item.alignmentOffset.y = roundNumber(item.clientRect.y - itemRect.y, 3);\n      }\n    }\n\n    // Apply final alignment to all the elements that need it.\n    for (const item of drag.items) {\n      if (\n        item.elementContainer !== item.dragContainer &&\n        (item.alignmentOffset.x !== 0 || item.alignmentOffset.y !== 0)\n      ) {\n        this.settings.applyPosition({\n          phase: DraggableApplyPositionPhase.EndAlign,\n          draggable: this,\n          drag,\n          item,\n        });\n      }\n    }\n\n    // Emit end event.\n    this._emit(DraggableEventType.End, drag.endEvent);\n\n    // Call onEnd callback.\n    this.settings.onEnd?.(drag, this);\n\n    // Reset drag data.\n    (this as Writeable<this>).drag = null;\n  }\n\n  align(instant = false) {\n    if (!this.drag || this.drag.isEnded) return;\n    if (instant || this.settings.sensorProcessingMode === DraggableSensorProcessingMode.Immediate) {\n      this._prepareAlign();\n      this._applyAlign();\n    } else {\n      ticker.once(tickerPhases.read, this._prepareAlign, this._alignId);\n      ticker.once(tickerPhases.write, this._applyAlign, this._alignId);\n    }\n  }\n\n  getClientRect() {\n    const { drag, settings } = this;\n    if (!drag) return null;\n    return settings.computeClientRect?.({ draggable: this, drag }) || null;\n  }\n\n  updateSettings(options: Partial<this['settings']>) {\n    (this as Writeable<this>).settings = this._parseSettings(options, this.settings);\n  }\n\n  use<SS extends S, PP extends P>(plugin: (draggable: this) => Draggable<SS, PP>) {\n    return plugin(this);\n  }\n\n  destroy() {\n    if (this.isDestroyed) return;\n    (this as Writeable<this>).isDestroyed = true;\n\n    this.stop();\n\n    this._sensorData.forEach(({ onMove, onEnd }, sensor) => {\n      sensor.off(SensorEventType.Start, onMove);\n      sensor.off(SensorEventType.Move, onMove);\n      sensor.off(SensorEventType.Cancel, onEnd);\n      sensor.off(SensorEventType.End, onEnd);\n      sensor.off(SensorEventType.Destroy, onEnd);\n    });\n\n    this._sensorData.clear();\n\n    this._emit(DraggableEventType.Destroy);\n\n    this.settings.onDestroy?.(this);\n\n    this._emitter.off();\n  }\n}\n"],"mappings":"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"}