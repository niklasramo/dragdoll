import{ticker as e,tickerPhases as t}from"./ticker-ep3c22TT.js";import{CollisionDetector as n}from"./collision-detector-C_qir_i0.js";import{SensorEventType as r}from"./sensor-C-EBcfly.js";import{DraggableEventType as i}from"./draggable-CPxcoDV9.js";import{DroppableEventType as a}from"./droppable-BW9Ygu-q.js";import{Emitter as o}from"eventti";var s=function(e){return e[e.Idle=0]=`Idle`,e[e.Computing=1]=`Computing`,e[e.Computed=2]=`Computed`,e[e.Emitting=3]=`Emitting`,e}(s||{});const c={capture:!0,passive:!0},l={Start:`start`,Move:`move`,Enter:`enter`,Leave:`leave`,Collide:`collide`,End:`end`,AddDraggables:`addDraggables`,RemoveDraggables:`removeDraggables`,AddDroppables:`addDroppables`,RemoveDroppables:`removeDroppables`,Destroy:`destroy`};var u=class{constructor(r={}){this._onScroll=()=>{this._drags.size!==0&&(e.once(t.read,()=>{this.updateDroppableClientRects()},this._listenerId),this.detectCollisions())};let{collisionDetector:i}=r;this.draggables=new Map,this.droppables=new Map,this.isDestroyed=!1,this._drags=new Map,this._listenerId=Symbol(),this._emitter=new o,this._onScroll=this._onScroll.bind(this),this._collisionDetector=i?i(this):new n(this)}get drags(){return this._drags}_isMatch(e,t){let n=typeof t.accept==`function`?t.accept(e):t.accept.includes(e.settings.group);if(n&&e.drag){let n=e.drag.items;for(let e=0;e<n.length;e++)if(n[e].element===t.element)return!1}return n}_getTargets(e){let t=this._drags.get(e);if(t?._targets)return t._targets;let n=new Map;for(let t of this.droppables.values())this._isMatch(e,t)&&n.set(t.id,t);return t&&(t._targets=n),n}_onDragPrepareStart(e){this.draggables.has(e.id)&&(this._drags.get(e)||(this._drags.set(e,{isEnded:!1,data:{},_targets:null,_cd:{phase:s.Idle,tickerId:Symbol(),targets:new Map,collisions:[],contacts:new Set,prevContacts:new Set,addedContacts:new Set,persistedContacts:new Set}}),this._drags.size===1&&this.updateDroppableClientRects(),this._computeCollisions(e),this._drags.size===1&&window.addEventListener(`scroll`,this._onScroll,c)))}_onDragStart(e){let t=this._drags.get(e);if(!(!t||t.isEnded)){if(this._emitter.listenerCount(l.Start)){let t=this._getTargets(e);this._emitter.emit(l.Start,{draggable:e,targets:t})}this._emitCollisions(e)}}_onDragPrepareMove(e){let t=this._drags.get(e);!t||t.isEnded||this._computeCollisions(e)}_onDragMove(e){let t=this._drags.get(e);if(!(!t||t.isEnded)){if(this._emitter.listenerCount(l.Move)){let t=this._getTargets(e);this._emitter.emit(l.Move,{draggable:e,targets:t})}this._emitCollisions(e)}}_onDragEnd(e){this._stopDrag(e)}_onDragCancel(e){this._stopDrag(e,!0)}_onDraggableDestroy(e){this.removeDraggables([e])}_stopDrag(e,t=!1){let n=this._drags.get(e);if(!n||n.isEnded)return!1;n.isEnded=!0;let r=n._cd.phase===s.Emitting;r||(this._computeCollisions(e,!0),this._emitCollisions(e,!0));let{targets:i,collisions:a,contacts:o}=n._cd;return this._emitter.listenerCount(l.End)&&this._emitter.emit(l.End,{canceled:t,draggable:e,targets:i,collisions:a,contacts:o}),r?(window.queueMicrotask(()=>{this._finalizeStopDrag(e)}),!0):(this._finalizeStopDrag(e),!1)}_finalizeStopDrag(n){let r=this._drags.get(n);!r||!r.isEnded||(this._drags.delete(n),this._collisionDetector.removeCollisionDataPool(n),e.off(t.read,r._cd.tickerId),e.off(t.write,r._cd.tickerId),this._drags.size||(e.off(t.read,this._listenerId),window.removeEventListener(`scroll`,this._onScroll,c)))}_computeCollisions(e,t=!1){let n=this._drags.get(e);if(!n||!t&&n.isEnded)return;let r=n._cd;switch(r.phase){case s.Computing:throw Error(`Collisions are being computed.`);case s.Emitting:throw Error(`Collisions are being emitted.`);default:break}r.phase=s.Computing,r.targets=this._getTargets(e),this._collisionDetector.detectCollisions(e,r.targets,r.collisions),r.phase=s.Computed}_emitCollisions(e,t=!1){let n=this._drags.get(e);if(!n||!t&&n.isEnded)return;let r=n._cd;switch(r.phase){case s.Computing:throw Error(`Collisions are being computed.`);case s.Emitting:throw Error(`Collisions are being emitted.`);case s.Idle:return;default:break}r.phase=s.Emitting;let i=this._emitter,a=r.collisions,o=r.targets,c=r.addedContacts,u=r.persistedContacts,d=r.contacts,f=r.prevContacts;r.prevContacts=d,r.contacts=f;let p=d;c.clear(),u.clear(),f.clear();for(let e of a){let t=o.get(e.droppableId);t&&(f.add(t),d.has(t)?(u.add(t),d.delete(t)):c.add(t))}d.size&&i.listenerCount(l.Leave)&&i.emit(l.Leave,{draggable:e,targets:o,collisions:a,contacts:f,removedContacts:p}),c.size&&i.listenerCount(l.Enter)&&i.emit(l.Enter,{draggable:e,targets:o,collisions:a,contacts:f,addedContacts:c}),i.listenerCount(l.Collide)&&(f.size||p.size)&&i.emit(l.Collide,{draggable:e,targets:o,collisions:a,contacts:f,addedContacts:c,removedContacts:p,persistedContacts:u}),c.clear(),u.clear(),d.clear(),r.phase=s.Idle}on(e,t,n){return this._emitter.on(e,t,n)}off(e,t){this._emitter.off(e,t)}updateDroppableClientRects(){for(let e of this.droppables.values())e.updateClientRect()}clearTargets(e){if(e){let t=this._drags.get(e);t&&(t._targets=null)}else for(let e of this._drags.values())e._targets=null}detectCollisions(n){if(!this.isDestroyed)if(n){let r=this._drags.get(n);if(!r||r.isEnded)return;e.once(t.read,()=>this._computeCollisions(n),r._cd.tickerId),e.once(t.write,()=>this._emitCollisions(n),r._cd.tickerId)}else for(let[n,r]of this._drags)r.isEnded||(e.once(t.read,()=>this._computeCollisions(n),r._cd.tickerId),e.once(t.write,()=>this._emitCollisions(n),r._cd.tickerId))}addDraggables(e){if(this.isDestroyed)return;let t=new Set;for(let n of e)this.draggables.has(n.id)||(t.add(n),this.draggables.set(n.id,n),n.on(i.PrepareStart,()=>{this._onDragPrepareStart(n)},this._listenerId),n.on(i.Start,()=>{this._onDragStart(n)},this._listenerId),n.on(i.PrepareMove,()=>{this._onDragPrepareMove(n)},this._listenerId),n.on(i.Move,()=>{this._onDragMove(n)},this._listenerId),n.on(i.End,e=>{e?.type===r.End?this._onDragEnd(n):e?.type===r.Cancel&&this._onDragCancel(n)},this._listenerId),n.on(i.Destroy,()=>{this._onDraggableDestroy(n)},this._listenerId));if(t.size){this._emitter.listenerCount(l.AddDraggables)&&this._emitter.emit(l.AddDraggables,{draggables:t});for(let e of t)if(!this.isDestroyed&&e.drag&&!e.drag.isEnded){let t=e._startPhase;t>=2&&this._onDragPrepareStart(e),t>=4&&this._onDragStart(e)}}}removeDraggables(e){if(this.isDestroyed)return;let t=new Set;for(let n of e)this.draggables.has(n.id)&&(t.add(n),this.draggables.delete(n.id),n.off(i.PrepareStart,this._listenerId),n.off(i.Start,this._listenerId),n.off(i.PrepareMove,this._listenerId),n.off(i.Move,this._listenerId),n.off(i.End,this._listenerId),n.off(i.Destroy,this._listenerId));for(let e of t)this._stopDrag(e,!0);this._emitter.listenerCount(l.RemoveDraggables)&&this._emitter.emit(l.RemoveDraggables,{draggables:t})}addDroppables(e){if(this.isDestroyed)return;let t=new Set;for(let n of e)this.droppables.has(n.id)||(t.add(n),this.droppables.set(n.id,n),n.on(a.Destroy,()=>{this.removeDroppables([n])},this._listenerId),this._drags.forEach(({_targets:e},t)=>{e&&this._isMatch(t,n)&&(e.set(n.id,n),this.detectCollisions(t))}));t.size&&this._emitter.listenerCount(l.AddDroppables)&&this._emitter.emit(l.AddDroppables,{droppables:t})}removeDroppables(e){if(this.isDestroyed)return;let t=new Set;for(let n of e)this.droppables.has(n.id)&&(this.droppables.delete(n.id),t.add(n),n.off(a.Destroy,this._listenerId),this._drags.forEach(({_targets:e},t)=>{e&&e.has(n.id)&&(e.delete(n.id),this.detectCollisions(t))}));t.size&&this._emitter.listenerCount(l.RemoveDroppables)&&this._emitter.emit(l.RemoveDroppables,{droppables:t})}destroy(){if(this.isDestroyed)return;this.isDestroyed=!0,this.draggables.forEach(e=>{e.off(i.PrepareStart,this._listenerId),e.off(i.Start,this._listenerId),e.off(i.PrepareMove,this._listenerId),e.off(i.Move,this._listenerId),e.off(i.End,this._listenerId),e.off(i.Destroy,this._listenerId)}),this.droppables.forEach(e=>{e.off(a.Destroy,this._listenerId)});let e=this._drags.keys();for(let t of e)this._stopDrag(t,!0);this._emitter.emit(l.Destroy),this._emitter.off(),this._collisionDetector.destroy(),this.draggables.clear(),this.droppables.clear()}};export{u as DndContext,l as DndContextEventType};
//# sourceMappingURL=dnd-context-8vlFXUrJ.js.map