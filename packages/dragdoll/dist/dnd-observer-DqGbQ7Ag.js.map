{"version":3,"file":"dnd-observer-DqGbQ7Ag.js","names":[],"sources":["../src/dnd-observer/dnd-observer.ts"],"sourcesContent":["import { Emitter } from 'eventti';\nimport type { AnyDraggable, Draggable, DraggableId } from '../draggable/draggable.js';\nimport { DraggableEventType } from '../draggable/draggable.js';\nimport type { Droppable, DroppableId } from '../droppable/droppable.js';\nimport { DroppableEventType } from '../droppable/droppable.js';\nimport type { SensorEventListenerId } from '../sensors/sensor.js';\nimport { SensorEventType } from '../sensors/sensor.js';\nimport { ticker, tickerPhases } from '../singletons/ticker.js';\nimport type { Writeable } from '../types.js';\nimport type { CollisionData } from './collision-detector.js';\nimport { CollisionDetector } from './collision-detector.js';\n\nenum CollisionDetectionPhase {\n  Idle = 0,\n  Computing = 1,\n  Computed = 2,\n  Emitting = 3,\n}\n\nconst SCROLL_LISTENER_OPTIONS = { capture: true, passive: true };\n\ninterface DndObserverInternalDragData<T extends CollisionData = CollisionData> {\n  isEnded: boolean;\n  data: { [key: string]: any };\n  _targets: Map<DroppableId, Droppable> | null;\n  _cd: {\n    phase: CollisionDetectionPhase;\n    tickerId: symbol;\n    targets: Map<DroppableId, Droppable>;\n    collisions: T[];\n    contacts: Set<Droppable>;\n    prevContacts: Set<Droppable>;\n    addedContacts: Set<Droppable>;\n    persistedContacts: Set<Droppable>;\n  };\n}\n\nexport const DndObserverEventType = {\n  Start: 'start',\n  Move: 'move',\n  Enter: 'enter',\n  Leave: 'leave',\n  Collide: 'collide',\n  End: 'end',\n  AddDraggables: 'addDraggables',\n  RemoveDraggables: 'removeDraggables',\n  AddDroppables: 'addDroppables',\n  RemoveDroppables: 'removeDroppables',\n  Destroy: 'destroy',\n} as const;\n\nexport type DndObserverEventType = (typeof DndObserverEventType)[keyof typeof DndObserverEventType];\n\nexport interface DndObserverEventCallbacks<T extends CollisionData = CollisionData> {\n  [DndObserverEventType.Start]: (data: {\n    draggable: AnyDraggable;\n    targets: ReadonlyMap<DroppableId, Droppable>;\n  }) => void;\n  [DndObserverEventType.Move]: (data: {\n    draggable: AnyDraggable;\n    targets: ReadonlyMap<DroppableId, Droppable>;\n  }) => void;\n  [DndObserverEventType.Enter]: (data: {\n    draggable: AnyDraggable;\n    targets: ReadonlyMap<DroppableId, Droppable>;\n    collisions: ReadonlyArray<T>;\n    contacts: ReadonlySet<Droppable>;\n    addedContacts: ReadonlySet<Droppable>;\n  }) => void;\n  [DndObserverEventType.Leave]: (data: {\n    draggable: AnyDraggable;\n    targets: ReadonlyMap<DroppableId, Droppable>;\n    collisions: ReadonlyArray<T>;\n    contacts: ReadonlySet<Droppable>;\n    removedContacts: ReadonlySet<Droppable>;\n  }) => void;\n  [DndObserverEventType.Collide]: (data: {\n    draggable: AnyDraggable;\n    targets: ReadonlyMap<DroppableId, Droppable>;\n    collisions: ReadonlyArray<T>;\n    contacts: ReadonlySet<Droppable>;\n    addedContacts: ReadonlySet<Droppable>;\n    removedContacts: ReadonlySet<Droppable>;\n    persistedContacts: ReadonlySet<Droppable>;\n  }) => void;\n  [DndObserverEventType.End]: (data: {\n    canceled: boolean;\n    draggable: AnyDraggable;\n    targets: ReadonlyMap<DroppableId, Droppable>;\n    collisions: ReadonlyArray<T>;\n    contacts: ReadonlySet<Droppable>;\n  }) => void;\n  [DndObserverEventType.AddDraggables]: (data: { draggables: ReadonlySet<AnyDraggable> }) => void;\n  [DndObserverEventType.RemoveDraggables]: (data: {\n    draggables: ReadonlySet<AnyDraggable>;\n  }) => void;\n  [DndObserverEventType.AddDroppables]: (data: { droppables: ReadonlySet<Droppable> }) => void;\n  [DndObserverEventType.RemoveDroppables]: (data: { droppables: ReadonlySet<Droppable> }) => void;\n  [DndObserverEventType.Destroy]: () => void;\n}\n\n// Public drag data exposed to consumers.\n// Top-level is read-only. Nested `data` object contents are mutable.\nexport type DndObserverDragData = Readonly<{\n  isEnded: boolean;\n  data: { [key: string]: any };\n}>;\n\nexport interface DndObserverOptions<T extends CollisionData = CollisionData> {\n  collisionDetector?: (dndObserver: DndObserver<T>) => CollisionDetector<T>;\n}\n\nexport class DndObserver<T extends CollisionData = CollisionData> {\n  // Keep track of all added draggables and droppables.\n  readonly draggables: ReadonlyMap<DraggableId, AnyDraggable>;\n  readonly droppables: ReadonlyMap<DroppableId, Droppable>;\n  readonly isDestroyed: boolean;\n\n  // Keep track of all active draggables and their drag data.\n  protected _drags: Map<AnyDraggable, DndObserverInternalDragData<T>>;\n\n  // Used for all all event listeners and scroll ticker listener.\n  protected _listenerId: symbol;\n\n  // The current collision detection function.\n  protected _collisionDetector: CollisionDetector<T>;\n\n  // The internal event emitter.\n  protected _emitter: Emitter<{\n    [K in keyof DndObserverEventCallbacks<T>]: DndObserverEventCallbacks<T>[K];\n  }>;\n\n  constructor(options: DndObserverOptions<T> = {}) {\n    const { collisionDetector } = options;\n\n    this.draggables = new Map();\n    this.droppables = new Map();\n    this.isDestroyed = false;\n    this._drags = new Map();\n    this._listenerId = Symbol();\n    this._emitter = new Emitter();\n\n    // Bind methods.\n    this._onScroll = this._onScroll.bind(this);\n\n    // Create the collision detector.\n    this._collisionDetector = collisionDetector\n      ? collisionDetector(this)\n      : new CollisionDetector<T>(this);\n  }\n\n  get drags() {\n    return this._drags as ReadonlyMap<AnyDraggable, DndObserverDragData>;\n  }\n\n  protected _isMatch(draggable: AnyDraggable, droppable: Droppable) {\n    let isMatch = false;\n\n    // If the droppable has an accept function, use it to determine the match.\n    if (typeof droppable.accept === 'function') {\n      isMatch = droppable.accept(draggable);\n    }\n    // Otherwise, use the groups to determine the match.\n    else {\n      const draggableSet = draggable.settings.dndGroups;\n      const droppableSet = droppable.accept;\n\n      // Make sure that there are groups to match.\n      if (!draggableSet || draggableSet.size === 0 || droppableSet.size === 0) {\n        return false;\n      }\n\n      // Find out which set is smaller.\n      const isDroppableSetSmaller = droppableSet.size < draggableSet.size;\n      const smallerSet = isDroppableSetSmaller ? droppableSet : draggableSet;\n      const largerSet = isDroppableSetSmaller ? draggableSet : droppableSet;\n\n      // Loop through the smaller set and check if any of the groups match the\n      // larger set.\n      for (const group of smallerSet) {\n        if (largerSet.has(group)) {\n          isMatch = true;\n          break;\n        }\n      }\n    }\n\n    // Make sure that none of the draggable's elements contain the droppable's\n    // element. If we allowed this the draggable would _probably_ be constantly\n    // colliding with this droppable, which is probably not what is wanted in\n    // most cases. If the user _really_ wants to allow this they can always\n    // override this method.\n    if (isMatch && draggable.drag) {\n      const items = draggable.drag.items;\n      for (let i = 0; i < items.length; i++) {\n        if (items[i].element.contains(droppable.element)) {\n          return false;\n        }\n      }\n    }\n\n    return isMatch;\n  }\n\n  protected _getTargets(draggable: AnyDraggable) {\n    const drag = this._drags.get(draggable);\n    if (drag?._targets) return drag._targets;\n\n    const targets = new Map<DroppableId, Droppable>();\n    for (const droppable of this.droppables.values()) {\n      if (this._isMatch(draggable, droppable)) {\n        targets.set(droppable.id, droppable);\n      }\n    }\n\n    if (drag) drag._targets = targets;\n\n    return targets;\n  }\n\n  protected _onDragPrepareStart(draggable: AnyDraggable) {\n    // Make sure the draggable is registered.\n    if (!this.draggables.has(draggable.id)) return;\n\n    // Make sure the draggable is not being dragged, yet.\n    if (this._drags.get(draggable)) return;\n\n    // Set the initial drag data for the draggable.\n    this._drags.set(draggable, {\n      isEnded: false,\n      data: {},\n      _targets: null,\n      _cd: {\n        phase: CollisionDetectionPhase.Idle,\n        tickerId: Symbol(),\n        targets: new Map(),\n        collisions: [],\n        contacts: new Set(),\n        prevContacts: new Set(),\n        addedContacts: new Set(),\n        persistedContacts: new Set(),\n      },\n    });\n\n    // Recompute the droppable client rects if this is the first dragged\n    // draggable. We only want to do this once per \"drag process\" and that\n    // starts when a draggable starts dragging while there are no other dragged\n    // draggables, and stops when a draggable ends dragging while there are no\n    // other dragged draggables.\n    if (this._drags.size === 1) {\n      this.updateDroppableClientRects();\n    }\n\n    // Run collision detection for the draggable. Note that we just compute the\n    // collisions here, but don't _yet_ emit the collisions events, we do that\n    // part after emitting the start event.\n    this._computeCollisions(draggable);\n\n    // Add scroll listener if this is the first dragged draggable.\n    if (this._drags.size === 1) {\n      window.addEventListener('scroll', this._onScroll, SCROLL_LISTENER_OPTIONS);\n    }\n  }\n\n  protected _onDragStart(draggable: AnyDraggable) {\n    // Make sure the draggable is being dragged.\n    const drag = this._drags.get(draggable);\n    if (!drag || drag.isEnded) return;\n\n    // Emit \"start\" event.\n    if (this._emitter.listenerCount(DndObserverEventType.Start)) {\n      const targets = this._getTargets(draggable);\n      this._emitter.emit(DndObserverEventType.Start, {\n        draggable,\n        targets,\n      });\n    }\n\n    // Lastly, emit collisions events.\n    this._emitCollisions(draggable);\n  }\n\n  protected _onDragPrepareMove(draggable: AnyDraggable) {\n    // Make sure the draggable is being dragged.\n    const drag = this._drags.get(draggable);\n    if (!drag || drag.isEnded) return;\n\n    // Run collision detection.\n    this._computeCollisions(draggable);\n  }\n\n  protected _onDragMove(draggable: AnyDraggable) {\n    // Make sure the draggable is being dragged.\n    const drag = this._drags.get(draggable);\n    if (!drag || drag.isEnded) return;\n\n    // Emit \"move\" event.\n    if (this._emitter.listenerCount(DndObserverEventType.Move)) {\n      const targets = this._getTargets(draggable);\n      this._emitter.emit(DndObserverEventType.Move, {\n        draggable,\n        targets,\n      });\n    }\n\n    // Lastly, emit collisions events.\n    this._emitCollisions(draggable);\n  }\n\n  protected _onDragEnd(draggable: AnyDraggable) {\n    this._stopDrag(draggable);\n  }\n\n  protected _onDragCancel(draggable: AnyDraggable) {\n    this._stopDrag(draggable, true);\n  }\n\n  protected _onDraggableDestroy(draggable: AnyDraggable) {\n    this.removeDraggables([draggable]);\n  }\n\n  protected _onScroll = () => {\n    if (this._drags.size === 0) return;\n\n    // Queue droppable client rects update.\n    ticker.once(\n      tickerPhases.read,\n      () => {\n        this.updateDroppableClientRects();\n      },\n      this._listenerId,\n    );\n\n    // Queue collision detection for all active draggables.\n    this.detectCollisions();\n  };\n\n  // Returns true if the final cleanup was queued to a microtask.\n  protected _stopDrag(draggable: AnyDraggable, canceled = false) {\n    // Make sure the draggable is being dragged.\n    const drag = this._drags.get(draggable);\n    if (!drag || drag.isEnded) return;\n\n    // Throw an error if collisions are being emitted. This guards against user\n    // manually stopping dragging while collisions are being emitted, in one of\n    // the collision event callbacks. Doing that will result the end event\n    // being potentially emitted before all the collision event callbacks are\n    // executed, which is confusing behavior. We want to guarantee the end event\n    // to be the last event to be emitted in the dnd process.\n    if (drag._cd.phase === CollisionDetectionPhase.Emitting) {\n      throw new Error('Cannot stop dragging while collisions are being emitted.');\n    }\n\n    // Mark the drag as ended.\n    drag.isEnded = true;\n\n    // Do a final collision detection pass before emitting the drop event to\n    // ensure we have the most up to date collisions data.\n    this._computeCollisions(draggable, true);\n    this._emitCollisions(draggable, true);\n\n    // Get the targets, collisions and colliding targets from the last collision\n    // detection pass.\n    const { targets, collisions, contacts } = drag._cd;\n\n    // Emit \"end\" event.\n    if (this._emitter.listenerCount(DndObserverEventType.End)) {\n      this._emitter.emit(DndObserverEventType.End, {\n        canceled,\n        draggable,\n        targets,\n        collisions,\n        contacts,\n      });\n    }\n\n    // Remove the drag data.\n    this._drags.delete(draggable);\n\n    // Free up the collision data pool from the collision detector.\n    this._collisionDetector['_removeCollisionDataArena'](draggable);\n\n    // Clear the queued detect collisions callbacks.\n    ticker.off(tickerPhases.read, drag._cd.tickerId);\n    ticker.off(tickerPhases.write, drag._cd.tickerId);\n\n    // Remove scroll ticker and listener if this was the last dragged draggable.\n    if (!this._drags.size) {\n      ticker.off(tickerPhases.read, this._listenerId);\n      window.removeEventListener('scroll', this._onScroll, SCROLL_LISTENER_OPTIONS);\n    }\n  }\n\n  protected _computeCollisions(draggable: AnyDraggable, force = false) {\n    const drag = this._drags.get(draggable);\n    if (!drag || (!force && drag.isEnded)) return;\n\n    const cd = drag._cd;\n\n    // Throw an error if collisions are being computed or emitted.\n    switch (cd.phase) {\n      case CollisionDetectionPhase.Computing:\n        throw new Error('Collisions are being computed.');\n      case CollisionDetectionPhase.Emitting:\n        throw new Error('Collisions are being emitted.');\n      default:\n        break;\n    }\n\n    // Mark collision detection as computing.\n    cd.phase = CollisionDetectionPhase.Computing;\n\n    // Get the targets of the draggable and set them as the collision targets.\n    cd.targets = this._getTargets(draggable);\n\n    // NB: Running collision detection will mutate the collision data of the\n    // current collisions of the draggable (since we use object pool objects\n    // directly for memory efficiency), so if we need to compare the current and\n    // next collisions we need to cache the current collisions before running\n    // the detection. But, we don't need to do that now, we just care about the\n    // previous colliding droppables so this is fine.\n    this._collisionDetector.detectCollisions(draggable, cd.targets, cd.collisions);\n\n    // Mark collision detection as computed.\n    cd.phase = CollisionDetectionPhase.Computed;\n  }\n\n  protected _emitCollisions(draggable: AnyDraggable, force = false) {\n    const drag = this._drags.get(draggable);\n    if (!drag || (!force && drag.isEnded)) return;\n\n    const cd = drag._cd;\n\n    // Make sure we have computed the collisions.\n    switch (cd.phase) {\n      case CollisionDetectionPhase.Computing:\n        throw new Error('Collisions are being computed.');\n      case CollisionDetectionPhase.Emitting:\n        throw new Error('Collisions are being emitted.');\n      case CollisionDetectionPhase.Idle:\n        // Silently ignore if collisions have not been computed yet. This is\n        // a potential scenario, a valid one, but we should not throw an error\n        // here.\n        return;\n      default:\n        break;\n    }\n\n    // Mark collision detection as emitting.\n    cd.phase = CollisionDetectionPhase.Emitting;\n\n    const emitter = this._emitter;\n    const collisions = cd.collisions;\n    const targets = cd.targets;\n    const addedContacts = cd.addedContacts;\n    const persistedContacts = cd.persistedContacts;\n\n    // Swap pointers to the colliding droppables sets.\n    const prevContacts = cd.contacts;\n    const contacts = cd.prevContacts;\n    cd.prevContacts = prevContacts;\n    cd.contacts = contacts;\n\n    // Make removedContacts piggyback on prevContacts.\n    const removedContacts = prevContacts;\n\n    // Clear reusable sets.\n    addedContacts.clear();\n    persistedContacts.clear();\n    contacts.clear();\n\n    // Populate the colliding droppables set based on collisions and find out\n    // added, persisted and removed collisions (leftover from the previous\n    // collision phase).\n    for (const collision of collisions) {\n      const droppable = targets.get(collision.droppableId);\n      // NB: We should always have a droppable here since we compute the\n      // collisions with the targets of the draggable, but it's still good to\n      // be defensive here.\n      if (!droppable) continue;\n      contacts.add(droppable);\n      if (prevContacts.has(droppable)) {\n        persistedContacts.add(droppable);\n        // Let's remove the droppable from the previous colliding droppables set,\n        // this way the removed collisions will be the ones that are left in the\n        // previous colliding droppables set.\n        prevContacts.delete(droppable);\n      } else {\n        addedContacts.add(droppable);\n      }\n    }\n\n    // Emit \"leave\" events.\n    if (prevContacts.size && emitter.listenerCount(DndObserverEventType.Leave)) {\n      emitter.emit(DndObserverEventType.Leave, {\n        draggable,\n        targets,\n        collisions,\n        contacts,\n        removedContacts,\n      });\n    }\n\n    // Emit \"enter\" events.\n    if (addedContacts.size && emitter.listenerCount(DndObserverEventType.Enter)) {\n      emitter.emit(DndObserverEventType.Enter, {\n        draggable,\n        targets,\n        collisions,\n        contacts,\n        addedContacts,\n      });\n    }\n\n    // Emit \"collide\" events if we have any contacts or removed contacts.\n    if (\n      emitter.listenerCount(DndObserverEventType.Collide) &&\n      (contacts.size || removedContacts.size)\n    ) {\n      emitter.emit(DndObserverEventType.Collide, {\n        draggable,\n        targets,\n        collisions,\n        contacts,\n        addedContacts,\n        removedContacts,\n        persistedContacts,\n      });\n    }\n\n    // Clear reusable sets.\n    addedContacts.clear();\n    persistedContacts.clear();\n    prevContacts.clear();\n\n    // Mark collision detection as idle.\n    cd.phase = CollisionDetectionPhase.Idle;\n  }\n\n  on<K extends keyof DndObserverEventCallbacks<T>>(\n    type: K,\n    listener: DndObserverEventCallbacks<T>[K],\n    listenerId?: SensorEventListenerId,\n  ): SensorEventListenerId {\n    return this._emitter.on(type, listener, listenerId);\n  }\n\n  off<K extends keyof DndObserverEventCallbacks<T>>(\n    type: K,\n    listenerId: SensorEventListenerId,\n  ): void {\n    this._emitter.off(type, listenerId);\n  }\n\n  updateDroppableClientRects() {\n    for (const droppable of this.droppables.values()) {\n      droppable.updateClientRect();\n    }\n  }\n\n  clearTargets(draggable?: AnyDraggable) {\n    if (draggable) {\n      const drag = this._drags.get(draggable);\n      if (drag) drag._targets = null;\n    } else {\n      for (const drag of this._drags.values()) {\n        drag._targets = null;\n      }\n    }\n  }\n\n  detectCollisions(draggable?: AnyDraggable) {\n    if (this.isDestroyed) return;\n\n    if (draggable) {\n      const drag = this._drags.get(draggable);\n      if (!drag || drag.isEnded) return;\n      ticker.once(tickerPhases.read, () => this._computeCollisions(draggable), drag._cd.tickerId);\n      ticker.once(tickerPhases.write, () => this._emitCollisions(draggable), drag._cd.tickerId);\n    } else {\n      for (const [d, drag] of this._drags) {\n        if (drag.isEnded) continue;\n        ticker.once(tickerPhases.read, () => this._computeCollisions(d), drag._cd.tickerId);\n        ticker.once(tickerPhases.write, () => this._emitCollisions(d), drag._cd.tickerId);\n      }\n    }\n  }\n\n  addDraggables(draggables: AnyDraggable[] | Set<AnyDraggable>) {\n    if (this.isDestroyed) return;\n\n    const addedDraggables = new Set<AnyDraggable>();\n\n    for (const draggable of draggables as Set<Draggable>) {\n      if (this.draggables.has(draggable.id)) continue;\n\n      addedDraggables.add(draggable);\n\n      (this.draggables as Map<DraggableId, AnyDraggable>).set(draggable.id, draggable);\n\n      draggable.on(\n        DraggableEventType.PrepareStart,\n        () => {\n          this._onDragPrepareStart(draggable);\n        },\n        this._listenerId,\n      );\n\n      draggable.on(\n        DraggableEventType.Start,\n        () => {\n          this._onDragStart(draggable);\n        },\n        this._listenerId,\n      );\n\n      draggable.on(\n        DraggableEventType.PrepareMove,\n        () => {\n          this._onDragPrepareMove(draggable);\n        },\n        this._listenerId,\n      );\n\n      draggable.on(\n        DraggableEventType.Move,\n        () => {\n          this._onDragMove(draggable);\n        },\n        this._listenerId,\n      );\n\n      draggable.on(\n        DraggableEventType.End,\n        (drag) => {\n          // If the end event's type is \"end\", call the end callback.\n          if (drag.endEvent?.type === SensorEventType.End) {\n            this._onDragEnd(draggable);\n          }\n          // In other cases, call the cancel callback.\n          else {\n            this._onDragCancel(draggable);\n          }\n        },\n        this._listenerId,\n      );\n\n      draggable.on(\n        DraggableEventType.Destroy,\n        () => {\n          this._onDraggableDestroy(draggable);\n        },\n        this._listenerId,\n      );\n    }\n\n    // If no draggables were added, return.\n    if (!addedDraggables.size) return;\n\n    // Emit \"addDraggables\" event.\n    if (this._emitter.listenerCount(DndObserverEventType.AddDraggables)) {\n      this._emitter.emit(DndObserverEventType.AddDraggables, { draggables: addedDraggables });\n    }\n\n    // Start the drag process for the added draggables, if needed.\n    for (const draggable of addedDraggables) {\n      // If the draggable is already being dragged, start the drag process\n      // manually. Note that we are reading internal state of the draggable here\n      // (`_startPhase`) to avoid double starting the drag process. We need to\n      // be careful here and make sure to update this logic if we change the\n      // draggable's internal state logic.\n      if (!this.isDestroyed && draggable.drag && !draggable.drag.isEnded) {\n        const startPhase = draggable['_startPhase'];\n        if (startPhase >= 2) this._onDragPrepareStart(draggable);\n        if (startPhase >= 4) this._onDragStart(draggable);\n      }\n    }\n  }\n\n  removeDraggables(draggables: AnyDraggable[] | Set<AnyDraggable>) {\n    if (this.isDestroyed) return;\n\n    const removedDraggables = new Set<AnyDraggable>();\n\n    for (const draggable of draggables) {\n      if (!this.draggables.has(draggable.id)) continue;\n\n      removedDraggables.add(draggable);\n\n      // Remove draggable.\n      (this.draggables as Map<DraggableId, AnyDraggable>).delete(draggable.id);\n\n      // Unbind the event listeners.\n      draggable.off(DraggableEventType.PrepareStart, this._listenerId);\n      draggable.off(DraggableEventType.Start, this._listenerId);\n      draggable.off(DraggableEventType.PrepareMove, this._listenerId);\n      draggable.off(DraggableEventType.Move, this._listenerId);\n      draggable.off(DraggableEventType.End, this._listenerId);\n      draggable.off(DraggableEventType.Destroy, this._listenerId);\n    }\n\n    // Cancel the drag.\n    // NB: We need to do this after first removing the draggables from the\n    // registry to avoid calling removeDraggables more than once per draggable.\n    for (const draggable of removedDraggables) {\n      this._stopDrag(draggable, true);\n    }\n\n    // Emit \"removeDraggables\" event.\n    if (this._emitter.listenerCount(DndObserverEventType.RemoveDraggables)) {\n      this._emitter.emit(DndObserverEventType.RemoveDraggables, { draggables: removedDraggables });\n    }\n  }\n\n  addDroppables(droppables: Droppable[] | Set<Droppable>) {\n    if (this.isDestroyed) return;\n\n    const addedDroppables = new Set<Droppable>();\n\n    for (const droppable of droppables) {\n      // Make sure the droppable is not registered.\n      if (this.droppables.has(droppable.id)) continue;\n\n      // Add the droppable to the validated set of droppables.\n      addedDroppables.add(droppable);\n\n      // Add the droppable to the droppable map.\n      (this.droppables as Map<DroppableId, Droppable>).set(droppable.id, droppable);\n\n      // Bind the destroy event listener.\n      droppable.on(\n        DroppableEventType.Destroy,\n        () => {\n          this.removeDroppables([droppable]);\n        },\n        this._listenerId,\n      );\n\n      // Add the droppable to the targets of all currently dragged draggables,\n      // where the droppable is a valid target.\n      this._drags.forEach(({ _targets }, draggable) => {\n        if (_targets && this._isMatch(draggable, droppable)) {\n          _targets.set(droppable.id, droppable);\n          this.detectCollisions(draggable);\n        }\n      });\n    }\n\n    // Emit \"addDroppables\" event.\n    if (addedDroppables.size && this._emitter.listenerCount(DndObserverEventType.AddDroppables)) {\n      this._emitter.emit(DndObserverEventType.AddDroppables, { droppables: addedDroppables });\n    }\n  }\n\n  removeDroppables(droppables: Droppable[] | Set<Droppable>) {\n    if (this.isDestroyed) return;\n\n    const removedDroppables = new Set<Droppable>();\n\n    for (const droppable of droppables) {\n      // Make sure the droppable is registered.\n      if (!this.droppables.has(droppable.id)) continue;\n\n      // Remove the droppable from the droppables map.\n      (this.droppables as Map<DroppableId, Droppable>).delete(droppable.id);\n\n      // Add the droppable to the validated set of droppables.\n      removedDroppables.add(droppable);\n\n      // Unbind the destroy event listener.\n      droppable.off(DroppableEventType.Destroy, this._listenerId);\n\n      // Remove the droppable from the targets set of all dragged draggables and\n      // queue collision detection for them.\n      this._drags.forEach(({ _targets }, draggable) => {\n        if (_targets && _targets.has(droppable.id)) {\n          _targets.delete(droppable.id);\n          this.detectCollisions(draggable);\n        }\n      });\n    }\n\n    // Emit \"removeDroppables\" event.\n    if (\n      removedDroppables.size &&\n      this._emitter.listenerCount(DndObserverEventType.RemoveDroppables)\n    ) {\n      this._emitter.emit(DndObserverEventType.RemoveDroppables, { droppables: removedDroppables });\n    }\n  }\n\n  destroy() {\n    // Return early if the dnd observer is already destroyed.\n    if (this.isDestroyed) return;\n\n    // Throw an error if collisions are being emitted. If we allowed this we\n    // could not guarantee the correct order of events. We want the destroy\n    // event to be the last event to be emitted when destroying the dnd\n    // observer.\n    const drags = Array.from(this._drags.values());\n    if (drags.some((drag) => drag._cd.phase === CollisionDetectionPhase.Emitting)) {\n      throw new Error('Cannot destroy the DndObserver while collisions are being emitted.');\n    }\n\n    // Mark the dnd observer as destroyed.\n    (this as Writeable<typeof this>).isDestroyed = true;\n\n    // Unbind all draggable event listeners.\n    this.draggables.forEach((draggable) => {\n      draggable.off(DraggableEventType.PrepareStart, this._listenerId);\n      draggable.off(DraggableEventType.Start, this._listenerId);\n      draggable.off(DraggableEventType.PrepareMove, this._listenerId);\n      draggable.off(DraggableEventType.Move, this._listenerId);\n      draggable.off(DraggableEventType.End, this._listenerId);\n      draggable.off(DraggableEventType.Destroy, this._listenerId);\n    });\n\n    // Unbind all droppable event listeners.\n    this.droppables.forEach((droppable) => {\n      droppable.off(DroppableEventType.Destroy, this._listenerId);\n    });\n\n    // Cancel all active drags.\n    const activeDraggables = this._drags.keys();\n    for (const draggable of activeDraggables) {\n      this._stopDrag(draggable, true);\n    }\n\n    // Emit \"destroy\" event.\n    this._emitter.emit(DndObserverEventType.Destroy);\n\n    // Unbind all emitter listeners.\n    this._emitter.off();\n\n    // Destroy the collision detector.\n    this._collisionDetector.destroy();\n\n    // Clear the draggables and droppables.\n    (this.draggables as Map<DraggableId, AnyDraggable>).clear();\n    (this.droppables as Map<DroppableId, Droppable>).clear();\n  }\n}\n"],"mappings":"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"}