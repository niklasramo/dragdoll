{"version":3,"file":"advanced-collision-detector-BXyCbT9h.js","names":["cachedDraggableClipMaskRect: Rect | null","EMPTY_RECT: Rect","MAX_RECT: Rect","DRAGGABLE_CLIP_ANCESTORS: (Element | Window)[]","DROPPABLE_CLIP_ANCESTORS: (Element | Window)[]","DRAGGABLE_CLIP_CHAIN: (Element | Window)[]","DROPPABLE_CLIP_CHAIN: (Element | Window)[]","fccc: Element | Window","draggableClipMask","droppableClipMask"],"sources":["../src/utils/get-clip-ancestors.ts","../src/dnd-context/advanced-collision-detector.ts"],"sourcesContent":["import { getStyle } from './get-style.js';\nimport { isDocument } from './is-document.js';\n\nconst VISIBLE_OVERFLOW = 'visible';\n\n/**\n * Compute the element's clip ancestor elements.\n */\nexport function getClipAncestors(\n  element: Element | Document | null,\n  includeElement: boolean,\n  result: (Element | Window)[] = [],\n) {\n  let parent = includeElement ? element : element?.parentNode;\n\n  // Reset the result array.\n  result.length = 0;\n\n  while (parent && !isDocument(parent)) {\n    if (parent instanceof Element) {\n      const style = getStyle(parent);\n      // TODO: Account for clip value, which is special. We will need to\n      // provide offset values for the clip container in the result array.\n      // At the moment this logic does not account for senario where we have\n      // clip and visible overflow on the same element for different axes. And\n      // also it does not account for overflow-clip-margin property, which is\n      // a bit experimental atm.\n      if (!(style.overflowY === VISIBLE_OVERFLOW || style.overflowX === VISIBLE_OVERFLOW)) {\n        result.push(parent);\n      }\n      parent = parent.parentNode;\n    } else if (parent instanceof ShadowRoot) {\n      parent = parent.host;\n    } else {\n      parent = parent.parentNode;\n    }\n  }\n\n  // Always push window to the results (as last clip container element).\n  result.push(window);\n\n  return result;\n}\n","import type { Draggable } from '../draggable/draggable.js';\nimport type { Droppable } from '../droppable/droppable.js';\nimport type { Rect } from '../types.js';\nimport { createRect } from '../utils/create-rect.js';\nimport { getClipAncestors } from '../utils/get-clip-ancestors.js';\nimport { getIntersectionRect } from '../utils/get-intersection-rect.js';\nimport { getIntersectionScore } from '../utils/get-intersection-score.js';\nimport { getRect } from '../utils/get-rect.js';\nimport type { CollisionData } from './collision-detector.js';\nimport { CollisionDetector } from './collision-detector.js';\nimport type { DndContext } from './dnd-context.js';\n\ninterface DragState {\n  clipMaskKeyMap: Map<Droppable, Element | Window>;\n  clipMaskMap: Map<Element | Window, [Rect, Rect]>;\n  cacheDirty: boolean;\n}\n\nlet cachedDraggableClipMaskRect: Rect | null;\n\nconst EMPTY_RECT: Rect = createRect();\nconst MAX_RECT: Rect = {\n  width: Number.MAX_SAFE_INTEGER,\n  height: Number.MAX_SAFE_INTEGER,\n  x: Number.MAX_SAFE_INTEGER * -0.5,\n  y: Number.MAX_SAFE_INTEGER * -0.5,\n};\nconst DRAGGABLE_CLIP_ANCESTORS: (Element | Window)[] = [];\nconst DROPPABLE_CLIP_ANCESTORS: (Element | Window)[] = [];\nconst DRAGGABLE_CLIP_CHAIN: (Element | Window)[] = [];\nconst DROPPABLE_CLIP_CHAIN: (Element | Window)[] = [];\n\nfunction computeDraggableClipAncestors(draggable: Draggable<any>) {\n  if (!DRAGGABLE_CLIP_ANCESTORS.length) {\n    const dragContainer = draggable.drag?.items?.[0]?.dragContainer;\n    if (dragContainer) {\n      getClipAncestors(dragContainer, true, DRAGGABLE_CLIP_ANCESTORS);\n    } else {\n      DRAGGABLE_CLIP_ANCESTORS.push(window);\n    }\n  }\n}\n\nfunction computeDroppableClipAncestors(droppable: Droppable) {\n  if (!DROPPABLE_CLIP_ANCESTORS.length) {\n    getClipAncestors(droppable.element, false, DROPPABLE_CLIP_ANCESTORS);\n  }\n}\n\nfunction getRecursiveIntersectionRect(elements: (Element | Window)[], result: Rect = createRect()) {\n  // Initialize with first element or empty rect.\n  createRect(elements.length ? getRect([elements[0], 'padding'], window) : MAX_RECT, result);\n\n  // Compute intersection with remaining elements.\n  for (let i = 1; i < elements.length; i++) {\n    const el = elements[i];\n    const rect = getRect([el, 'padding'], window);\n    if (!getIntersectionRect(result, rect, result)) {\n      createRect(EMPTY_RECT, result);\n      break;\n    }\n  }\n\n  return result;\n}\n\nexport interface AdvancedCollisionData extends CollisionData {\n  draggableVisibleRect: Rect;\n  droppableVisibleRect: Rect;\n}\n\nexport class AdvancedCollisionDetector<\n  T extends AdvancedCollisionData = AdvancedCollisionData,\n> extends CollisionDetector<T> {\n  protected _dragStates: Map<Draggable<any>, DragState>;\n  protected _visibilityLogic: 'relative' | 'absolute';\n  protected _listenersAttached: boolean;\n  protected _clearCache: () => void;\n\n  constructor(dndContext: DndContext<T>, options?: { visibilityLogic: 'relative' | 'absolute' }) {\n    super(dndContext);\n    this._dragStates = new Map();\n    this._visibilityLogic = options?.visibilityLogic || 'relative';\n    this._listenersAttached = false;\n    this._clearCache = () => this.clearCache();\n  }\n\n  protected override _checkCollision(\n    draggable: Draggable<any>,\n    droppable: Droppable,\n    collisionData: T,\n  ) {\n    // Get the drag state.\n    const state = this._dragStates.get(draggable);\n    if (!state) return null;\n\n    // Get the draggable and droppable rects.\n    const draggableRect = draggable.getClientRect();\n    const droppableRect = droppable.getClientRect();\n    if (!draggableRect || !droppableRect) return null;\n\n    // Get the clip mask key.\n    let clipMaskKey = state.clipMaskKeyMap.get(droppable);\n\n    // If we don't have a clip mask key, compute it and also the clip masks if\n    // there is no entry yet for this clip mask key.\n    if (!clipMaskKey) {\n      const isRelativeLogic = this._visibilityLogic === 'relative';\n\n      // Reset temp data before computing (just a safety measure).\n      DROPPABLE_CLIP_ANCESTORS.length = 0;\n      DRAGGABLE_CLIP_CHAIN.length = 0;\n      DROPPABLE_CLIP_CHAIN.length = 0;\n\n      // Compute the droppable clip ancestors.\n      computeDroppableClipAncestors(droppable);\n\n      // Use the first clip container as the clip mask key.\n      clipMaskKey = DROPPABLE_CLIP_ANCESTORS[0] || window;\n\n      // Store the clip mask key.\n      state.clipMaskKeyMap.set(droppable, clipMaskKey);\n\n      // If there is no entry yet for this clip mask key, compute the clip\n      // masks.\n      if (!state.clipMaskMap.has(clipMaskKey)) {\n        computeDraggableClipAncestors(draggable);\n\n        // For relative visibility logic, we need to compute the clip chains up\n        // to the FCCC.\n        if (isRelativeLogic) {\n          // Find first common clip container (FCCC).\n          let fccc: Element | Window = window;\n          for (const droppableClipAncestor of DROPPABLE_CLIP_ANCESTORS) {\n            if (DRAGGABLE_CLIP_ANCESTORS.includes(droppableClipAncestor)) {\n              fccc = droppableClipAncestor;\n              break;\n            }\n          }\n\n          // Get draggable's clip container chain.\n          for (const draggableClipAncestor of DRAGGABLE_CLIP_ANCESTORS) {\n            if (draggableClipAncestor === fccc) break;\n            DRAGGABLE_CLIP_CHAIN.push(draggableClipAncestor);\n          }\n\n          // Get droppable's clip container chain.\n          for (const droppableClipAncestor of DROPPABLE_CLIP_ANCESTORS) {\n            if (droppableClipAncestor === fccc) break;\n            DROPPABLE_CLIP_CHAIN.push(droppableClipAncestor);\n          }\n        }\n        // For absolute visibility logic the clip chains are equal to the clip\n        // ancestors.\n        else {\n          DRAGGABLE_CLIP_CHAIN.push(...DRAGGABLE_CLIP_ANCESTORS);\n          DROPPABLE_CLIP_CHAIN.push(...DROPPABLE_CLIP_ANCESTORS);\n        }\n\n        // Compute clip masks.\n        const draggableClipMask =\n          isRelativeLogic || !cachedDraggableClipMaskRect\n            ? getRecursiveIntersectionRect(DRAGGABLE_CLIP_CHAIN)\n            : createRect(cachedDraggableClipMaskRect);\n        const droppableClipMask = getRecursiveIntersectionRect(DROPPABLE_CLIP_CHAIN);\n\n        // Cache the draggable clip mask rect for absolute visibility logic.\n        // Unlike with relative visibility logic, the draggable clip mask rect\n        // needs to be computed only once, not for each droppable.\n        if (!isRelativeLogic && !cachedDraggableClipMaskRect) {\n          cachedDraggableClipMaskRect = draggableClipMask;\n        }\n\n        // Cache the clip masks.\n        state.clipMaskMap.set(clipMaskKey, [draggableClipMask, droppableClipMask]);\n      }\n\n      // Reset temp data.\n      DROPPABLE_CLIP_ANCESTORS.length = 0;\n      DRAGGABLE_CLIP_CHAIN.length = 0;\n      DROPPABLE_CLIP_CHAIN.length = 0;\n    }\n\n    // Get the clip masks.\n    const [draggableClipMask, droppableClipMask] = state.clipMaskMap.get(clipMaskKey) || [];\n    if (!draggableClipMask || !droppableClipMask) return null;\n\n    // Compute the draggable visible rect.\n    if (\n      !getIntersectionRect(draggableRect, draggableClipMask, collisionData.draggableVisibleRect)\n    ) {\n      return null;\n    }\n\n    // Compute the droppable visible rect.\n    if (\n      !getIntersectionRect(droppableRect, droppableClipMask, collisionData.droppableVisibleRect)\n    ) {\n      return null;\n    }\n\n    // Compute the intersection rect.\n    if (\n      !getIntersectionRect(\n        collisionData.draggableVisibleRect,\n        collisionData.droppableVisibleRect,\n        collisionData.intersectionRect,\n      )\n    ) {\n      return null;\n    }\n\n    // Compute the intersection score.\n    const score = getIntersectionScore(\n      collisionData.draggableVisibleRect,\n      collisionData.droppableVisibleRect,\n      collisionData.intersectionRect,\n    );\n    if (score <= 0) return null;\n\n    // Set the collision data.\n    collisionData.droppableId = droppable.id;\n    createRect(droppableRect, collisionData.droppableRect);\n    createRect(draggableRect, collisionData.draggableRect);\n    collisionData.intersectionScore = score;\n\n    // Return the collision data.\n    return collisionData;\n  }\n\n  protected override _sortCollisions(_draggable: Draggable<any>, collisions: T[]) {\n    return collisions.sort((a, b) => {\n      const diff = b.intersectionScore - a.intersectionScore;\n      if (diff !== 0) return diff;\n\n      return (\n        a.droppableVisibleRect.width * a.droppableVisibleRect.height -\n        b.droppableVisibleRect.width * b.droppableVisibleRect.height\n      );\n    });\n  }\n\n  protected override _createCollisionData() {\n    const data = super._createCollisionData();\n    data.droppableVisibleRect = createRect();\n    data.draggableVisibleRect = createRect();\n    return data;\n  }\n\n  protected _getDragState(draggable: Draggable<any>) {\n    let state = this._dragStates.get(draggable);\n    if (state) return state;\n\n    // Create the state.\n    state = {\n      clipMaskKeyMap: new Map(),\n      clipMaskMap: new Map(),\n      cacheDirty: true,\n    };\n\n    // Store the state.\n    this._dragStates.set(draggable, state);\n\n    // Attach global listeners if needed.\n    if (!this._listenersAttached) {\n      window.addEventListener('scroll', this._clearCache, {\n        capture: true,\n        passive: true,\n      });\n      window.addEventListener('resize', this._clearCache, { passive: true });\n      this._listenersAttached = true;\n    }\n\n    return state;\n  }\n\n  // Create or get pool, making sure our drag state exists first.\n  override getCollisionDataPool(draggable: Draggable<any>) {\n    this._getDragState(draggable);\n    return super.getCollisionDataPool(draggable);\n  }\n\n  override removeCollisionDataPool(draggable: Draggable<any>) {\n    if (this._dragStates.delete(draggable)) {\n      if (this._dndContext.drags.size <= 0) {\n        if (this._listenersAttached) {\n          window.removeEventListener('scroll', this._clearCache, { capture: true });\n          window.removeEventListener('resize', this._clearCache);\n          this._listenersAttached = false;\n        }\n      }\n    }\n    super.removeCollisionDataPool(draggable);\n  }\n\n  override detectCollisions(\n    draggable: Draggable<any>,\n    targets: Map<Droppable['id'], Droppable>,\n    collisions: T[],\n  ) {\n    // Reset draggable clip ancestors before computing (just a safety measure).\n    DRAGGABLE_CLIP_ANCESTORS.length = 0;\n\n    // Reset cached draggable clip mask rect before computing (just a safety\n    // measure).\n    cachedDraggableClipMaskRect = null;\n\n    // Clear the clip masks maps if the cache is dirty.\n    const state = this._getDragState(draggable);\n    if (state.cacheDirty) {\n      state.clipMaskKeyMap.clear();\n      state.clipMaskMap.clear();\n      state.cacheDirty = false;\n    }\n\n    super.detectCollisions(draggable, targets, collisions);\n\n    // Reset draggable clip ancestors after computing.\n    DRAGGABLE_CLIP_ANCESTORS.length = 0;\n\n    // Reset draggable clip mask rect.\n    cachedDraggableClipMaskRect = null;\n  }\n\n  clearCache(draggable?: Draggable<any>) {\n    if (draggable) {\n      const state = this._dragStates.get(draggable);\n      if (state) state.cacheDirty = true;\n    } else {\n      this._dragStates.forEach((state) => {\n        state.cacheDirty = true;\n      });\n    }\n  }\n}\n"],"mappings":"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"}