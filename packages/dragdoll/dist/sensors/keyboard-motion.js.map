{"version":3,"file":"keyboard-motion.js","names":["keyboardMotionSensorDefaults: KeyboardMotionSensorSettings<any>"],"sources":["../../src/sensors/keyboard-motion-sensor.ts"],"sourcesContent":["import type { Point } from '../types.js';\nimport { BaseMotionSensor, BaseMotionSensorEvents } from './base-motion-sensor.js';\nimport type { Sensor } from './sensor.js';\nimport { SensorEventType } from './sensor.js';\n\nexport interface KeyboardMotionSensorSettings<\n  E extends KeyboardMotionSensorEvents = KeyboardMotionSensorEvents,\n> {\n  startKeys: string[];\n  moveLeftKeys: string[];\n  moveRightKeys: string[];\n  moveUpKeys: string[];\n  moveDownKeys: string[];\n  cancelKeys: string[];\n  endKeys: string[];\n  cancelOnBlur: boolean;\n  cancelOnVisibilityChange: boolean;\n  computeSpeed: (sensor: KeyboardMotionSensor<E>) => number;\n  startPredicate: (e: KeyboardEvent, sensor: KeyboardMotionSensor<E>) => Point | null | undefined;\n}\n\nexport interface KeyboardMotionSensorEvents extends BaseMotionSensorEvents {}\n\nconst KEY_TYPES = [\n  'start',\n  'cancel',\n  'end',\n  'moveLeft',\n  'moveRight',\n  'moveUp',\n  'moveDown',\n] as const;\n\nfunction getEarliestTimestamp(keys: Set<string>, timestamps: Map<string, number>) {\n  if (!keys.size || !timestamps.size) return Infinity;\n  let result = Infinity;\n  for (const key of keys) {\n    const timestamp = timestamps.get(key);\n    if (timestamp !== undefined && timestamp < result) {\n      result = timestamp;\n    }\n  }\n  return result;\n}\n\nexport const keyboardMotionSensorDefaults: KeyboardMotionSensorSettings<any> = {\n  startKeys: [' ', 'Enter'],\n  moveLeftKeys: ['ArrowLeft'],\n  moveRightKeys: ['ArrowRight'],\n  moveUpKeys: ['ArrowUp'],\n  moveDownKeys: ['ArrowDown'],\n  cancelKeys: ['Escape'],\n  endKeys: [' ', 'Enter'],\n  cancelOnBlur: true,\n  cancelOnVisibilityChange: true,\n  computeSpeed: () => 500,\n  startPredicate: (_e, sensor) => {\n    if (sensor.element && document.activeElement === sensor.element) {\n      const { left, top } = sensor.element.getBoundingClientRect();\n      return { x: left, y: top };\n    }\n    return null;\n  },\n} as const;\n\nexport class KeyboardMotionSensor<E extends KeyboardMotionSensorEvents = KeyboardMotionSensorEvents>\n  extends BaseMotionSensor<E>\n  implements Sensor<E>\n{\n  declare _events_type: E;\n  readonly element: Element | null;\n  protected _moveKeys: Set<string>;\n  protected _moveKeyTimestamps: Map<string, number>;\n  protected _startKeys: Set<string>;\n  protected _moveLeftKeys: Set<string>;\n  protected _moveRightKeys: Set<string>;\n  protected _moveUpKeys: Set<string>;\n  protected _moveDownKeys: Set<string>;\n  protected _cancelKeys: Set<string>;\n  protected _endKeys: Set<string>;\n  protected _cancelOnBlur: boolean;\n  protected _cancelOnVisibilityChange: boolean;\n  protected _computeSpeed: Exclude<KeyboardMotionSensorSettings<E>['computeSpeed'], undefined>;\n  protected _startPredicate: Exclude<KeyboardMotionSensorSettings<E>['startPredicate'], undefined>;\n\n  constructor(element: Element | null, options: Partial<KeyboardMotionSensorSettings<E>> = {}) {\n    super();\n\n    const {\n      startPredicate = keyboardMotionSensorDefaults.startPredicate,\n      computeSpeed = keyboardMotionSensorDefaults.computeSpeed,\n      cancelOnVisibilityChange = keyboardMotionSensorDefaults.cancelOnVisibilityChange,\n      cancelOnBlur = keyboardMotionSensorDefaults.cancelOnBlur,\n      startKeys = keyboardMotionSensorDefaults.startKeys,\n      moveLeftKeys = keyboardMotionSensorDefaults.moveLeftKeys,\n      moveRightKeys = keyboardMotionSensorDefaults.moveRightKeys,\n      moveUpKeys = keyboardMotionSensorDefaults.moveUpKeys,\n      moveDownKeys = keyboardMotionSensorDefaults.moveDownKeys,\n      cancelKeys = keyboardMotionSensorDefaults.cancelKeys,\n      endKeys = keyboardMotionSensorDefaults.endKeys,\n    } = options;\n\n    this.element = element;\n    this._startKeys = new Set(startKeys);\n    this._cancelKeys = new Set(cancelKeys);\n    this._endKeys = new Set(endKeys);\n    this._moveLeftKeys = new Set(moveLeftKeys);\n    this._moveRightKeys = new Set(moveRightKeys);\n    this._moveUpKeys = new Set(moveUpKeys);\n    this._moveDownKeys = new Set(moveDownKeys);\n    this._moveKeys = new Set([...moveLeftKeys, ...moveRightKeys, ...moveUpKeys, ...moveDownKeys]);\n    this._moveKeyTimestamps = new Map();\n    this._cancelOnBlur = cancelOnBlur;\n    this._cancelOnVisibilityChange = cancelOnVisibilityChange;\n    this._computeSpeed = computeSpeed;\n    this._startPredicate = startPredicate;\n\n    this._onKeyDown = this._onKeyDown.bind(this);\n    this._onKeyUp = this._onKeyUp.bind(this);\n    this._onTick = this._onTick.bind(this);\n    this._internalCancel = this._internalCancel.bind(this);\n    this._blurCancelHandler = this._blurCancelHandler.bind(this);\n\n    this.on('tick', this._onTick, this._onTick);\n    document.addEventListener('keydown', this._onKeyDown);\n    document.addEventListener('keyup', this._onKeyUp);\n    if (cancelOnBlur) {\n      element?.addEventListener('blur', this._blurCancelHandler);\n    }\n    if (cancelOnVisibilityChange) {\n      document.addEventListener('visibilitychange', this._internalCancel);\n    }\n  }\n\n  protected _end(data: E['end']) {\n    if (!this.drag) return;\n    this._moveKeyTimestamps.clear();\n    this._direction.x = 0;\n    this._direction.y = 0;\n    super._end(data);\n  }\n\n  protected _cancel(data: E['cancel']) {\n    if (!this.drag) return;\n    this._moveKeyTimestamps.clear();\n    this._direction.x = 0;\n    this._direction.y = 0;\n    super._cancel(data);\n  }\n\n  protected _internalCancel() {\n    this.cancel();\n  }\n\n  protected _blurCancelHandler() {\n    // If the Draggable has a container defined the dragged element will be\n    // appended to the container, which will cause the element to lose focus\n    // temporarily in some browsers (e.g. Chrome). Draggable will automatically\n    // restore the focus immediately after the element is appended, but the blur\n    // event will be triggered anyway. This is why we need to defer the cancel\n    // call to the next microtask, where we can check if the element is still\n    // focused.\n    queueMicrotask(() => {\n      if (document.activeElement !== this.element) {\n        this.cancel();\n      }\n    });\n  }\n\n  protected _updateDirection() {\n    const leftTime = getEarliestTimestamp(this._moveLeftKeys, this._moveKeyTimestamps);\n    const rightTime = getEarliestTimestamp(this._moveRightKeys, this._moveKeyTimestamps);\n    const upTime = getEarliestTimestamp(this._moveUpKeys, this._moveKeyTimestamps);\n    const downTime = getEarliestTimestamp(this._moveDownKeys, this._moveKeyTimestamps);\n\n    let x = leftTime === rightTime ? 0 : leftTime < rightTime ? -1 : 1;\n    let y = upTime === downTime ? 0 : upTime < downTime ? -1 : 1;\n\n    // If the direction is NE/NW/SE/SW we need to normalize the direction\n    // vector.\n    if (!(x === 0 || y === 0)) {\n      const normFactor = 1 / (Math.sqrt(x * x + y * y) || 1);\n      x *= normFactor;\n      y *= normFactor;\n    }\n\n    this._direction.x = x;\n    this._direction.y = y;\n  }\n\n  protected _onTick() {\n    this._speed = this._computeSpeed(this);\n  }\n\n  protected _onKeyUp(e: KeyboardEvent) {\n    if (this._moveKeyTimestamps.get(e.key)) {\n      this._moveKeyTimestamps.delete(e.key);\n      this._updateDirection();\n    }\n  }\n\n  protected _onKeyDown(e: KeyboardEvent) {\n    // Handle start.\n    if (!this.drag) {\n      if (this._startKeys.has(e.key)) {\n        const startPosition = this._startPredicate(e, this);\n        if (startPosition) {\n          e.preventDefault();\n          this._start({\n            type: SensorEventType.Start,\n            x: startPosition.x,\n            y: startPosition.y,\n          });\n        }\n      }\n      return;\n    }\n\n    // Handle cancel.\n    if (this._cancelKeys.has(e.key)) {\n      e.preventDefault();\n      this._internalCancel();\n      return;\n    }\n\n    // Handle end.\n    if (this._endKeys.has(e.key)) {\n      e.preventDefault();\n      this._end({\n        type: SensorEventType.End,\n        x: this.drag.x,\n        y: this.drag.y,\n      });\n      return;\n    }\n\n    // Handle move.\n    if (this._moveKeys.has(e.key)) {\n      e.preventDefault();\n      if (!this._moveKeyTimestamps.get(e.key)) {\n        this._moveKeyTimestamps.set(e.key, Date.now());\n        this._updateDirection();\n      }\n      return;\n    }\n  }\n\n  updateSettings(options: Partial<KeyboardMotionSensorSettings<E>> = {}) {\n    let moveKeysMayNeedUpdate = false;\n\n    const { cancelOnBlur, cancelOnVisibilityChange, startPredicate, computeSpeed } = options;\n\n    if (cancelOnBlur !== undefined && this._cancelOnBlur !== cancelOnBlur) {\n      this._cancelOnBlur = cancelOnBlur;\n      if (cancelOnBlur) {\n        this.element?.addEventListener('blur', this._blurCancelHandler);\n      } else {\n        this.element?.removeEventListener('blur', this._blurCancelHandler);\n      }\n    }\n\n    if (\n      cancelOnVisibilityChange !== undefined &&\n      this._cancelOnVisibilityChange !== cancelOnVisibilityChange\n    ) {\n      this._cancelOnVisibilityChange = cancelOnVisibilityChange;\n      if (cancelOnVisibilityChange) {\n        document.addEventListener('visibilitychange', this._internalCancel);\n      } else {\n        document.removeEventListener('visibilitychange', this._internalCancel);\n      }\n    }\n\n    if (startPredicate !== undefined) {\n      this._startPredicate = startPredicate;\n    }\n\n    if (computeSpeed !== undefined) {\n      this._computeSpeed = computeSpeed;\n    }\n\n    KEY_TYPES.forEach((keyType, index) => {\n      const name = `${keyType}Keys` as const;\n      const value = options[name];\n      if (value !== undefined) {\n        this[`_${name}`] = new Set(value);\n        if (index >= 3) moveKeysMayNeedUpdate = true;\n      }\n    });\n\n    if (moveKeysMayNeedUpdate) {\n      // Construct the next move keys array.\n      const nextMoveKeys = [\n        ...this._moveLeftKeys,\n        ...this._moveRightKeys,\n        ...this._moveUpKeys,\n        ...this._moveDownKeys,\n      ];\n\n      // Check if the next move keys are equal to the current ones.\n      const areMoveKeysEqual = [...this._moveKeys].every(\n        (key, index) => nextMoveKeys[index] === key,\n      );\n\n      // Update move keys if needed.\n      if (!areMoveKeysEqual) {\n        this._moveKeys = new Set(nextMoveKeys);\n        this._moveKeyTimestamps.clear();\n        this._updateDirection();\n      }\n    }\n  }\n\n  destroy() {\n    if (this.isDestroyed) return;\n    super.destroy();\n    this.off('tick', this._onTick);\n    document.removeEventListener('keydown', this._onKeyDown);\n    document.removeEventListener('keyup', this._onKeyUp);\n    if (this._cancelOnBlur) {\n      this.element?.removeEventListener('blur', this._blurCancelHandler);\n    }\n    if (this._cancelOnVisibilityChange) {\n      document.removeEventListener('visibilitychange', this._internalCancel);\n    }\n  }\n}\n"],"mappings":"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"}