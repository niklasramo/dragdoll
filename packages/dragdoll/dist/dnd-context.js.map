{"version":3,"file":"dnd-context.js","names":[],"sources":["../src/dnd-context/dnd-context.ts"],"sourcesContent":["import { Emitter, EventListenerId } from 'eventti';\nimport { Draggable, DraggableEventType, DraggableId } from '../draggable/draggable.js';\nimport { Droppable, DroppableEventType, DroppableId } from '../droppable/droppable.js';\nimport { SensorEventType } from '../sensors/sensor.js';\nimport { ticker, tickerPhases } from '../singletons/ticker.js';\nimport type { Writeable } from '../types.js';\nimport { CollisionData, CollisionDetector } from './collision-detector.js';\n\nenum CollisionDetectionPhase {\n  Idle = 0,\n  Computing = 1,\n  Computed = 2,\n  Emitting = 3,\n}\n\nconst SCROLL_LISTENER_OPTIONS = { capture: true, passive: true };\n\ninterface DndContextInternalDragData<T extends CollisionData = CollisionData> {\n  isEnded: boolean;\n  data: { [key: string]: any };\n  _targets: Map<DroppableId, Droppable> | null;\n  _cd: {\n    phase: CollisionDetectionPhase;\n    tickerId: symbol;\n    targets: Map<DroppableId, Droppable>;\n    collisions: T[];\n    contacts: Set<Droppable>;\n    prevContacts: Set<Droppable>;\n    addedContacts: Set<Droppable>;\n    persistedContacts: Set<Droppable>;\n  };\n}\n\nexport const DndContextEventType = {\n  Start: 'start',\n  Move: 'move',\n  Enter: 'enter',\n  Leave: 'leave',\n  Collide: 'collide',\n  End: 'end',\n  AddDraggables: 'addDraggables',\n  RemoveDraggables: 'removeDraggables',\n  AddDroppables: 'addDroppables',\n  RemoveDroppables: 'removeDroppables',\n  Destroy: 'destroy',\n} as const;\n\nexport type DndContextEventType = (typeof DndContextEventType)[keyof typeof DndContextEventType];\n\nexport interface DndContextEventCallbacks<T extends CollisionData = CollisionData> {\n  [DndContextEventType.Start]: (data: {\n    draggable: Draggable<any>;\n    targets: ReadonlyMap<DroppableId, Droppable>;\n  }) => void;\n  [DndContextEventType.Move]: (data: {\n    draggable: Draggable<any>;\n    targets: ReadonlyMap<DroppableId, Droppable>;\n  }) => void;\n  [DndContextEventType.Enter]: (data: {\n    draggable: Draggable<any>;\n    targets: ReadonlyMap<DroppableId, Droppable>;\n    collisions: ReadonlyArray<T>;\n    contacts: ReadonlySet<Droppable>;\n    addedContacts: ReadonlySet<Droppable>;\n  }) => void;\n  [DndContextEventType.Leave]: (data: {\n    draggable: Draggable<any>;\n    targets: ReadonlyMap<DroppableId, Droppable>;\n    collisions: ReadonlyArray<T>;\n    contacts: ReadonlySet<Droppable>;\n    removedContacts: ReadonlySet<Droppable>;\n  }) => void;\n  [DndContextEventType.Collide]: (data: {\n    draggable: Draggable<any>;\n    targets: ReadonlyMap<DroppableId, Droppable>;\n    collisions: ReadonlyArray<T>;\n    contacts: ReadonlySet<Droppable>;\n    addedContacts: ReadonlySet<Droppable>;\n    removedContacts: ReadonlySet<Droppable>;\n    persistedContacts: ReadonlySet<Droppable>;\n  }) => void;\n  [DndContextEventType.End]: (data: {\n    canceled: boolean;\n    draggable: Draggable<any>;\n    targets: ReadonlyMap<DroppableId, Droppable>;\n    collisions: ReadonlyArray<T>;\n    contacts: ReadonlySet<Droppable>;\n  }) => void;\n  [DndContextEventType.AddDraggables]: (data: { draggables: ReadonlySet<Draggable<any>> }) => void;\n  [DndContextEventType.RemoveDraggables]: (data: {\n    draggables: ReadonlySet<Draggable<any>>;\n  }) => void;\n  [DndContextEventType.AddDroppables]: (data: { droppables: ReadonlySet<Droppable> }) => void;\n  [DndContextEventType.RemoveDroppables]: (data: { droppables: ReadonlySet<Droppable> }) => void;\n  [DndContextEventType.Destroy]: () => void;\n}\n\n// Public drag data exposed to consumers.\n// Top-level is read-only; nested `data` object contents are mutable.\nexport type DndContextDragData = Readonly<{\n  isEnded: boolean;\n  data: { [key: string]: any };\n}>;\n\nexport interface DndContextOptions<T extends CollisionData = CollisionData> {\n  collisionDetector?: (dndContext: DndContext<T>) => CollisionDetector<T>;\n}\n\nexport class DndContext<T extends CollisionData = CollisionData> {\n  // Keep track of all added draggables and droppables.\n  readonly draggables: ReadonlyMap<DraggableId, Draggable<any>>;\n  readonly droppables: ReadonlyMap<DroppableId, Droppable>;\n  readonly isDestroyed: boolean;\n\n  // Keep track of all active draggables and their drag data.\n  protected _drags: Map<Draggable<any>, DndContextInternalDragData<T>>;\n\n  // Used for all all event listeners and scroll ticker listener.\n  protected _listenerId: symbol;\n\n  // The current collision detection function.\n  protected _collisionDetector: CollisionDetector<T>;\n\n  // The internal event emitter.\n  protected _emitter: Emitter<{\n    [K in keyof DndContextEventCallbacks<T>]: DndContextEventCallbacks<T>[K];\n  }>;\n\n  constructor(options: DndContextOptions<T> = {}) {\n    const { collisionDetector } = options;\n\n    this.draggables = new Map();\n    this.droppables = new Map();\n    this.isDestroyed = false;\n    this._drags = new Map();\n    this._listenerId = Symbol();\n    this._emitter = new Emitter();\n\n    // Bind methods.\n    this._onScroll = this._onScroll.bind(this);\n\n    // Create the collision detector.\n    this._collisionDetector = collisionDetector\n      ? collisionDetector(this)\n      : new CollisionDetector<T>(this);\n  }\n\n  get drags() {\n    return this._drags as ReadonlyMap<Draggable<any>, DndContextDragData>;\n  }\n\n  protected _isMatch(draggable: Draggable<any>, droppable: Droppable) {\n    const isMatch =\n      typeof droppable.accept === 'function'\n        ? droppable.accept(draggable)\n        : droppable.accept.includes(draggable.settings.group as any);\n\n    // Make sure that none of the draggable's elements match the droppable's\n    // element.\n    if (isMatch && draggable.drag) {\n      const items = draggable.drag.items;\n      for (let i = 0; i < items.length; i++) {\n        if (items[i].element === droppable.element) {\n          return false;\n        }\n      }\n    }\n\n    return isMatch;\n  }\n\n  protected _getTargets(draggable: Draggable<any>) {\n    const drag = this._drags.get(draggable);\n    if (drag?._targets) return drag._targets;\n\n    const targets = new Map<DroppableId, Droppable>();\n    for (const droppable of this.droppables.values()) {\n      if (this._isMatch(draggable, droppable)) {\n        targets.set(droppable.id, droppable);\n      }\n    }\n\n    if (drag) drag._targets = targets;\n\n    return targets;\n  }\n\n  protected _onDragPrepareStart(draggable: Draggable<any>) {\n    // Make sure the draggable is registered.\n    if (!this.draggables.has(draggable.id)) return;\n\n    // Make sure the draggable is not being dragged, yet.\n    if (this._drags.get(draggable)) return;\n\n    // Set the initial drag data for the draggable.\n    this._drags.set(draggable, {\n      isEnded: false,\n      data: {},\n      _targets: null,\n      _cd: {\n        phase: CollisionDetectionPhase.Idle,\n        tickerId: Symbol(),\n        targets: new Map(),\n        collisions: [],\n        contacts: new Set(),\n        prevContacts: new Set(),\n        addedContacts: new Set(),\n        persistedContacts: new Set(),\n      },\n    });\n\n    // Recompute the droppable client rects if this is the first dragged\n    // draggable. We only want to do this once per \"drag process\" and that\n    // starts when a draggable starts dragging while there are no other dragged\n    // draggables, and stops when a draggable ends dragging while there are no\n    // other dragged draggables.\n    if (this._drags.size === 1) {\n      this.updateDroppableClientRects();\n    }\n\n    // Run collision detection for the draggable. Note that we just compute the\n    // collisions here, but don't _yet_ emit the collisions events, we do that\n    // part after emitting the start event.\n    this._computeCollisions(draggable);\n\n    // Add scroll listener if this is the first dragged draggable.\n    if (this._drags.size === 1) {\n      window.addEventListener('scroll', this._onScroll, SCROLL_LISTENER_OPTIONS);\n    }\n  }\n\n  protected _onDragStart(draggable: Draggable<any>) {\n    // Make sure the draggable is being dragged.\n    const drag = this._drags.get(draggable);\n    if (!drag || drag.isEnded) return;\n\n    // Emit \"start\" event.\n    if (this._emitter.listenerCount(DndContextEventType.Start)) {\n      const targets = this._getTargets(draggable);\n      this._emitter.emit(DndContextEventType.Start, {\n        draggable,\n        targets,\n      });\n    }\n\n    // Lastly, emit collisions events.\n    this._emitCollisions(draggable);\n  }\n\n  protected _onDragPrepareMove(draggable: Draggable<any>) {\n    // Make sure the draggable is being dragged.\n    const drag = this._drags.get(draggable);\n    if (!drag || drag.isEnded) return;\n\n    // Run collision detection.\n    this._computeCollisions(draggable);\n  }\n\n  protected _onDragMove(draggable: Draggable<any>) {\n    // Make sure the draggable is being dragged.\n    const drag = this._drags.get(draggable);\n    if (!drag || drag.isEnded) return;\n\n    // Emit \"move\" event.\n    if (this._emitter.listenerCount(DndContextEventType.Move)) {\n      const targets = this._getTargets(draggable);\n      this._emitter.emit(DndContextEventType.Move, {\n        draggable,\n        targets,\n      });\n    }\n\n    // Lastly, emit collisions events.\n    this._emitCollisions(draggable);\n  }\n\n  protected _onDragEnd(draggable: Draggable<any>) {\n    this._stopDrag(draggable);\n  }\n\n  protected _onDragCancel(draggable: Draggable<any>) {\n    this._stopDrag(draggable, true);\n  }\n\n  protected _onDraggableDestroy(draggable: Draggable<any>) {\n    this.removeDraggables([draggable]);\n  }\n\n  protected _onScroll = () => {\n    if (this._drags.size === 0) return;\n\n    // Queue droppable client rects update.\n    ticker.once(\n      tickerPhases.read,\n      () => {\n        this.updateDroppableClientRects();\n      },\n      this._listenerId,\n    );\n\n    // Queue collision detection for all active draggables.\n    this.detectCollisions();\n  };\n\n  // Returns true if the final cleanup was queued to a microtask.\n  protected _stopDrag(draggable: Draggable<any>, canceled = false): boolean {\n    // Make sure the draggable is being dragged.\n    const drag = this._drags.get(draggable);\n    if (!drag || drag.isEnded) return false;\n\n    // Mark the drag as ended.\n    drag.isEnded = true;\n\n    // Check if the collisions are being emitted currently. This can happen if\n    // the user causes drag to end synchronously in any way during the collision\n    // emit phase.\n    const isEmittingCollisions = drag._cd.phase === CollisionDetectionPhase.Emitting;\n\n    // If the collisions are not being emitted currently, do a final collision\n    // detection pass before emitting the drop event to ensure we have the most\n    // up to date collisions data.\n    if (!isEmittingCollisions) {\n      this._computeCollisions(draggable, true);\n      this._emitCollisions(draggable, true);\n    }\n\n    // Get the targets, collisions and colliding targets from the last collision\n    // detection pass.\n    const { targets, collisions, contacts } = drag._cd;\n\n    // Emit \"end\" event.\n    if (this._emitter.listenerCount(DndContextEventType.End)) {\n      this._emitter.emit(DndContextEventType.End, {\n        canceled,\n        draggable,\n        targets,\n        collisions,\n        contacts,\n      });\n    }\n\n    // Wait for the collisions to be emitted before finalizing the drag end.\n    // Also let's return true to indicate that the drag end was not finished\n    // synchronously.\n    if (isEmittingCollisions) {\n      window.queueMicrotask(() => {\n        this._finalizeStopDrag(draggable);\n      });\n      return true;\n    }\n\n    this._finalizeStopDrag(draggable);\n    return false;\n  }\n\n  protected _finalizeStopDrag(draggable: Draggable<any>) {\n    const drag = this._drags.get(draggable);\n    if (!drag || !drag.isEnded) return;\n\n    // Remove the drag data.\n    this._drags.delete(draggable);\n\n    // Free up the collision data pool from the collision detector.\n    this._collisionDetector.removeCollisionDataPool(draggable);\n\n    // Clear the queued detect collisions callbacks.\n    ticker.off(tickerPhases.read, drag._cd.tickerId);\n    ticker.off(tickerPhases.write, drag._cd.tickerId);\n\n    // Remove scroll ticker and listener if this was the last dragged draggable.\n    if (!this._drags.size) {\n      ticker.off(tickerPhases.read, this._listenerId);\n      window.removeEventListener('scroll', this._onScroll, SCROLL_LISTENER_OPTIONS);\n    }\n  }\n\n  protected _computeCollisions(draggable: Draggable<any>, force = false) {\n    const drag = this._drags.get(draggable);\n    if (!drag || (!force && drag.isEnded)) return;\n\n    const cd = drag._cd;\n\n    // Throw an error if collisions are being computed or emitted.\n    switch (cd.phase) {\n      case CollisionDetectionPhase.Computing:\n        throw new Error('Collisions are being computed.');\n      case CollisionDetectionPhase.Emitting:\n        throw new Error('Collisions are being emitted.');\n      default:\n        break;\n    }\n\n    // Mark collision detection as computing.\n    cd.phase = CollisionDetectionPhase.Computing;\n\n    // Get the targets of the draggable and set them as the collision targets.\n    cd.targets = this._getTargets(draggable);\n\n    // NB: Running collision detection will mutate the collision data of the\n    // current collisions of the draggable (since we use object pool objects\n    // directly for memory efficiency), so if we need to compare the current and\n    // next collisions we need to cache the current collisions before running\n    // the detection. But, we don't need to do that now, we just care about the\n    // previous colliding droppables so this is fine.\n    this._collisionDetector.detectCollisions(draggable, cd.targets, cd.collisions);\n\n    // Mark collision detection as computed.\n    cd.phase = CollisionDetectionPhase.Computed;\n  }\n\n  protected _emitCollisions(draggable: Draggable<any>, force = false) {\n    const drag = this._drags.get(draggable);\n    if (!drag || (!force && drag.isEnded)) return;\n\n    const cd = drag._cd;\n\n    // Make sure we have computed the collisions.\n    switch (cd.phase) {\n      case CollisionDetectionPhase.Computing:\n        throw new Error('Collisions are being computed.');\n      case CollisionDetectionPhase.Emitting:\n        throw new Error('Collisions are being emitted.');\n      case CollisionDetectionPhase.Idle:\n        // Silently ignore if collisions have not been computed yet. This is\n        // a potential scenario, a valid one, but we should not throw an error\n        // here.\n        return;\n      default:\n        break;\n    }\n\n    // Mark collision detection as emitting.\n    cd.phase = CollisionDetectionPhase.Emitting;\n\n    const emitter = this._emitter;\n    const collisions = cd.collisions;\n    const targets = cd.targets;\n    const addedContacts = cd.addedContacts;\n    const persistedContacts = cd.persistedContacts;\n\n    // Swap pointers to the colliding droppables sets.\n    const prevContacts = cd.contacts;\n    const contacts = cd.prevContacts;\n    cd.prevContacts = prevContacts;\n    cd.contacts = contacts;\n\n    // Make removedContacts piggyback on prevContacts.\n    const removedContacts = prevContacts;\n\n    // Clear reusable sets.\n    addedContacts.clear();\n    persistedContacts.clear();\n    contacts.clear();\n\n    // Populate the colliding droppables set based on collisions and find out\n    // added, persisted and removed collisions (leftover from the previous\n    // collision phase).\n    for (const collision of collisions) {\n      const droppable = targets.get(collision.droppableId);\n      // NB: We should always have a droppable here since we compute the\n      // collisions with the targets of the draggable, but it's still good to\n      // be defensive here.\n      if (!droppable) continue;\n      contacts.add(droppable);\n      if (prevContacts.has(droppable)) {\n        persistedContacts.add(droppable);\n        // Let's remove the droppable from the previous colliding droppables set,\n        // this way the removed collisions will be the ones that are left in the\n        // previous colliding droppables set.\n        prevContacts.delete(droppable);\n      } else {\n        addedContacts.add(droppable);\n      }\n    }\n\n    // Emit \"leave\" events.\n    if (prevContacts.size && emitter.listenerCount(DndContextEventType.Leave)) {\n      emitter.emit(DndContextEventType.Leave, {\n        draggable,\n        targets,\n        collisions,\n        contacts,\n        removedContacts,\n      });\n    }\n\n    // Emit \"enter\" events.\n    if (addedContacts.size && emitter.listenerCount(DndContextEventType.Enter)) {\n      emitter.emit(DndContextEventType.Enter, {\n        draggable,\n        targets,\n        collisions,\n        contacts,\n        addedContacts,\n      });\n    }\n\n    // Emit \"collide\" events if we have any contacts or removed contacts.\n    if (\n      emitter.listenerCount(DndContextEventType.Collide) &&\n      (contacts.size || removedContacts.size)\n    ) {\n      emitter.emit(DndContextEventType.Collide, {\n        draggable,\n        targets,\n        collisions,\n        contacts,\n        addedContacts,\n        removedContacts,\n        persistedContacts,\n      });\n    }\n\n    // Clear reusable sets.\n    addedContacts.clear();\n    persistedContacts.clear();\n    prevContacts.clear();\n\n    // Mark collision detection as idle.\n    cd.phase = CollisionDetectionPhase.Idle;\n  }\n\n  on<K extends keyof DndContextEventCallbacks<T>>(\n    type: K,\n    listener: DndContextEventCallbacks<T>[K],\n    listenerId?: EventListenerId,\n  ): EventListenerId {\n    return this._emitter.on(type, listener, listenerId);\n  }\n\n  off<K extends keyof DndContextEventCallbacks<T>>(type: K, listenerId: EventListenerId): void {\n    this._emitter.off(type, listenerId);\n  }\n\n  updateDroppableClientRects() {\n    for (const droppable of this.droppables.values()) {\n      droppable.updateClientRect();\n    }\n  }\n\n  clearTargets(draggable?: Draggable<any>) {\n    if (draggable) {\n      const drag = this._drags.get(draggable);\n      if (drag) drag._targets = null;\n    } else {\n      for (const drag of this._drags.values()) {\n        drag._targets = null;\n      }\n    }\n  }\n\n  detectCollisions(draggable?: Draggable<any>) {\n    if (this.isDestroyed) return;\n\n    if (draggable) {\n      const drag = this._drags.get(draggable);\n      if (!drag || drag.isEnded) return;\n      ticker.once(tickerPhases.read, () => this._computeCollisions(draggable), drag._cd.tickerId);\n      ticker.once(tickerPhases.write, () => this._emitCollisions(draggable), drag._cd.tickerId);\n    } else {\n      for (const [d, drag] of this._drags) {\n        if (drag.isEnded) continue;\n        ticker.once(tickerPhases.read, () => this._computeCollisions(d), drag._cd.tickerId);\n        ticker.once(tickerPhases.write, () => this._emitCollisions(d), drag._cd.tickerId);\n      }\n    }\n  }\n\n  addDraggables(draggables: Draggable<any>[] | Set<Draggable<any>>) {\n    if (this.isDestroyed) return;\n\n    const addedDraggables = new Set<Draggable<any>>();\n\n    for (const draggable of draggables) {\n      if (this.draggables.has(draggable.id)) continue;\n\n      addedDraggables.add(draggable);\n\n      (this.draggables as Map<DraggableId, Draggable<any>>).set(draggable.id, draggable);\n\n      draggable.on(\n        DraggableEventType.PrepareStart,\n        () => {\n          this._onDragPrepareStart(draggable);\n        },\n        this._listenerId,\n      );\n\n      draggable.on(\n        DraggableEventType.Start,\n        () => {\n          this._onDragStart(draggable);\n        },\n        this._listenerId,\n      );\n\n      draggable.on(\n        DraggableEventType.PrepareMove,\n        () => {\n          this._onDragPrepareMove(draggable);\n        },\n        this._listenerId,\n      );\n\n      draggable.on(\n        DraggableEventType.Move,\n        () => {\n          this._onDragMove(draggable);\n        },\n        this._listenerId,\n      );\n\n      draggable.on(\n        DraggableEventType.End,\n        (e) => {\n          if (e?.type === SensorEventType.End) {\n            this._onDragEnd(draggable);\n          } else if (e?.type === SensorEventType.Cancel) {\n            this._onDragCancel(draggable);\n          }\n        },\n        this._listenerId,\n      );\n\n      draggable.on(\n        DraggableEventType.Destroy,\n        () => {\n          this._onDraggableDestroy(draggable);\n        },\n        this._listenerId,\n      );\n    }\n\n    // If no draggables were added, return.\n    if (!addedDraggables.size) return;\n\n    // Emit \"addDraggables\" event.\n    if (this._emitter.listenerCount(DndContextEventType.AddDraggables)) {\n      this._emitter.emit(DndContextEventType.AddDraggables, { draggables: addedDraggables });\n    }\n\n    // Start the drag process for the added draggables, if needed.\n    for (const draggable of addedDraggables) {\n      // If the draggable is already being dragged, start the drag process\n      // manually. Note that we are reading internal state of the draggable here\n      // (`_startPhase`) to avoid double starting the drag process. We need to\n      // be careful here and make sure to update this logic if we change the\n      // draggable's internal state logic.\n      if (!this.isDestroyed && draggable.drag && !draggable.drag.isEnded) {\n        const startPhase = draggable['_startPhase'];\n        if (startPhase >= 2) this._onDragPrepareStart(draggable);\n        if (startPhase >= 4) this._onDragStart(draggable);\n      }\n    }\n  }\n\n  removeDraggables(draggables: Draggable<any>[] | Set<Draggable<any>>) {\n    if (this.isDestroyed) return;\n\n    const removedDraggables = new Set<Draggable<any>>();\n\n    for (const draggable of draggables) {\n      if (!this.draggables.has(draggable.id)) continue;\n\n      removedDraggables.add(draggable);\n\n      // Remove draggable.\n      (this.draggables as Map<DraggableId, Draggable<any>>).delete(draggable.id);\n\n      // Unbind the event listeners.\n      draggable.off(DraggableEventType.PrepareStart, this._listenerId);\n      draggable.off(DraggableEventType.Start, this._listenerId);\n      draggable.off(DraggableEventType.PrepareMove, this._listenerId);\n      draggable.off(DraggableEventType.Move, this._listenerId);\n      draggable.off(DraggableEventType.End, this._listenerId);\n      draggable.off(DraggableEventType.Destroy, this._listenerId);\n    }\n\n    // Cancel the drag.\n    // NB: We need to do this after first removing the draggables from the\n    // registry to avoid calling removeDraggables more than once per draggable.\n    for (const draggable of removedDraggables) {\n      this._stopDrag(draggable, true);\n    }\n\n    // Emit \"removeDraggables\" event.\n    if (this._emitter.listenerCount(DndContextEventType.RemoveDraggables)) {\n      this._emitter.emit(DndContextEventType.RemoveDraggables, { draggables: removedDraggables });\n    }\n  }\n\n  addDroppables(droppables: Droppable[] | Set<Droppable>) {\n    if (this.isDestroyed) return;\n\n    const addedDroppables = new Set<Droppable>();\n\n    for (const droppable of droppables) {\n      // Make sure the droppable is not registered.\n      if (this.droppables.has(droppable.id)) continue;\n\n      // Add the droppable to the validated set of droppables.\n      addedDroppables.add(droppable);\n\n      // Add the droppable to the droppable map.\n      (this.droppables as Map<DroppableId, Droppable>).set(droppable.id, droppable);\n\n      // Bind the destroy event listener.\n      droppable.on(\n        DroppableEventType.Destroy,\n        () => {\n          this.removeDroppables([droppable]);\n        },\n        this._listenerId,\n      );\n\n      // Add the droppable to the targets of all currently dragged draggables,\n      // where the droppable is a valid target.\n      this._drags.forEach(({ _targets }, draggable) => {\n        if (_targets && this._isMatch(draggable, droppable)) {\n          _targets.set(droppable.id, droppable);\n          this.detectCollisions(draggable);\n        }\n      });\n    }\n\n    // Emit \"addDroppables\" event.\n    if (addedDroppables.size && this._emitter.listenerCount(DndContextEventType.AddDroppables)) {\n      this._emitter.emit(DndContextEventType.AddDroppables, { droppables: addedDroppables });\n    }\n  }\n\n  removeDroppables(droppables: Droppable[] | Set<Droppable>) {\n    if (this.isDestroyed) return;\n\n    const removedDroppables = new Set<Droppable>();\n\n    for (const droppable of droppables) {\n      // Make sure the droppable is registered.\n      if (!this.droppables.has(droppable.id)) continue;\n\n      // Remove the droppable from the droppables map.\n      (this.droppables as Map<DroppableId, Droppable>).delete(droppable.id);\n\n      // Add the droppable to the validated set of droppables.\n      removedDroppables.add(droppable);\n\n      // Unbind the destroy event listener.\n      droppable.off(DroppableEventType.Destroy, this._listenerId);\n\n      // Remove the droppable from the targets set of all dragged draggables and\n      // queue collision detection for them.\n      this._drags.forEach(({ _targets }, draggable) => {\n        if (_targets && _targets.has(droppable.id)) {\n          _targets.delete(droppable.id);\n          this.detectCollisions(draggable);\n        }\n      });\n    }\n\n    // Emit \"removeDroppables\" event.\n    if (\n      removedDroppables.size &&\n      this._emitter.listenerCount(DndContextEventType.RemoveDroppables)\n    ) {\n      this._emitter.emit(DndContextEventType.RemoveDroppables, { droppables: removedDroppables });\n    }\n  }\n\n  destroy() {\n    // Make sure the context is not destroyed yet.\n    if (this.isDestroyed) return;\n    (this as Writeable<typeof this>).isDestroyed = true;\n\n    // Unbind all draggable event listeners.\n    this.draggables.forEach((draggable) => {\n      draggable.off(DraggableEventType.PrepareStart, this._listenerId);\n      draggable.off(DraggableEventType.Start, this._listenerId);\n      draggable.off(DraggableEventType.PrepareMove, this._listenerId);\n      draggable.off(DraggableEventType.Move, this._listenerId);\n      draggable.off(DraggableEventType.End, this._listenerId);\n      draggable.off(DraggableEventType.Destroy, this._listenerId);\n    });\n\n    // Unbind all droppable event listeners.\n    this.droppables.forEach((droppable) => {\n      droppable.off(DroppableEventType.Destroy, this._listenerId);\n    });\n\n    // Cancel all active drags.\n    const activeDraggables = this._drags.keys();\n    for (const draggable of activeDraggables) {\n      this._stopDrag(draggable, true);\n    }\n\n    // Emit \"destroy\" event.\n    this._emitter.emit(DndContextEventType.Destroy);\n\n    // Unbind all emitter listeners.\n    this._emitter.off();\n\n    // Destroy the collision detector.\n    this._collisionDetector.destroy();\n\n    // Clear the draggables and droppables.\n    (this.draggables as Map<DraggableId, Draggable<any>>).clear();\n    (this.droppables as Map<DroppableId, Droppable>).clear();\n  }\n}\n"],"mappings":"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"}