{"version":3,"file":"use-keyboard-motion-sensor-B0wbimu8.js","names":[],"sources":["../src/hooks/use-keyboard-motion-sensor.ts"],"sourcesContent":["import type { KeyboardMotionSensorEvents, KeyboardMotionSensorSettings } from 'dragdoll';\nimport { KeyboardMotionSensor } from 'dragdoll';\nimport { useRef, useState } from 'react';\nimport { useCallbackStable } from './use-callback-stable.js';\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-layout-effect.js';\nimport { useMemoStable } from './use-memo-stable.js';\n\nexport function useKeyboardMotionSensor<\n  E extends KeyboardMotionSensorEvents = KeyboardMotionSensorEvents,\n>(settings: Partial<KeyboardMotionSensorSettings<E>> = {}, element?: Element | null) {\n  const [sensor, setSensor] = useState<KeyboardMotionSensor<E> | null>(null);\n  const sensorRef = useRef<KeyboardMotionSensor<E> | null>(sensor);\n  const settingsRef = useRef(settings);\n\n  // Helper function to create a new keyboard sensor.\n  const createSensor = useCallbackStable((node: Element | null) => {\n    sensorRef.current?.destroy();\n    const newSensor = new KeyboardMotionSensor<E>(node, settingsRef.current);\n    sensorRef.current = newSensor;\n    setSensor(newSensor);\n  }, []);\n\n  // Helper function to destroy the keyboard sensor.\n  const destroySensor = useCallbackStable(() => {\n    if (!sensorRef.current) return;\n    sensorRef.current.destroy();\n    sensorRef.current = null;\n    setSensor(null);\n  }, []);\n\n  // Ref callback for the keyboard sensor element IF user does not provide an\n  // explicit element.\n  const setRef = useCallbackStable(\n    (node: Element | null) => {\n      // If user provides an explicit element or null, do not create a new\n      // keyboard sensor.\n      if (element !== undefined) return;\n\n      // Destroy the keyboard sensor if the node is null.\n      if (node === null) {\n        destroySensor();\n        return;\n      }\n\n      // Create a new keyboard sensor if there is no sensor or the node has\n      // changed.\n      const currentSensor = sensorRef.current;\n      if (!currentSensor || currentSensor.element !== node) {\n        createSensor(node);\n      }\n    },\n    [element, createSensor, destroySensor],\n  );\n\n  // Keep the settings up to date.\n  settingsRef.current = settings;\n\n  // Handle explicit element change.\n  useIsomorphicLayoutEffect(() => {\n    if (element === undefined) return;\n    createSensor(element);\n    return destroySensor;\n  }, [element, createSensor, destroySensor]);\n\n  // Handle settings change.\n  useIsomorphicLayoutEffect(() => {\n    if (sensor) sensor.updateSettings(settings);\n  }, [sensor, settings]);\n\n  return useMemoStable(() => {\n    return [sensor, setRef] as const;\n  }, [sensor, setRef]);\n}\n"],"mappings":"yNAOA,SAAgB,EAEd,EAAqD,EAAE,CAAE,EAA0B,CACnF,GAAM,CAAC,EAAQ,GAAa,EAAyC,KAAK,CACpE,EAAY,EAAuC,EAAO,CAC1D,EAAc,EAAO,EAAS,CAG9B,EAAe,EAAmB,GAAyB,CAC/D,EAAU,SAAS,SAAS,CAC5B,IAAM,EAAY,IAAI,EAAwB,EAAM,EAAY,QAAQ,CACxE,EAAU,QAAU,EACpB,EAAU,EAAU,EACnB,EAAE,CAAC,CAGA,EAAgB,MAAwB,CACvC,EAAU,UACf,EAAU,QAAQ,SAAS,CAC3B,EAAU,QAAU,KACpB,EAAU,KAAK,GACd,EAAE,CAAC,CAIA,EAAS,EACZ,GAAyB,CAGxB,GAAI,IAAY,IAAA,GAAW,OAG3B,GAAI,IAAS,KAAM,CACjB,GAAe,CACf,OAKF,IAAM,EAAgB,EAAU,SAC5B,CAAC,GAAiB,EAAc,UAAY,IAC9C,EAAa,EAAK,EAGtB,CAAC,EAAS,EAAc,EAAc,CACvC,CAiBD,MAdA,GAAY,QAAU,EAGtB,MAAgC,CAC1B,OAAY,IAAA,GAEhB,OADA,EAAa,EAAQ,CACd,GACN,CAAC,EAAS,EAAc,EAAc,CAAC,CAG1C,MAAgC,CAC1B,GAAQ,EAAO,eAAe,EAAS,EAC1C,CAAC,EAAQ,EAAS,CAAC,CAEf,MACE,CAAC,EAAQ,EAAO,CACtB,CAAC,EAAQ,EAAO,CAAC"}