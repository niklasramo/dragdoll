{"version":3,"file":"use-keyboard-sensor-CEuoAT1c.js","names":[],"sources":["../src/hooks/use-keyboard-sensor.ts"],"sourcesContent":["import type { KeyboardSensorEvents, KeyboardSensorSettings } from 'dragdoll';\nimport { KeyboardSensor } from 'dragdoll';\nimport { useRef, useState } from 'react';\nimport { useCallbackStable } from './use-callback-stable.js';\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-layout-effect.js';\nimport { useMemoStable } from './use-memo-stable.js';\n\nexport function useKeyboardSensor<E extends KeyboardSensorEvents = KeyboardSensorEvents>(\n  settings: Partial<KeyboardSensorSettings<E>> = {},\n  element?: Element | null,\n) {\n  const [sensor, setSensor] = useState<KeyboardSensor<E> | null>(null);\n  const sensorRef = useRef<KeyboardSensor<E> | null>(sensor);\n  const settingsRef = useRef(settings);\n\n  // Helper function to create a new keyboard sensor.\n  const createSensor = useCallbackStable((node: Element | null) => {\n    sensorRef.current?.destroy();\n    const newSensor = new KeyboardSensor<E>(node, settingsRef.current);\n    sensorRef.current = newSensor;\n    setSensor(newSensor);\n  }, []);\n\n  // Helper function to destroy the keyboard sensor.\n  const destroySensor = useCallbackStable(() => {\n    if (!sensorRef.current) return;\n    sensorRef.current.destroy();\n    sensorRef.current = null;\n    setSensor(null);\n  }, []);\n\n  // Ref callback for the keyboard sensor element IF user does not provide an\n  // explicit element.\n  const setRef = useCallbackStable(\n    (node: Element | null) => {\n      // If user provides an explicit element or null, do not create a new\n      // keyboard sensor.\n      if (element !== undefined) return;\n\n      // Destroy the keyboard sensor if the node is null.\n      if (node === null) {\n        destroySensor();\n        return;\n      }\n\n      // Create a new keyboard sensor if there is no sensor or the node has\n      // changed.\n      const currentSensor = sensorRef.current;\n      if (!currentSensor || currentSensor.element !== node) {\n        createSensor(node);\n      }\n    },\n    [element, createSensor, destroySensor],\n  );\n\n  // Keep the settings up to date.\n  settingsRef.current = settings;\n\n  // Handle explicit element change.\n  useIsomorphicLayoutEffect(() => {\n    if (element === undefined) return;\n    createSensor(element);\n    return destroySensor;\n  }, [element, createSensor, destroySensor]);\n\n  // Handle settings change.\n  useIsomorphicLayoutEffect(() => {\n    if (sensor) sensor.updateSettings(settings);\n  }, [sensor, settings]);\n\n  return useMemoStable(() => {\n    return [sensor, setRef] as const;\n  }, [sensor, setRef]);\n}\n"],"mappings":"mNAOA,SAAgB,EACd,EAA+C,EAAE,CACjD,EACA,CACA,GAAM,CAAC,EAAQ,GAAa,EAAmC,KAAK,CAC9D,EAAY,EAAiC,EAAO,CACpD,EAAc,EAAO,EAAS,CAG9B,EAAe,EAAmB,GAAyB,CAC/D,EAAU,SAAS,SAAS,CAC5B,IAAM,EAAY,IAAI,EAAkB,EAAM,EAAY,QAAQ,CAClE,EAAU,QAAU,EACpB,EAAU,EAAU,EACnB,EAAE,CAAC,CAGA,EAAgB,MAAwB,CACvC,EAAU,UACf,EAAU,QAAQ,SAAS,CAC3B,EAAU,QAAU,KACpB,EAAU,KAAK,GACd,EAAE,CAAC,CAIA,EAAS,EACZ,GAAyB,CAGxB,GAAI,IAAY,IAAA,GAAW,OAG3B,GAAI,IAAS,KAAM,CACjB,GAAe,CACf,OAKF,IAAM,EAAgB,EAAU,SAC5B,CAAC,GAAiB,EAAc,UAAY,IAC9C,EAAa,EAAK,EAGtB,CAAC,EAAS,EAAc,EAAc,CACvC,CAiBD,MAdA,GAAY,QAAU,EAGtB,MAAgC,CAC1B,OAAY,IAAA,GAEhB,OADA,EAAa,EAAQ,CACd,GACN,CAAC,EAAS,EAAc,EAAc,CAAC,CAG1C,MAAgC,CAC1B,GAAQ,EAAO,eAAe,EAAS,EAC1C,CAAC,EAAQ,EAAS,CAAC,CAEf,MACE,CAAC,EAAQ,EAAO,CACtB,CAAC,EAAQ,EAAO,CAAC"}