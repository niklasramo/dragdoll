{"version":3,"file":"create-touch-delay-predicate.js","names":["scrollables: (Element | Window)[]","dragAllowed: boolean | undefined","startTimeStamp: number","targetElement: Element | null","timer: number | undefined","pointerSensorStartPredicate: D['settings']['startPredicate']","sensor"],"sources":["../../../src/utils/is-scrollable.ts","../../../src/utils/get-scrollable-ancestors.ts","../../../src/draggable/helpers/create-touch-delay-predicate.ts"],"sourcesContent":["import { getStyle } from './get-style.js';\n\nconst SCROLLABLE_OVERFLOWS = new Set(['auto', 'scroll', 'overlay']);\n\n/**\n * Check if element is scrollable.\n */\nexport function isScrollable(element: Element) {\n  const style = getStyle(element);\n  return !!(SCROLLABLE_OVERFLOWS.has(style.overflowY) || SCROLLABLE_OVERFLOWS.has(style.overflowX));\n}\n","import { isScrollable } from './is-scrollable.js';\nimport { isDocument } from './is-document.js';\n\n/**\n * Compute the element's scrollable ancestor elements.\n */\nexport function getScrollableAncestors(\n  element: Element | Document | null,\n  result: (Element | Window)[] = [],\n) {\n  let parent = element?.parentNode;\n\n  // Reset the result array.\n  result.length = 0;\n\n  while (parent && !isDocument(parent)) {\n    if (parent instanceof Element) {\n      if (isScrollable(parent)) result.push(parent);\n      parent = parent.parentNode;\n    } else if (parent instanceof ShadowRoot) {\n      parent = parent.host;\n    } else {\n      parent = parent.parentNode;\n    }\n  }\n\n  // Always push window to the results (as last scrollable element).\n  result.push(window);\n\n  return result;\n}\n","import type { Sensor } from '../../sensors/sensor.js';\n\nimport type { Draggable } from '../draggable.js';\n\nimport { SensorEventType } from '../../sensors/sensor.js';\n\nimport { DraggableEventType } from '../draggable.js';\n\nimport { PointerSensor, PointerSensorEvents } from '../../sensors/pointer-sensor.js';\n\nimport { getScrollableAncestors } from '../../utils/get-scrollable-ancestors.js';\n\nimport { isScrollable } from '../../utils/is-scrollable.js';\n\nfunction getScrollables(element: Element) {\n  const scrollables: (Element | Window)[] = [];\n\n  if (isScrollable(element)) {\n    scrollables.push(element);\n  }\n\n  getScrollableAncestors(element, scrollables);\n\n  return scrollables;\n}\n\nexport function createTouchDelayPredicate<\n  S extends (Sensor | PointerSensor)[] = (Sensor | PointerSensor)[],\n  D extends Draggable<S> = Draggable<S>,\n>(\n  options: {\n    touchDelay?: number;\n    fallback?: D['settings']['startPredicate'];\n  } = {},\n) {\n  let dragAllowed: boolean | undefined = undefined;\n\n  let startTimeStamp: number = 0;\n\n  let targetElement: Element | null = null;\n\n  let timer: number | undefined = undefined;\n\n  const { touchDelay = 250, fallback = () => true } = options;\n\n  const onContextMenu = (e: Event) => e.preventDefault();\n\n  const onTouchMove = (e: TouchEvent) => {\n    if (!startTimeStamp) return;\n\n    if (dragAllowed) {\n      e.cancelable && e.preventDefault();\n      return;\n    }\n\n    if (dragAllowed === undefined) {\n      if (e.cancelable && e.timeStamp - startTimeStamp > touchDelay) {\n        dragAllowed = true;\n        e.preventDefault();\n      } else {\n        dragAllowed = false;\n      }\n    }\n  };\n\n  const pointerSensorStartPredicate: D['settings']['startPredicate'] = (data) => {\n    if (!(data.sensor instanceof PointerSensor)) {\n      return fallback(data);\n    }\n\n    const { draggable, sensor, event } = data;\n    const e = event as PointerSensorEvents['start'] | PointerSensorEvents['move'];\n\n    if (e.pointerType === 'touch') {\n      // On first event (touchstart/pointerdown) we need to store the drag start\n      // data and bind listeners for touchmove and contextmenu.\n      if (\n        e.type === SensorEventType.Start &&\n        (e.srcEvent.type === 'pointerdown' || e.srcEvent.type === 'touchstart')\n      ) {\n        // Prevent potentially scrollable nodes from scrolling to make sure\n        // native scrolling does not interfere with dragging.\n        targetElement = e.target as Element | null;\n        const scrollables = targetElement ? getScrollables(targetElement) : [];\n        scrollables.forEach((scrollable) => {\n          scrollable.addEventListener('touchmove', onTouchMove as EventListener, {\n            passive: false,\n            capture: true,\n          });\n        });\n\n        const dragEndListener = () => {\n          if (!startTimeStamp) return;\n\n          // Unbind listeners.\n          draggable.off(DraggableEventType.End, dragEndListener);\n          draggable.sensors.forEach((sensor) => {\n            if (sensor instanceof PointerSensor) {\n              sensor.off(SensorEventType.End, dragEndListener);\n            }\n          });\n          targetElement?.removeEventListener('contextmenu', onContextMenu);\n          scrollables.forEach((scrollable) => {\n            scrollable.removeEventListener('touchmove', onTouchMove as EventListener, {\n              capture: true,\n            });\n          });\n\n          // Reset state.\n          startTimeStamp = 0;\n          dragAllowed = undefined;\n          targetElement = null;\n          timer = void window.clearTimeout(timer);\n        };\n\n        // Set start state.\n        dragAllowed = undefined;\n        startTimeStamp = e.srcEvent.timeStamp;\n\n        // Prevent context menu popping up.\n        targetElement?.addEventListener('contextmenu', onContextMenu);\n\n        // Reset data on drag end. We want to listen to all sensors as we don't\n        // know yet which one will start the drag.\n        draggable.on(DraggableEventType.End, dragEndListener);\n        draggable.sensors.forEach((sensor) => {\n          if (sensor instanceof PointerSensor) {\n            sensor.on(SensorEventType.End, dragEndListener);\n          }\n        });\n\n        // If we have touchDelay defined, let's set a timer that force starts\n        // the drag process after the timeout.\n        // TODO: This will start drag sometimes when it's not actually possible\n        // to prevent the native scrolling on touch devices. We'd need a way\n        // to check if the first touchstart/touchmove is cancelable. Needs\n        // testing on real devices. The funky thing is that we seem to need to\n        // get one touchmove event to check if we can prevent native scrolling\n        // but that is kind of too late already.. let's see if we can detect\n        // that earlier somehow.\n        if (touchDelay > 0) {\n          timer = window.setTimeout(() => {\n            draggable.resolveStartPredicate(sensor);\n            dragAllowed = true;\n            timer = undefined;\n          }, touchDelay);\n        }\n      }\n\n      return dragAllowed;\n    }\n\n    // On mouse/pen let's allow starting drag immediately if mouse's left button\n    // is pressed down.\n    if (e.type === SensorEventType.Start && !(e.srcEvent as MouseEvent | PointerEvent).button) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  return pointerSensorStartPredicate;\n}\n"],"mappings":"oXAEA,MAAM,EAAuB,IAAI,IAAI,CAAC,OAAQ,SAAU,UAAU,CAAC,CAKnE,SAAgB,EAAa,EAAkB,CAC7C,IAAM,EAAQ,EAAS,EAAQ,CAC/B,MAAO,CAAC,EAAE,EAAqB,IAAI,EAAM,UAAU,EAAI,EAAqB,IAAI,EAAM,UAAU,ECHlG,SAAgB,EACd,EACA,EAA+B,EAAE,CACjC,CACA,IAAI,EAAS,GAAS,WAKtB,IAFA,EAAO,OAAS,EAET,GAAU,CAAC,EAAW,EAAO,EAC9B,aAAkB,SAChB,EAAa,EAAO,EAAE,EAAO,KAAK,EAAO,CAC7C,EAAS,EAAO,YAIhB,EAHS,aAAkB,WAClB,EAAO,KAEP,EAAO,WAOpB,OAFA,EAAO,KAAK,OAAO,CAEZ,ECfT,SAAS,EAAe,EAAkB,CACxC,IAAMA,EAAoC,EAAE,CAQ5C,OANI,EAAa,EAAQ,EACvB,EAAY,KAAK,EAAQ,CAG3B,EAAuB,EAAS,EAAY,CAErC,EAGT,SAAgB,EAId,EAGI,EAAE,CACN,CACA,IAAIC,EAEAC,EAAyB,EAEzBC,EAAgC,KAEhCC,EAEE,CAAE,aAAa,IAAK,eAAiB,IAAS,EAE9C,EAAiB,GAAa,EAAE,gBAAgB,CAEhD,EAAe,GAAkB,CAChC,KAEL,IAAI,EAAa,CACf,EAAE,YAAc,EAAE,gBAAgB,CAClC,OAGE,IAAgB,IAAA,KACd,EAAE,YAAc,EAAE,UAAY,EAAiB,GACjD,EAAc,GACd,EAAE,gBAAgB,EAElB,EAAc,MAqGpB,MAhGsE,IAAS,CAC7E,GAAI,EAAE,EAAK,kBAAkB,GAC3B,OAAO,EAAS,EAAK,CAGvB,GAAM,CAAE,YAAW,SAAQ,SAAU,EAC/B,EAAI,EAEV,GAAI,EAAE,cAAgB,QAAS,CAG7B,GACE,EAAE,OAAS,EAAgB,QAC1B,EAAE,SAAS,OAAS,eAAiB,EAAE,SAAS,OAAS,cAC1D,CAGA,EAAgB,EAAE,OAClB,IAAM,EAAc,EAAgB,EAAe,EAAc,CAAG,EAAE,CACtE,EAAY,QAAS,GAAe,CAClC,EAAW,iBAAiB,YAAa,EAA8B,CACrE,QAAS,GACT,QAAS,GACV,CAAC,EACF,CAEF,IAAM,MAAwB,CACvB,IAGL,EAAU,IAAI,EAAmB,IAAK,EAAgB,CACtD,EAAU,QAAQ,QAAS,GAAW,CAChCE,aAAkB,GACpB,EAAO,IAAI,EAAgB,IAAK,EAAgB,EAElD,CACF,GAAe,oBAAoB,cAAe,EAAc,CAChE,EAAY,QAAS,GAAe,CAClC,EAAW,oBAAoB,YAAa,EAA8B,CACxE,QAAS,GACV,CAAC,EACF,CAGF,EAAiB,EACjB,EAAc,IAAA,GACd,EAAgB,KAChB,EAAQ,KAAK,OAAO,aAAa,EAAM,GAIzC,EAAc,IAAA,GACd,EAAiB,EAAE,SAAS,UAG5B,GAAe,iBAAiB,cAAe,EAAc,CAI7D,EAAU,GAAG,EAAmB,IAAK,EAAgB,CACrD,EAAU,QAAQ,QAAS,GAAW,CAChCA,aAAkB,GACpB,EAAO,GAAG,EAAgB,IAAK,EAAgB,EAEjD,CAWE,EAAa,IACf,EAAQ,OAAO,eAAiB,CAC9B,EAAU,sBAAsB,EAAO,CACvC,EAAc,GACd,EAAQ,IAAA,IACP,EAAW,EAIlB,OAAO,EAQP,OAHE,EAAE,OAAS,EAAgB,OAAS,CAAE,EAAE,SAAuC"}