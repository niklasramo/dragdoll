import{Emitter}from"eventti";import{Ticker}from"tikki";const SensorEventType={start:"start",move:"move",cancel:"cancel",end:"end",destroy:"destroy"};class BaseSensor{constructor(){this.drag=null,this.isDestroyed=!1,this._emitter=new Emitter}_createDragData(t){return{x:t.x,y:t.y}}_updateDragData(t){this.drag&&(this.drag.x=t.x,this.drag.y=t.y)}_resetDragData(){this.drag=null}_start(t){this.isDestroyed||this.drag||(this.drag=this._createDragData(t),this._emitter.emit(SensorEventType.start,t))}_move(t){this.drag&&(this._updateDragData(t),this._emitter.emit(SensorEventType.move,t))}_end(t){this.drag&&(this._updateDragData(t),this._emitter.emit(SensorEventType.end,t),this._resetDragData())}_cancel(t){this.drag&&(this._updateDragData(t),this._emitter.emit(SensorEventType.cancel,t),this._resetDragData())}on(t,e,i){return this._emitter.on(t,e,i)}off(t,e){this._emitter.off(t,e)}cancel(){this.drag&&(this._emitter.emit(SensorEventType.cancel,{type:SensorEventType.cancel,x:this.drag.x,y:this.drag.y}),this._resetDragData())}destroy(){this.isDestroyed||(this.isDestroyed=!0,this.cancel(),this._emitter.emit(SensorEventType.destroy,{type:SensorEventType.destroy}),this._emitter.off())}}let tickerReadPhase=Symbol(),tickerWritePhase=Symbol(),ticker=new Ticker({phases:[tickerReadPhase,tickerWritePhase]});function setTicker(t,e,i){tickerReadPhase=e,tickerWritePhase=i,ticker=t}class BaseMotionSensor extends BaseSensor{constructor(){super(),this.drag=null,this._direction={x:0,y:0},this._speed=0,this._tick=this._tick.bind(this)}_createDragData(t){return Object.assign(Object.assign({},super._createDragData(t)),{time:0,deltaTime:0})}_start(t){this.isDestroyed||this.drag||(super._start(t),ticker.on(tickerReadPhase,this._tick))}_end(t){this.drag&&(ticker.off(tickerReadPhase,this._tick),super._end(t))}_cancel(t){this.drag&&(ticker.off(tickerReadPhase,this._tick),super._cancel(t))}_tick(t){if(this.drag)if(t&&this.drag.time){this.drag.deltaTime=t-this.drag.time,this.drag.time=t;const e={type:"tick",time:this.drag.time,deltaTime:this.drag.deltaTime};if(this._emitter.emit("tick",e),!this.drag)return;const i=this._speed*(this.drag.deltaTime/1e3),s=this._direction.x*i,n=this._direction.y*i;(s||n)&&this._move({type:"move",x:this.drag.x+s,y:this.drag.y+n})}else this.drag.time=t,this.drag.deltaTime=0}}function getPointerEventData(t,e){if("pointerId"in t)return t.pointerId===e?t:null;if("changedTouches"in t){let i=0;for(;i<t.changedTouches.length;i++)if(t.changedTouches[i].identifier===e)return t.changedTouches[i];return null}return t}function getPointerType(t){return"pointerType"in t?t.pointerType:"touches"in t?"touch":"mouse"}function getPointerId(t){return"pointerId"in t?t.pointerId:"changedTouches"in t?t.changedTouches[0]?t.changedTouches[0].identifier:null:-1}const IS_BROWSER="undefined"!=typeof window&&void 0!==window.document,HAS_PASSIVE_EVENTS=(()=>{let t=!1;try{const e=Object.defineProperty({},"passive",{get:function(){t=!0}});window.addEventListener("testPassive",null,e),window.removeEventListener("testPassive",null,e)}catch(t){}return t})(),HAS_TOUCH_EVENTS=IS_BROWSER&&"ontouchstart"in window,HAS_POINTER_EVENTS=IS_BROWSER&&!!window.PointerEvent,IS_SAFARI=!!(IS_BROWSER&&navigator.vendor&&navigator.vendor.indexOf("Apple")>-1&&navigator.userAgent&&-1==navigator.userAgent.indexOf("CriOS")&&-1==navigator.userAgent.indexOf("FxiOS"));function parseListenerOptions(t={}){const{capture:e=!0,passive:i=!0}=t;return HAS_PASSIVE_EVENTS?{capture:e,passive:i}:{capture:e}}function parseSourceEvents(t){return"auto"===t||void 0===t?HAS_POINTER_EVENTS?"pointer":HAS_TOUCH_EVENTS?"touch":"mouse":t}const POINTER_EVENTS={start:"pointerdown",move:"pointermove",cancel:"pointercancel",end:"pointerup"},TOUCH_EVENTS={start:"touchstart",move:"touchmove",cancel:"touchcancel",end:"touchend"},MOUSE_EVENTS={start:"mousedown",move:"mousemove",cancel:"",end:"mouseup"},SOURCE_EVENTS={pointer:POINTER_EVENTS,touch:TOUCH_EVENTS,mouse:MOUSE_EVENTS};class PointerSensor{constructor(t,e={}){const{listenerOptions:i={},sourceEvents:s="auto",startPredicate:n=(t=>!("button"in t&&t.button>0))}=e;this.element=t,this.drag=null,this.isDestroyed=!1,this._areWindowListenersBound=!1,this._startPredicate=n,this._listenerOptions=parseListenerOptions(i),this._sourceEvents=parseSourceEvents(s),this._emitter=new Emitter,this._onStart=this._onStart.bind(this),this._onMove=this._onMove.bind(this),this._onCancel=this._onCancel.bind(this),this._onEnd=this._onEnd.bind(this),t.addEventListener(SOURCE_EVENTS[this._sourceEvents].start,this._onStart,this._listenerOptions)}_getTrackedPointerEventData(t){return this.drag?getPointerEventData(t,this.drag.pointerId):null}_onStart(t){if(this.isDestroyed||this.drag)return;if(!this._startPredicate(t))return;const e=getPointerId(t);if(null===e)return;const i=getPointerEventData(t,e);if(null===i)return;const s={pointerId:e,pointerType:getPointerType(t),x:i.clientX,y:i.clientY};this.drag=s;const n=Object.assign(Object.assign({},s),{type:SensorEventType.start,srcEvent:t,target:i.target});this._emitter.emit(n.type,n),this.drag&&this._bindWindowListeners()}_onMove(t){if(!this.drag)return;const e=this._getTrackedPointerEventData(t);if(!e)return;this.drag.x=e.clientX,this.drag.y=e.clientY;const i=Object.assign({type:SensorEventType.move,srcEvent:t,target:e.target},this.drag);this._emitter.emit(i.type,i)}_onCancel(t){if(!this.drag)return;const e=this._getTrackedPointerEventData(t);if(!e)return;this.drag.x=e.clientX,this.drag.y=e.clientY;const i=Object.assign({type:SensorEventType.cancel,srcEvent:t,target:e.target},this.drag);this._emitter.emit(i.type,i),this._resetDrag()}_onEnd(t){if(!this.drag)return;const e=this._getTrackedPointerEventData(t);if(!e)return;this.drag.x=e.clientX,this.drag.y=e.clientY;const i=Object.assign({type:SensorEventType.end,srcEvent:t,target:e.target},this.drag);this._emitter.emit(i.type,i),this._resetDrag()}_bindWindowListeners(){if(this._areWindowListenersBound)return;const{move:t,end:e,cancel:i}=SOURCE_EVENTS[this._sourceEvents];window.addEventListener(t,this._onMove,this._listenerOptions),window.addEventListener(e,this._onEnd,this._listenerOptions),i&&window.addEventListener(i,this._onCancel,this._listenerOptions),this._areWindowListenersBound=!0}_unbindWindowListeners(){if(this._areWindowListenersBound){const{move:t,end:e,cancel:i}=SOURCE_EVENTS[this._sourceEvents];window.removeEventListener(t,this._onMove,this._listenerOptions),window.removeEventListener(e,this._onEnd,this._listenerOptions),i&&window.removeEventListener(i,this._onCancel,this._listenerOptions),this._areWindowListenersBound=!1}}_resetDrag(){this.drag=null,this._unbindWindowListeners()}cancel(){if(!this.drag)return;const t=Object.assign({type:SensorEventType.cancel,srcEvent:null,target:null},this.drag);this._emitter.emit(t.type,t),this._resetDrag()}updateSettings(t){if(this.isDestroyed)return;const{listenerOptions:e,sourceEvents:i,startPredicate:s}=t,n=parseSourceEvents(i),r=parseListenerOptions(e);s&&this._startPredicate!==s&&(this._startPredicate=s),(e&&(this._listenerOptions.capture!==r.capture||this._listenerOptions.passive===r.passive)||i&&this._sourceEvents!==n)&&(this.element.removeEventListener(SOURCE_EVENTS[this._sourceEvents].start,this._onStart,this._listenerOptions),this._unbindWindowListeners(),this.cancel(),i&&(this._sourceEvents=n),e&&r&&(this._listenerOptions=r),this.element.addEventListener(SOURCE_EVENTS[this._sourceEvents].start,this._onStart,this._listenerOptions))}on(t,e,i){return this._emitter.on(t,e,i)}off(t,e){this._emitter.off(t,e)}destroy(){this.isDestroyed||(this.isDestroyed=!0,this.cancel(),this._emitter.emit(SensorEventType.destroy,{type:SensorEventType.destroy}),this._emitter.off(),this.element.removeEventListener(SOURCE_EVENTS[this._sourceEvents].start,this._onStart,this._listenerOptions))}}class KeyboardSensor extends BaseSensor{constructor(t={}){super();const{moveDistance:e=25,startPredicate:i=(t=>{if(("Enter"===t.key||"Space"===t.key||" "===t.key)&&document.activeElement&&document.activeElement!==document.body){const{left:t,top:e}=document.activeElement.getBoundingClientRect();return{x:t,y:e}}return null}),movePredicate:s=((t,e,i)=>{if(!e.drag)return null;switch(t.key){case"ArrowLeft":return{x:e.drag.x-i,y:e.drag.y};case"ArrowRight":return{x:e.drag.x+i,y:e.drag.y};case"ArrowUp":return{x:e.drag.x,y:e.drag.y-i};case"ArrowDown":return{x:e.drag.x,y:e.drag.y+i};default:return null}}),cancelPredicate:n=((t,e)=>e.drag&&"Escape"===t.key?{x:e.drag.x,y:e.drag.y}:null),endPredicate:r=((t,e)=>!e.drag||"Enter"!==t.key&&"Space"!==t.key&&" "!==t.key?null:{x:e.drag.x,y:e.drag.y})}=t;this._moveDistance=e,this._startPredicate=i,this._movePredicate=s,this._cancelPredicate=n,this._endPredicate=r,this.cancel=this.cancel.bind(this),this._onKeyDown=this._onKeyDown.bind(this),document.addEventListener("keydown",this._onKeyDown),window.addEventListener("blur",this.cancel),window.addEventListener("visibilitychange",this.cancel)}_onKeyDown(t){if(!this.drag){const e=this._startPredicate(t,this,this._moveDistance);return void(e&&(t.preventDefault(),this._start({type:"start",x:e.x,y:e.y,srcEvent:t})))}const e=this._cancelPredicate(t,this,this._moveDistance);if(e)return t.preventDefault(),void this._cancel({type:"cancel",x:e.x,y:e.y,srcEvent:t});const i=this._endPredicate(t,this,this._moveDistance);if(i)return t.preventDefault(),void this._end({type:"end",x:i.x,y:i.y,srcEvent:t});const s=this._movePredicate(t,this,this._moveDistance);return s?(t.preventDefault(),void this._move({type:"move",x:s.x,y:s.y,srcEvent:t})):void 0}updateSettings(t={}){void 0!==t.moveDistance&&(this._moveDistance=t.moveDistance),void 0!==t.startPredicate&&(this._startPredicate=t.startPredicate),void 0!==t.movePredicate&&(this._movePredicate=t.movePredicate),void 0!==t.cancelPredicate&&(this._cancelPredicate=t.cancelPredicate),void 0!==t.endPredicate&&(this._endPredicate=t.endPredicate)}destroy(){this.isDestroyed||(super.destroy(),document.removeEventListener("keydown",this._onKeyDown),window.removeEventListener("blur",this.cancel),window.removeEventListener("visibilitychange",this.cancel))}}const KEY_TYPES=["start","cancel","end","moveLeft","moveRight","moveUp","moveDown"];function getEarliestTimestamp(t,e){if(!t.size||!e.size)return 1/0;let i=1/0;for(const s of t){const t=e.get(s);void 0!==t&&t<i&&(i=t)}return i}class KeyboardMotionSensor extends BaseMotionSensor{constructor(t={}){super();const{startPredicate:e=(()=>{if(document.activeElement){const{left:t,top:e}=document.activeElement.getBoundingClientRect();return{x:t,y:e}}return null}),computeSpeed:i=(()=>500),startKeys:s=[" ","Space","Enter"],moveLeftKeys:n=["ArrowLeft"],moveRightKeys:r=["ArrowRight"],moveUpKeys:o=["ArrowUp"],moveDownKeys:a=["ArrowDown"],cancelKeys:c=["Escape"],endKeys:h=[" ","Space","Enter"]}=t;this._computeSpeed=i,this._startPredicate=e,this._startKeys=new Set(s),this._cancelKeys=new Set(c),this._endKeys=new Set(h),this._moveLeftKeys=new Set(n),this._moveRightKeys=new Set(r),this._moveUpKeys=new Set(o),this._moveDownKeys=new Set(a),this._moveKeys=new Set([...n,...r,...o,...a]),this._moveKeyTimestamps=new Map,this._onKeyDown=this._onKeyDown.bind(this),this._onKeyUp=this._onKeyUp.bind(this),this._onTick=this._onTick.bind(this),this.on("tick",this._onTick),document.addEventListener("keydown",this._onKeyDown),document.addEventListener("keyup",this._onKeyUp),window.addEventListener("blur",this.cancel),window.addEventListener("visibilitychange",this.cancel)}_end(t){this.drag&&(this._moveKeyTimestamps.clear(),super._end(t))}_cancel(t){this.drag&&(this._moveKeyTimestamps.clear(),super._cancel(t))}_updateDirection(){const t=getEarliestTimestamp(this._moveLeftKeys,this._moveKeyTimestamps),e=getEarliestTimestamp(this._moveRightKeys,this._moveKeyTimestamps),i=getEarliestTimestamp(this._moveUpKeys,this._moveKeyTimestamps),s=getEarliestTimestamp(this._moveDownKeys,this._moveKeyTimestamps);let n=t===e?0:t<e?-1:1,r=i===s?0:i<s?-1:1;if(0!==n&&0!==r){const t=1/(Math.sqrt(n*n+r*r)||1);n*=t,r*=t}this._direction.x=n,this._direction.y=r}_onTick(){this._speed=this._computeSpeed(this)}_onKeyUp(t){this._moveKeyTimestamps.get(t.key)&&(this._moveKeyTimestamps.delete(t.key),this._updateDirection())}_onKeyDown(t){if(this.drag)return this._cancelKeys.has(t.key)?(t.preventDefault(),void this._cancel({type:"cancel",x:this.drag.x,y:this.drag.y})):this._endKeys.has(t.key)?(t.preventDefault(),void this._end({type:"end",x:this.drag.x,y:this.drag.y})):this._moveKeys.has(t.key)?(t.preventDefault(),void(this._moveKeyTimestamps.get(t.key)||(this._moveKeyTimestamps.set(t.key,Date.now()),this._updateDirection()))):void 0;if(this._startKeys.has(t.key)){const e=this._startPredicate(t,this);e&&(t.preventDefault(),this._start({type:"start",x:e.x,y:e.y}))}}updateSettings(t={}){let e=!1;if(void 0!==t.startPredicate&&(this._startPredicate=t.startPredicate),void 0!==t.computeSpeed&&(this._computeSpeed=t.computeSpeed),KEY_TYPES.forEach(((i,s)=>{const n=`${i}Keys`,r=t[n];void 0!==r&&(this[`_${n}`]=new Set(r),s>=3&&(e=!0))})),e){const t=[...this._moveLeftKeys,...this._moveRightKeys,...this._moveUpKeys,...this._moveDownKeys];[...this._moveKeys].every(((e,i)=>t[i]===e))||(this._moveKeys=new Set(t),this._moveKeyTimestamps.clear(),this._updateDirection())}}destroy(){this.isDestroyed||(super.destroy(),this.off("tick",this._onTick),document.removeEventListener("keydown",this._onKeyDown),document.removeEventListener("keyup",this._onKeyUp),window.removeEventListener("blur",this.cancel),window.removeEventListener("visibilitychange",this.cancel))}}const STYLES_CACHE=new WeakMap;function getStyle(t,e){if(!e)return"";let i=STYLES_CACHE.get(t);return i||(i=window.getComputedStyle(t,null),STYLES_CACHE.set(t,i)),i.getPropertyValue(e)}function isContainingBlock(t){if("static"!==getStyle(t,"position"))return!0;const e=getStyle(t,"display");if("inline"===e||"none"===e)return!1;const i=getStyle(t,"transform");if(i&&"none"!==i)return!0;const s=getStyle(t,"perspective");if(s&&"none"!==s)return!0;const n=getStyle(t,"content-visibility");if(n&&("auto"===n||"hidden"===n))return!0;const r=getStyle(t,"contain");if(r&&("strict"===r||"content"===r||r.indexOf("paint")>-1||r.indexOf("layout")>-1))return!0;if(!IS_SAFARI){const e=getStyle(t,"filter");if(e&&"none"!==e)return!0;const i=getStyle(t,"will-change");if(i&&(i.indexOf("transform")>-1||i.indexOf("perspective")>-1))return!0}return!1}function getContainingBlock(t){let e=t||document;for(;e&&e!==document&&!isContainingBlock(t);)e=e.parentElement||document;return e}function getStyleAsFloat(t,e){return parseFloat(getStyle(t,e))||0}function getOffset(t,e={left:0,top:0}){if(e.left=0,e.top=0,t===document)return e;if(e.left=window.pageXOffset||0,e.top=window.pageYOffset||0,"self"in t&&t.self===window.self)return e;const{left:i,top:s}=t.getBoundingClientRect();return e.left+=i,e.top+=s,e.left+=getStyleAsFloat(t,"border-left-width"),e.top+=getStyleAsFloat(t,"border-top-width"),e}const offsetA={left:0,top:0},offsetB={left:0,top:0};function getOffsetDiff(t,e,i={left:0,top:0}){return i.left=0,i.top=0,t===e||(getOffset(t,offsetA),getOffset(e,offsetB),i.left=offsetB.left-offsetA.left,i.top=offsetB.top-offsetA.top),i}const IDENTITY_MATRIX="matrix(1, 0, 0, 1, 0, 0)",IDENTITY_MATRIX_3D="matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)",SCROLL_LISTENER_OPTIONS=!HAS_PASSIVE_EVENTS||{capture:!0,passive:!0},OFFSET_DIFF={left:0,top:0},POSITION_CHANGE={x:0,y:0};var DraggableStartPredicateState;!function(t){t[t.PENDING=0]="PENDING",t[t.RESOLVED=1]="RESOLVED",t[t.REJECTED=2]="REJECTED"}(DraggableStartPredicateState||(DraggableStartPredicateState={}));class DraggableDragItem{constructor(t,e,i,s,n){this.element=t,this.rootParent=e,this.rootContainingBlock=i,this.dragParent=s,this.dragContainingBlock=n,this.x=0,this.y=0,this.pX=0,this.pY=0,this._syncDiffX=0,this._syncDiffY=0,this._moveDiffX=0,this._moveDiffY=0,this._containerDiffX=0,this._containerDiffY=0,this._transform=""}}class DraggableDrag{constructor(){this.sensor=null,this.isEnded=!1,this.isStarted=!1,this.startEvent=null,this.nextMoveEvent=null,this.prevMoveEvent=null,this.endEvent=null,this.items=[]}}function getDefaultSettings$1(){return{container:null,startPredicate:()=>!0,getElements:()=>null,releaseElements:()=>{},getStartPosition:({item:t})=>{const e=getStyle(t.element,"transform");return t._transform=e&&"none"!==e&&e!==IDENTITY_MATRIX&&e!==IDENTITY_MATRIX_3D?e:"",{x:0,y:0}},setPosition:({item:t,x:e,y:i})=>{t.element.style.transform=`translate(${e}px, ${i}px) ${t._transform}`},getPositionChange:({event:t,prevEvent:e})=>(POSITION_CHANGE.x=t.x-e.x,POSITION_CHANGE.y=t.y-e.y,POSITION_CHANGE)}}class Draggable{constructor(t,e={}){this.sensors=t,this.settings=this._parseSettings(e),this.plugins={},this.drag=null,this.isDestroyed=!1,this._sensorData=new Map,this._emitter=new Emitter,this._startId=Symbol(),this._moveId=Symbol(),this._syncId=Symbol(),this._onMove=this._onMove.bind(this),this._onScroll=this._onScroll.bind(this),this._onEnd=this._onEnd.bind(this),this._prepareStart=this._prepareStart.bind(this),this._applyStart=this._applyStart.bind(this),this._prepareMove=this._prepareMove.bind(this),this._applyMove=this._applyMove.bind(this),this._prepareSync=this._prepareSync.bind(this),this._applySync=this._applySync.bind(this),this.sensors.forEach((t=>{this._sensorData.set(t,{predicateState:DraggableStartPredicateState.PENDING,predicateEvent:null,onMove:e=>this._onMove(e,t),onEnd:e=>this._onEnd(e,t)});const{onMove:e,onEnd:i}=this._sensorData.get(t);t.on("start",e),t.on("move",e),t.on("cancel",i),t.on("end",i),t.on("destroy",i)}))}_parseSettings(t,e=getDefaultSettings$1()){const{container:i=e.container,startPredicate:s=e.startPredicate,getElements:n=e.getElements,releaseElements:r=e.releaseElements,getStartPosition:o=e.getStartPosition,setPosition:a=e.setPosition,getPositionChange:c=e.getPositionChange}=t||{};return{container:i,startPredicate:s,getElements:n,releaseElements:r,getStartPosition:o,setPosition:a,getPositionChange:c}}_emit(t,...e){this._emitter.emit(t,...e)}_onMove(t,e){const i=this._sensorData.get(e);if(i)switch(i.predicateState){case DraggableStartPredicateState.PENDING:{i.predicateEvent=t;const s=this.settings.startPredicate({draggable:this,sensor:e,event:t});!0===s?this.resolveStartPredicate(e):!1===s&&this.rejectStartPredicate(e);break}case DraggableStartPredicateState.RESOLVED:this.drag&&(this.drag.nextMoveEvent=t,ticker.once(tickerReadPhase,this._prepareMove,this._moveId),ticker.once(tickerWritePhase,this._applyMove,this._moveId))}}_onScroll(){this.fixLayoutShift()}_onEnd(t,e){const i=this._sensorData.get(e);i&&(this.drag?i.predicateState===DraggableStartPredicateState.RESOLVED&&(this.drag.endEvent=t,this._sensorData.forEach((t=>{t.predicateState=DraggableStartPredicateState.PENDING,t.predicateEvent=null})),this.stop()):(i.predicateState=DraggableStartPredicateState.PENDING,i.predicateEvent=null))}_prepareStart(){const{drag:t}=this;if(!t||!t.startEvent)return;const e=this.settings.getElements({draggable:this,sensor:t.sensor,startEvent:t.startEvent})||[];t.items=e.map((e=>{if(!e.isConnected)throw new Error("Element is not connected");const i=e.parentNode,s=getContainingBlock(i),n=this.settings.container||i,r=n===i?s:getContainingBlock(n),o=new DraggableDragItem(e,i,s,n,r),a=e.getBoundingClientRect();if(o.x=a.left,o.y=a.top,s!==r){const{left:t,top:e}=getOffsetDiff(r,s,OFFSET_DIFF);o._containerDiffX=t,o._containerDiffY=e}const{x:c,y:h}=this.settings.getStartPosition({draggable:this,sensor:t.sensor,item:o});return o.pX=c,o.pY=h,o}))}_applyStart(){const t=this.drag;if(!t||!t.startEvent)return;if(this._emit("beforestart",t.startEvent),this.drag!==t)return;const{container:e}=this.settings;if(e)for(const i of t.items)i.element&&(i.element.parentNode!==e&&(e.appendChild(i.element),i.pX+=i._containerDiffX,i.pY+=i._containerDiffY),this.settings.setPosition({phase:"start",draggable:this,sensor:t.sensor,item:i,x:i.pX,y:i.pY}));window.addEventListener("scroll",this._onScroll,SCROLL_LISTENER_OPTIONS),t.isStarted=!0,this._emit("start",t.startEvent)}_prepareMove(){const{drag:t}=this;if(!t||!t.startEvent)return;const e=t.nextMoveEvent,i=t.prevMoveEvent||t.startEvent;if(e&&e!==i){for(const s of t.items){if(!s.element)continue;const{x:n,y:r}=this.settings.getPositionChange({draggable:this,sensor:t.sensor,item:s,startEvent:t.startEvent,prevEvent:i,event:e});n&&(s.pX=s.pX-s._moveDiffX+n,s.x=s.x-s._moveDiffX+n,s._moveDiffX=n),r&&(s.pY=s.pY-s._moveDiffY+r,s.y=s.y-s._moveDiffY+r,s._moveDiffY=r)}t.prevMoveEvent=e}}_applyMove(){const{drag:t}=this;if(t&&t.nextMoveEvent){for(const e of t.items)e._moveDiffX=0,e._moveDiffY=0;if(this._emit("beforemove",t.nextMoveEvent),this.drag===t){for(const e of t.items)e.element&&this.settings.setPosition({phase:"move",draggable:this,sensor:t.sensor,item:e,x:e.pX,y:e.pY});this._emit("move",t.nextMoveEvent)}}}_prepareSync(){const{drag:t}=this;if(t)for(const e of t.items){if(!e.element)continue;if(e.rootContainingBlock!==e.dragContainingBlock){const{left:t,top:i}=getOffsetDiff(e.dragContainingBlock,e.rootContainingBlock,OFFSET_DIFF);e._containerDiffX=t,e._containerDiffY=i}const{left:t,top:i}=e.element.getBoundingClientRect(),s=e.x-e._moveDiffX-t;e.pX=e.pX-e._syncDiffX+s,e._syncDiffX=s;const n=e.y-e._moveDiffY-i;e.pY=e.pY-e._syncDiffY+n,e._syncDiffY=n}}_applySync(){const{drag:t}=this;if(t)for(const e of t.items)e.element&&(e._syncDiffX=0,e._syncDiffY=0,this.settings.setPosition({phase:"move",draggable:this,sensor:t.sensor,item:e,x:e.pX,y:e.pY}))}on(t,e,i){return this._emitter.on(t,e,i)}off(t,e){this._emitter.off(t,e)}fixLayoutShift(t=!1){this.drag&&(t?(this._prepareSync(),this._applySync()):(ticker.once(tickerReadPhase,this._prepareSync,this._syncId),ticker.once(tickerWritePhase,this._applySync,this._syncId)))}resolveStartPredicate(t,e){const i=this._sensorData.get(t);if(!i)return;const s=e||i.predicateEvent;i.predicateState===DraggableStartPredicateState.PENDING&&s&&(i.predicateState=DraggableStartPredicateState.RESOLVED,i.predicateEvent=null,this.drag=new DraggableDrag,this.drag.sensor=t,this.drag.startEvent=s,this._sensorData.forEach(((e,i)=>{i!==t&&(e.predicateState=DraggableStartPredicateState.REJECTED,e.predicateEvent=null)})),ticker.once(tickerReadPhase,this._prepareStart,this._startId),ticker.once(tickerWritePhase,this._applyStart,this._startId))}rejectStartPredicate(t){const e=this._sensorData.get(t);(null==e?void 0:e.predicateState)===DraggableStartPredicateState.PENDING&&(e.predicateState=DraggableStartPredicateState.REJECTED,e.predicateEvent=null)}stop(){const{drag:t}=this;if(t&&!t.isEnded){if(t.isEnded=!0,this._emit("beforeend",t.endEvent),ticker.off(tickerReadPhase,this._startId),ticker.off(tickerWritePhase,this._startId),ticker.off(tickerReadPhase,this._moveId),ticker.off(tickerWritePhase,this._moveId),ticker.off(tickerReadPhase,this._syncId),ticker.off(tickerWritePhase,this._syncId),t.isStarted){window.removeEventListener("scroll",this._onScroll,SCROLL_LISTENER_OPTIONS);const e=[];for(const i of t.items)i.element&&(e.push(i.element),i.rootParent&&i.element.parentNode!==i.rootParent&&(i.pX-=i._containerDiffX,i.pY-=i._containerDiffY,i._containerDiffX=0,i._containerDiffY=0,i.rootParent.appendChild(i.element)),this.settings.setPosition({phase:"end",draggable:this,sensor:t.sensor,item:i,x:i.pX,y:i.pY}));e.length&&this.settings.releaseElements({draggable:this,sensor:t.sensor,elements:e})}this._emit("end",t.endEvent),this.drag=null}}updateSettings(t={}){this.settings=this._parseSettings(t,this.settings)}use(t){return t(this)}destroy(){this.isDestroyed||(this.isDestroyed=!0,this.stop(),this._sensorData.forEach((({onMove:t,onEnd:e},i)=>{i.off("start",t),i.off("move",t),i.off("cancel",e),i.off("end",e),i.off("destroy",e)})),this._sensorData.clear(),this._emit("destroy"),this._emitter.off())}}class Pool{constructor(t,e){this._data=[],this._createObject=t,this._onPut=e}pick(){return this._data.length?this._data.pop():this._createObject()}put(t){-1===this._data.indexOf(t)&&(this._onPut&&this._onPut(t),this._data.push(t))}reset(){this._data.length=0}}function isRectsOverlapping(t,e){return!(t.right<=e.left||e.right<=t.left||t.bottom<=e.top||e.bottom<=t.top)}function getIntersectionArea(t,e){if(!isRectsOverlapping(t,e))return 0;return(Math.min(t.right,e.right)-Math.max(t.left,e.left))*(Math.min(t.bottom,e.bottom)-Math.max(t.top,e.top))}function getIntersectionScore(t,e){const i=getIntersectionArea(t,e);if(!i)return 0;return i/(Math.min(t.width,e.width)*Math.min(t.height,e.height))*100}function isWindow(t){return t===window}function getContentRect(t,e={width:0,height:0,left:0,right:0,top:0,bottom:0}){if(isWindow(t))e.width=document.documentElement.clientWidth,e.height=document.documentElement.clientHeight,e.left=0,e.right=e.width,e.top=0,e.bottom=e.height;else{const{left:i,top:s}=t.getBoundingClientRect(),n=t.clientLeft||getStyleAsFloat(t,"border-left-width"),r=t.clientTop||getStyleAsFloat(t,"border-top-width");e.width=t.clientWidth,e.height=t.clientHeight,e.left=i+n,e.right=e.left+e.width,e.top=s+r,e.bottom=e.top+e.height}return e}function distanceBetweenPoints(t,e,i,s){return Math.sqrt(Math.pow(i-t,2)+Math.pow(s-e,2))}function getDistanceBetweenRects(t,e){return isRectsOverlapping(t,e)?0:t.right<e.left?t.bottom<e.top?distanceBetweenPoints(t.right,t.bottom,e.left,e.top):t.top>e.bottom?distanceBetweenPoints(t.right,t.top,e.left,e.bottom):e.left-t.right:t.left>e.right?t.bottom<e.top?distanceBetweenPoints(t.left,t.bottom,e.right,e.top):t.top>e.bottom?distanceBetweenPoints(t.left,t.top,e.right,e.bottom):t.left-e.right:t.bottom<e.top?e.top-t.bottom:t.top-e.bottom}function getScrollElement(t){return isWindow(t)||t===document.documentElement||t===document.body?window:t}function getScrollLeft(t){return isWindow(t)?t.pageXOffset:t.scrollLeft}function getScrollLeftMax(t){return isWindow(t)&&(t=document.documentElement),t.scrollWidth-t.clientWidth}function getScrollTop(t){return isWindow(t)?t.pageYOffset:t.scrollTop}function getScrollTopMax(t){return isWindow(t)&&(t=document.documentElement),t.scrollHeight-t.clientHeight}const R1={width:0,height:0,left:0,right:0,top:0,bottom:0},R2=Object.assign({},R1),R3=Object.assign({},R1),DEFAULT_THRESHOLD=50,SPEED_DATA={direction:"none",threshold:0,distance:0,value:0,maxValue:0,duration:0,speed:0,deltaTime:0,isEnding:!1},AUTO_SCROLL_AXIS={x:1,y:2},AUTO_SCROLL_AXIS_DIRECTION={forward:4,reverse:8},AUTO_SCROLL_DIRECTION_X={none:0,left:AUTO_SCROLL_AXIS.x|AUTO_SCROLL_AXIS_DIRECTION.reverse,right:AUTO_SCROLL_AXIS.x|AUTO_SCROLL_AXIS_DIRECTION.forward},AUTO_SCROLL_DIRECTION_Y={none:0,up:AUTO_SCROLL_AXIS.y|AUTO_SCROLL_AXIS_DIRECTION.reverse,down:AUTO_SCROLL_AXIS.y|AUTO_SCROLL_AXIS_DIRECTION.forward},AUTO_SCROLL_DIRECTION=Object.assign(Object.assign({},AUTO_SCROLL_DIRECTION_X),AUTO_SCROLL_DIRECTION_Y);function getDirectionAsString(t){switch(t){case AUTO_SCROLL_DIRECTION_X.none:case AUTO_SCROLL_DIRECTION_Y.none:return"none";case AUTO_SCROLL_DIRECTION_X.left:return"left";case AUTO_SCROLL_DIRECTION_X.right:return"right";case AUTO_SCROLL_DIRECTION_Y.up:return"up";case AUTO_SCROLL_DIRECTION_Y.down:return"down";default:throw new Error(`Unknown direction value: ${t}`)}}function getPaddedRect(t,e,i){let{left:s=0,right:n=0,top:r=0,bottom:o=0}=e;return s=Math.max(0,s),n=Math.max(0,n),r=Math.max(0,r),o=Math.max(0,o),i.width=t.width+s+n,i.height=t.height+r+o,i.left=t.left-s,i.top=t.top-r,i.right=t.right+n,i.bottom=t.bottom+o,i}function isScrolledToMax(t,e){return Math.ceil(t)>=Math.floor(e)}function computeThreshold(t,e){return Math.min(e/2,t)}function computeEdgeOffset(t,e,i,s){return Math.max(0,i+2*t+s*e-s)/2}class AutoScrollItemData{constructor(){this.positionX=0,this.positionY=0,this.directionX=AUTO_SCROLL_DIRECTION.none,this.directionY=AUTO_SCROLL_DIRECTION.none,this.overlapCheckRequestTime=0}}class AutoScrollAction{constructor(){this.element=null,this.requestX=null,this.requestY=null,this.scrollLeft=0,this.scrollTop=0}reset(){this.requestX&&(this.requestX.action=null),this.requestY&&(this.requestY.action=null),this.element=null,this.requestX=null,this.requestY=null,this.scrollLeft=0,this.scrollTop=0}addRequest(t){AUTO_SCROLL_AXIS.x&t.direction?(this.requestX&&this.removeRequest(this.requestX),this.requestX=t):(this.requestY&&this.removeRequest(this.requestY),this.requestY=t),t.action=this}removeRequest(t){this.requestX===t?(this.requestX=null,t.action=null):this.requestY===t&&(this.requestY=null,t.action=null)}computeScrollValues(){this.element&&(this.scrollLeft=this.requestX?this.requestX.value:getScrollLeft(this.element),this.scrollTop=this.requestY?this.requestY.value:getScrollTop(this.element))}scroll(){this.element&&(this.element.scrollTo?this.element.scrollTo(this.scrollLeft,this.scrollTop):(this.element.scrollLeft=this.scrollLeft,this.element.scrollTop=this.scrollTop))}}class AutoScrollRequest{constructor(){this.item=null,this.element=null,this.isActive=!1,this.isEnding=!1,this.direction=0,this.value=NaN,this.maxValue=0,this.threshold=0,this.distance=0,this.deltaTime=0,this.speed=0,this.duration=0,this.action=null}reset(){this.isActive&&this.onStop(),this.item=null,this.element=null,this.isActive=!1,this.isEnding=!1,this.direction=0,this.value=NaN,this.maxValue=0,this.threshold=0,this.distance=0,this.deltaTime=0,this.speed=0,this.duration=0,this.action=null}hasReachedEnd(){return AUTO_SCROLL_AXIS_DIRECTION.forward&this.direction?isScrolledToMax(this.value,this.maxValue):this.value<=0}computeCurrentScrollValue(){return this.element?this.value!=this.value?AUTO_SCROLL_AXIS.x&this.direction?getScrollLeft(this.element):getScrollTop(this.element):Math.max(0,Math.min(this.value,this.maxValue)):0}computeNextScrollValue(){const t=this.speed*(this.deltaTime/1e3),e=AUTO_SCROLL_AXIS_DIRECTION.forward&this.direction?this.value+t:this.value-t;return Math.max(0,Math.min(e,this.maxValue))}computeSpeed(){if(!this.item||!this.element)return 0;const{speed:t}=this.item;return"function"==typeof t?(SPEED_DATA.direction=getDirectionAsString(this.direction),SPEED_DATA.threshold=this.threshold,SPEED_DATA.distance=this.distance,SPEED_DATA.value=this.value,SPEED_DATA.maxValue=this.maxValue,SPEED_DATA.duration=this.duration,SPEED_DATA.speed=this.speed,SPEED_DATA.deltaTime=this.deltaTime,SPEED_DATA.isEnding=this.isEnding,t(this.element,SPEED_DATA)):t}tick(t){return this.isActive||(this.isActive=!0,this.onStart()),this.deltaTime=t,this.value=this.computeCurrentScrollValue(),this.speed=this.computeSpeed(),this.value=this.computeNextScrollValue(),this.duration+=t,this.value}onStart(){if(!this.item||!this.element)return;const{onStart:t}=this.item;"function"==typeof t&&t(this.element,getDirectionAsString(this.direction))}onStop(){if(!this.item||!this.element)return;const{onStop:t}=this.item;"function"==typeof t&&t(this.element,getDirectionAsString(this.direction))}}function autoScrollSmoothSpeed(t=500,e=.5,i=.25){const s=t*(e>0?1/e:1/0),n=t*(i>0?1/i:1/0);return function(e,i){let r=0;if(!i.isEnding)if(i.threshold>0){const e=i.threshold-Math.max(0,i.distance);r=t/i.threshold*e}else r=t;const o=i.speed;if(o===r)return r;let a=r;return o<r?(a=o+s*(i.deltaTime/1e3),Math.min(r,a)):(a=o-n*(i.deltaTime/1e3),Math.max(r,a))}}class AutoScroll{constructor(t={}){const{overlapCheckInterval:e=150}=t;this.items=[],this.settings={overlapCheckInterval:e},this._actions=[],this._isDestroyed=!1,this._isTicking=!1,this._tickTime=0,this._tickDeltaTime=0,this._requests={[AUTO_SCROLL_AXIS.x]:new Map,[AUTO_SCROLL_AXIS.y]:new Map},this._itemData=new Map,this._requestPool=new Pool((()=>new AutoScrollRequest),(t=>t.reset())),this._actionPool=new Pool((()=>new AutoScrollAction),(t=>t.reset())),this._emitter=new Emitter,this._frameRead=this._frameRead.bind(this),this._frameWrite=this._frameWrite.bind(this)}_frameRead(t){this._isDestroyed||(t&&this._tickTime?(this._tickDeltaTime=t-this._tickTime,this._tickTime=t,this._updateItems(),this._updateRequests(),this._updateActions()):(this._tickTime=t,this._tickDeltaTime=0))}_frameWrite(){this._isDestroyed||this._applyActions()}_startTicking(){this._isTicking||(this._isTicking=!0,ticker.on(tickerReadPhase,this._frameRead),ticker.on(tickerWritePhase,this._frameWrite))}_stopTicking(){this._isTicking&&(this._isTicking=!1,this._tickTime=0,this._tickDeltaTime=0,ticker.off(tickerReadPhase,this._frameRead),ticker.off(tickerWritePhase,this._frameWrite))}_getItemClientRect(t,e={width:0,height:0,left:0,right:0,top:0,bottom:0}){const{clientRect:i}=t;return e.left=i.left,e.top=i.top,e.width=i.width,e.height=i.height,e.right=i.left+i.width,e.bottom=i.top+i.height,e}_requestItemScroll(t,e,i,s,n,r,o){const a=this._requests[e];let c=a.get(t);c?c.element===i&&c.direction===s||c.reset():(c=this._requestPool.pick(),a.set(t,c)),c.item=t,c.element=i,c.direction=s,c.threshold=n,c.distance=r,c.maxValue=o}_cancelItemScroll(t,e){const i=this._requests[e],s=i.get(t);s&&(s.action&&s.action.removeRequest(s),this._requestPool.put(s),i.delete(t))}_checkItemOverlap(t,e,i){const{inertAreaSize:s,targets:n}=t;if(!n.length)return e&&this._cancelItemScroll(t,AUTO_SCROLL_AXIS.x),void(i&&this._cancelItemScroll(t,AUTO_SCROLL_AXIS.y));const r=this._itemData.get(t),o=r.directionX,a=r.directionY;if(!o&&!a)return e&&this._cancelItemScroll(t,AUTO_SCROLL_AXIS.x),void(i&&this._cancelItemScroll(t,AUTO_SCROLL_AXIS.y));const c=this._getItemClientRect(t,R1);let h=null,l=-1/0,d=0,_=-1/0,u=AUTO_SCROLL_DIRECTION.none,g=0,S=0,p=null,m=-1/0,f=0,E=-1/0,v=AUTO_SCROLL_DIRECTION.none,T=0,O=0,y=0;for(;y<n.length;y++){const t=n[y],r="number"==typeof t.threshold?t.threshold:50,L=!(!e||!o||"y"===t.axis),R=!(!i||!a||"x"===t.axis),D=t.priority||0;if((!L||D<l)&&(!R||D<m))continue;const I=getScrollElement(t.element||t),A=L?getScrollLeftMax(I):-1,C=R?getScrollTopMax(I):-1;if(A<=0&&C<=0)continue;const P=getContentRect(I,R2);let w=getIntersectionScore(c,P)||-1/0;if(w===-1/0){if(!t.padding||!isRectsOverlapping(c,getPaddedRect(P,t.padding,R3)))continue;w=-getDistanceBetweenRects(c,P)}if(L&&D>=l&&A>0&&(D>l||w>_)){let t=0,e=AUTO_SCROLL_DIRECTION.none;const i=computeThreshold(r,P.width),n=computeEdgeOffset(i,s,c.width,P.width);o===AUTO_SCROLL_DIRECTION.right?(t=P.right+n-c.right,t<=i&&!isScrolledToMax(getScrollLeft(I),A)&&(e=AUTO_SCROLL_DIRECTION.right)):o===AUTO_SCROLL_DIRECTION.left&&(t=c.left-(P.left-n),t<=i&&getScrollLeft(I)>0&&(e=AUTO_SCROLL_DIRECTION.left)),e&&(h=I,l=D,d=i,_=w,u=e,g=t,S=A)}if(R&&D>=m&&C>0&&(D>m||w>E)){let t=0,e=AUTO_SCROLL_DIRECTION_Y.none;const i=computeThreshold(r,P.height),n=computeEdgeOffset(i,s,c.height,P.height);a===AUTO_SCROLL_DIRECTION.down?(t=P.bottom+n-c.bottom,t<=i&&!isScrolledToMax(getScrollTop(I),C)&&(e=AUTO_SCROLL_DIRECTION.down)):a===AUTO_SCROLL_DIRECTION.up&&(t=c.top-(P.top-n),t<=i&&getScrollTop(I)>0&&(e=AUTO_SCROLL_DIRECTION.up)),e&&(p=I,m=D,f=i,E=w,v=e,T=t,O=C)}}e&&(h&&u?this._requestItemScroll(t,AUTO_SCROLL_AXIS.x,h,u,d,g,S):this._cancelItemScroll(t,AUTO_SCROLL_AXIS.x)),i&&(p&&v?this._requestItemScroll(t,AUTO_SCROLL_AXIS.y,p,v,f,T,O):this._cancelItemScroll(t,AUTO_SCROLL_AXIS.y))}_updateScrollRequest(t){const e=t.item,{inertAreaSize:i,smoothStop:s,targets:n}=e,r=this._getItemClientRect(e,R1);let o=null,a=0;for(;a<n.length;a++){const e=n[a],s=getScrollElement(e.element||e);if(s!==t.element)continue;const c=!!(AUTO_SCROLL_AXIS.x&t.direction);if(c){if("y"===e.axis)continue}else if("x"===e.axis)continue;const h=c?getScrollLeftMax(s):getScrollTopMax(s);if(h<=0)break;const l=getContentRect(s,R2);if((getIntersectionScore(r,l)||-1/0)===-1/0){const t=e.scrollPadding||e.padding;if(!t||!isRectsOverlapping(r,getPaddedRect(l,t,R3)))break}const d=computeThreshold("number"==typeof e.threshold?e.threshold:50,c?l.width:l.height),_=computeEdgeOffset(d,i,c?r.width:r.height,c?l.width:l.height);let u=0;if(u=t.direction===AUTO_SCROLL_DIRECTION.left?r.left-(l.left-_):t.direction===AUTO_SCROLL_DIRECTION.right?l.right+_-r.right:t.direction===AUTO_SCROLL_DIRECTION.up?r.top-(l.top-_):l.bottom+_-r.bottom,u>d)break;const g=c?getScrollLeft(s):getScrollTop(s);if(o=AUTO_SCROLL_AXIS_DIRECTION.forward&t.direction?isScrolledToMax(g,h):g<=0,o)break;return t.maxValue=h,t.threshold=d,t.distance=u,t.isEnding=!1,!0}return!0===s&&t.speed>0?(null===o&&(o=t.hasReachedEnd()),t.isEnding=!o):t.isEnding=!1,t.isEnding}_updateItems(){for(let t=0;t<this.items.length;t++){const e=this.items[t],i=this._itemData.get(e),{x:s,y:n}=e.position,r=i.positionX,o=i.positionY;s===r&&n===o||(i.directionX=s>r?AUTO_SCROLL_DIRECTION.right:s<r?AUTO_SCROLL_DIRECTION.left:i.directionX,i.directionY=n>o?AUTO_SCROLL_DIRECTION.down:n<o?AUTO_SCROLL_DIRECTION.up:i.directionY,i.positionX=s,i.positionY=n,0===i.overlapCheckRequestTime&&(i.overlapCheckRequestTime=this._tickTime))}}_updateRequests(){const t=this.items,e=this._requests[AUTO_SCROLL_AXIS.x],i=this._requests[AUTO_SCROLL_AXIS.y];let s=0;for(;s<t.length;s++){const n=t[s],r=this._itemData.get(n),o=r.overlapCheckRequestTime;let a=o>0&&this._tickTime-o>this.settings.overlapCheckInterval,c=!0;const h=e.get(n);h&&h.isActive&&(c=!this._updateScrollRequest(h),c&&(a=!0,this._cancelItemScroll(n,AUTO_SCROLL_AXIS.x)));let l=!0;const d=i.get(n);d&&d.isActive&&(l=!this._updateScrollRequest(d),l&&(a=!0,this._cancelItemScroll(n,AUTO_SCROLL_AXIS.y))),a&&(r.overlapCheckRequestTime=0,this._checkItemOverlap(n,c,l))}}_requestAction(t,e){const i=e===AUTO_SCROLL_AXIS.x;let s=null,n=0;for(;n<this._actions.length;n++){if(s=this._actions[n],t.element===s.element){if(i?s.requestX:s.requestY)return void this._cancelItemScroll(t.item,e);break}s=null}s||(s=this._actionPool.pick()),s.element=t.element,s.addRequest(t),t.tick(this._tickDeltaTime),this._actions.push(s)}_updateActions(){let t=0;for(t=0;t<this.items.length;t++){const e=this.items[t],i=this._requests[AUTO_SCROLL_AXIS.x].get(e),s=this._requests[AUTO_SCROLL_AXIS.y].get(e);i&&this._requestAction(i,AUTO_SCROLL_AXIS.x),s&&this._requestAction(s,AUTO_SCROLL_AXIS.y)}for(t=0;t<this._actions.length;t++)this._actions[t].computeScrollValues()}_applyActions(){if(!this._actions.length)return;this._emitter.emit("beforescroll");let t,e=0;for(e=0;e<this._actions.length;e++)this._actions[e].scroll(),this._actionPool.put(this._actions[e]);for(this._actions.length=0,e=0;e<this.items.length;e++)t=this.items[e],t.onPrepareScrollEffect&&t.onPrepareScrollEffect();for(e=0;e<this.items.length;e++)t=this.items[e],t.onApplyScrollEffect&&t.onApplyScrollEffect();this._emitter.emit("afterscroll")}on(t,e){return this._emitter.on(t,e)}off(t,e){this._emitter.off(t,e)}addItem(t){if(this._isDestroyed||this._itemData.has(t))return;const{x:e,y:i}=t.position,s=new AutoScrollItemData;s.positionX=e,s.positionY=i,s.directionX=AUTO_SCROLL_DIRECTION.none,s.directionY=AUTO_SCROLL_DIRECTION.none,s.overlapCheckRequestTime=this._tickTime,this._itemData.set(t,s),this.items.push(t),this._isTicking||this._startTicking()}removeItem(t){if(this._isDestroyed)return;const e=this.items.indexOf(t);-1!==e&&(this._requests[AUTO_SCROLL_AXIS.x].get(t)&&(this._cancelItemScroll(t,AUTO_SCROLL_AXIS.x),this._requests[AUTO_SCROLL_AXIS.x].delete(t)),this._requests[AUTO_SCROLL_AXIS.y].get(t)&&(this._cancelItemScroll(t,AUTO_SCROLL_AXIS.y),this._requests[AUTO_SCROLL_AXIS.y].delete(t)),this._itemData.delete(t),this.items.splice(e,1),this._isTicking&&!this.items.length&&this._stopTicking())}isDestroyed(){return this._isDestroyed}isItemScrollingX(t){var e;return!!(null===(e=this._requests[AUTO_SCROLL_AXIS.x].get(t))||void 0===e?void 0:e.isActive)}isItemScrollingY(t){var e;return!!(null===(e=this._requests[AUTO_SCROLL_AXIS.y].get(t))||void 0===e?void 0:e.isActive)}isItemScrolling(t){return this.isItemScrollingX(t)||this.isItemScrollingY(t)}updateSettings(t={}){const{overlapCheckInterval:e=this.settings.overlapCheckInterval}=t;this.settings.overlapCheckInterval=e}destroy(){if(this._isDestroyed)return;const t=this.items.slice(0);let e=0;for(;e<t.length;e++)this.removeItem(t[e]);this._actions.length=0,this._requestPool.reset(),this._actionPool.reset(),this._emitter.off(),this._isDestroyed=!0}}const autoScroll=new AutoScroll,AUTOSCROLL_POSITION={x:0,y:0},AUTOSCROLL_CLIENT_RECT={left:0,top:0,width:0,height:0};function getDefaultSettings(){return{targets:[],inertAreaSize:.2,speed:autoScrollSmoothSpeed(),smoothStop:!1,getPosition:t=>{const{drag:e}=t,i=null==e?void 0:e.items[0];if(i)AUTOSCROLL_POSITION.x=i.pX,AUTOSCROLL_POSITION.y=i.pY;else{const t=e&&(e.nextMoveEvent||e.startEvent);AUTOSCROLL_POSITION.x=t?t.x:0,AUTOSCROLL_POSITION.y=t?t.y:0}return AUTOSCROLL_POSITION},getClientRect:t=>{const{drag:e}=t,i=null==e?void 0:e.items[0];if(i&&i.element){const{left:t,top:e,width:s,height:n}=i.element.getBoundingClientRect();AUTOSCROLL_CLIENT_RECT.left=t,AUTOSCROLL_CLIENT_RECT.top=e,AUTOSCROLL_CLIENT_RECT.width=s,AUTOSCROLL_CLIENT_RECT.height=n}else{const t=e&&(e.nextMoveEvent||e.startEvent);AUTOSCROLL_CLIENT_RECT.left=t?t.x-25:0,AUTOSCROLL_CLIENT_RECT.top=t?t.y-25:0,AUTOSCROLL_CLIENT_RECT.width=t?50:0,AUTOSCROLL_CLIENT_RECT.height=t?50:0}return AUTOSCROLL_CLIENT_RECT},onStart:null,onStop:null}}class DraggableAutoScrollProxy{constructor(t,e){this._draggableAutoScroll=t,this._draggable=e,this._position={x:0,y:0},this._clientRect={left:0,top:0,width:0,height:0}}_getSettings(){return this._draggableAutoScroll.settings}get targets(){let{targets:t}=this._getSettings();return"function"==typeof t&&(t=t(this._draggable)),t}get position(){let{getPosition:t}=this._getSettings();if("function"==typeof t){const e=t(this._draggable);this._position.x=e.x,this._position.y=e.y}else this._position.x=0,this._position.y=0;return this._position}get clientRect(){let{getClientRect:t}=this._getSettings();if("function"==typeof t){const{left:e,top:i,width:s,height:n}=t(this._draggable);this._clientRect.left=e,this._clientRect.top=i,this._clientRect.width=s,this._clientRect.height=n}else this._clientRect.left=0,this._clientRect.top=0,this._clientRect.width=0,this._clientRect.height=0;return this._clientRect}get inertAreaSize(){return this._getSettings().inertAreaSize}get smoothStop(){return this._getSettings().smoothStop}get speed(){return this._getSettings().speed}get onStart(){return this._getSettings().onStart}get onStop(){return this._getSettings().onStop}onPrepareScrollEffect(){const t=this._draggable._syncId;ticker.off(tickerReadPhase,t),ticker.off(tickerWritePhase,t),this._draggable._prepareSync()}onApplyScrollEffect(){this._draggable._applySync()}}class DraggableAutoScroll{constructor(t,e={}){this.name="autoscroll",this.version="0.0.2",this.settings=this._parseSettings(e),this._autoScrollProxy=null,t.on("start",(()=>{this._autoScrollProxy||(this._autoScrollProxy=new DraggableAutoScrollProxy(this,t),autoScroll.addItem(this._autoScrollProxy))})),t.on("beforeend",(()=>{this._autoScrollProxy&&(autoScroll.removeItem(this._autoScrollProxy),this._autoScrollProxy=null)}))}_parseSettings(t,e=getDefaultSettings()){const{targets:i=e.targets,inertAreaSize:s=e.inertAreaSize,speed:n=e.speed,smoothStop:r=e.smoothStop,getPosition:o=e.getPosition,getClientRect:a=e.getClientRect,onStart:c=e.onStart,onStop:h=e.onStop}=t||{};return{targets:i,inertAreaSize:s,speed:n,smoothStop:r,getPosition:o,getClientRect:a,onStart:c,onStop:h}}updateSettings(t={}){this.settings=this._parseSettings(t,this.settings)}}function autoScrollPlugin(t){return e=>{const i=new DraggableAutoScroll(e,t),s=e;return s.plugins[i.name]=i,s}}const SCROLLABLE_OVERFLOWS=new Set(["auto","scroll","overlay"]);function isScrollable(t){return!!(SCROLLABLE_OVERFLOWS.has(getStyle(t,"overflow"))||SCROLLABLE_OVERFLOWS.has(getStyle(t,"overflow-x"))||SCROLLABLE_OVERFLOWS.has(getStyle(t,"overflow-y")))}function getScrollableAncestors(t,e=[]){let i=null;for(;t&&(i=t.parentNode,i&&!(i instanceof Document));)isScrollable(t="host"in i?i.host:i)&&e.push(t);return e.push(window),e}function getScrollables(t){const e=[];return isScrollable(t)&&e.push(t),getScrollableAncestors(t,e),e}function createPointerSensorStartPredicate(t={}){let e,i,s=0,n=null;const{timeout:r=250,fallback:o=(()=>!0)}=t,a=t=>t.preventDefault(),c=t=>{s&&(e?t.cancelable&&t.preventDefault():void 0===e&&(t.cancelable&&t.timeStamp-s>r?(e=!0,t.preventDefault()):e=!1))};return t=>{if(!(t.sensor instanceof PointerSensor))return o(t);const{draggable:h,sensor:l,event:d}=t,_=d;if("touch"===_.pointerType){if("start"===_.type&&("pointerdown"===_.srcEvent.type||"touchstart"===_.srcEvent.type)){n=_.target;const t=n?getScrollables(n):[];t.forEach((t=>{t.addEventListener("touchmove",c,{passive:!1,capture:!0})}));const o=()=>{s&&(h.off("beforeend",o),h.sensors.forEach((t=>{t instanceof PointerSensor&&t.off("end",o)})),null==n||n.removeEventListener("contextmenu",a),t.forEach((t=>{t.removeEventListener("touchmove",c,{capture:!0})})),s=0,e=void 0,n=null,i=void window.clearTimeout(i))};e=void 0,s=_.srcEvent.timeStamp,null==n||n.addEventListener("contextmenu",a),h.on("beforeend",o),h.sensors.forEach((t=>{t instanceof PointerSensor&&t.off("end",o)})),r>0&&(i=window.setTimeout((()=>{h.resolveStartPredicate(l),e=!0,i=void 0}),r))}return e}return"start"===_.type&&!_.srcEvent.button}}export{AUTO_SCROLL_AXIS,AUTO_SCROLL_AXIS_DIRECTION,AUTO_SCROLL_DIRECTION,AutoScroll,BaseMotionSensor,BaseSensor,Draggable,DraggableAutoScroll,KeyboardMotionSensor,KeyboardSensor,PointerSensor,SensorEventType,autoScroll,autoScrollPlugin,autoScrollSmoothSpeed,createPointerSensorStartPredicate,setTicker,ticker,tickerReadPhase,tickerWritePhase};